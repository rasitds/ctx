---
title: "ctx v0.2.0: The Archaeology Release"
date: 2026-02-01
author: Jose Alekhinne
topics:
  - session recall
  - journal system
  - structured entries
  - token budgets
  - meta-tools
---

# ctx v0.2.0: The Archaeology Release

!!! note "Update (2026-02-11)"
    As of v0.4.0, ctx consolidated sessions into the journal mechanism.
    The `.context/sessions/` directory referenced in this post has been
    eliminated. Session history is now accessed via `ctx recall` and
    enriched journals live in `.context/journal/`.

![ctx](../images/ctx-banner.png)

## Digging Through the Past to Build the Future

*Jose Alekhinne / 2026-02-01*

!!! question "What if your AI could remember everything?"
    Not just the current session, but **every** session:

    * **Every** decision made,
    * **every** mistake avoided, 
    * **every** path not taken.

    That's what v0.2.0 delivers.

Between `v0.1.2` and `v0.2.0`, **86 commits landed across 5 days**. 

The release notes list features and fixes. 

This post tells the story of **why** those features exist, and what 
building them taught me.

**This isn't a changelog**: It is an explanation of intent.

## The Problem: Amnesia Isn't Just Session-Level

v0.1.0 solved **reset amnesia**: 

The AI now **remembers** *decisions*, *learnings*,
and *tasks* **across sessions**. 

But a new problem emerged, which I can sum up as: "I (*the human*) am not AI".

Frankly, **I couldn't remember what the AI remembered.**

In the course of days, I realized session transcripts piled up in 
`.context/sessions/`; I was `grep`ping, `JSONL` files with
thousands of lines... Raw tool calls, assistant responses, user messages...
all interleaved. 

Valuable context effectively buried in machine-readable noise.

I found myself grepping through files to answer questions like:

* "When did we decide to use constants instead of literals?"
* "What was the session where we fixed the hook regex?"
* "How did the `embed.go` split actually happen?"

!!! note "Fate is Whimsical"
    The irony was **painful**: 
    I built a tool to prevent AI amnesia, but I was suffering from 
    **human amnesia** about what happened in AI sessions.

This was the moment `ctx` stopped being just an AI tool and started
needing to support **the human** on the other side of the loop.

## The Solution: Recall and Journal

v0.2.0 introduces two interconnected systems.

They solve different problems; and only work well together.

### `ctx recall`: Browse Your Past

```bash
# List all sessions for this project
ctx recall list

# Show a specific session
ctx recall show gleaming-wobbling-sutherland

# See the full transcript
ctx recall show gleaming-wobbling-sutherland --full
````

The `recall` system parses Claude Code's JSONL transcripts and presents
them in a human-readable format:

| Session                       | Date       | Turns | Duration |
|-------------------------------|------------|-------|----------|
| tender-painting-sundae        | 2026-01-29 | 3     | <1m      |
| crystalline-gliding-willow    | 2026-01-29 | 3     | <1m      |
| declarative-hugging-snowglobe | 2026-01-31 | 2     | <1m      |

Slugs are auto-generated from session IDs (*memorable names instead of
UUIDs*). The goal (*as the name implies*) is **recall**, not archival accuracy.

!!! note "2,121 lines of new code"
    The `ctx recall` feature was the largest single addition:
    parser library, CLI commands, test suite, and slash command.

### `ctx journal`: From Raw to Rich

Listing sessions isn't enough. The transcripts are still unwieldy.

Recall answers *what happened*.
Journal answers *what mattered*.

```bash
# Export sessions to editable Markdown
ctx recall export --all

# Generate a static site from journal entries
ctx journal site

# Serve it locally
ctx serve
```

The exported files land in `.context/journal/`:

```
.context/journal/
├── 2026-01-28-proud-sleeping-cook-6e535360.md
├── 2026-01-29-tender-painting-sundae-b14ddaaa.md
├── 2026-01-29-crystalline-gliding-willow-ff7fd67d.md
└── 2026-01-31-declarative-hugging-snowglobe-4549026d.md
```

Each file is a structured Markdown document ready for enrichment.

They are meant to be **read**, **edited**, and **reasoned about**; 
not just stored.

## The Meta: Slash Commands for Self-Analysis

The journal system includes four slash commands that use Claude to
analyze and synthesize session history:

| Command                  | Purpose                          |
|--------------------------|----------------------------------|
| `/ctx-journal-enrich`    | Add frontmatter, topics, tags    |
| `/ctx-blog`              | Generate blog post from activity |
| `/ctx-blog-changelog`    | Generate changelog from commits  |

This very post was drafted using `/ctx-blog`. The previous post about
refactoring was drafted the same way.

So, yes: **The meta continues**: `ctx` now helps write posts about `ctx`.

With the current release, `ctx` is no longer just recording history: It is
**participating** in its **interpretation**.

## The Structure: Decisions as First-Class Citizens

`v0.1.0` let you add decisions with a simple command:

```bash
ctx add decision "Use PostgreSQL"
```

But sessions showed a pattern: decisions added this way were incomplete.
Context was missing. Rationale was vague. Consequences were never stated.

Once recall and journaling existed, this weakness became impossible
to ignore. Structure stopped being optional.

`v0.2.0` **enforces** structure:

```bash
ctx add decision "Use PostgreSQL" \
  --context "Need a reliable database for user data" \
  --rationale "ACID compliance, team familiarity, strong ecosystem" \
  --consequences "Need to set up connection pooling, team training"
```

All three flags are **required**. No more placeholder text. 

Every decision is now a proper Architecture Decision Record (*ADR),
not a note.

The same enforcement applies to learnings, too:

```bash
ctx add learning "CGO breaks ARM64 builds" \
  --context "go test failed with gcc errors on ARM64" \
  --lesson "Always use CGO_ENABLED=0 for cross-platform builds" \
  --application "Added to Makefile and CI config"
```

!!! quote "Structured entries are prompts to the AI"
    When the AI reads a decision with full context, rationale, and
    consequences, it understands the **why**, *not* just the **what**.

One-liners teach nothing.

## The Order: Newest First

A subtle but important change: `DECISIONS.md` and `LEARNINGS.md` now use
**reverse-chronological order**.

One reason is token budgets, obviously; **another** reason is to
help your fellow human (*i.e., the Author*): Earlier decisions are more likely
to be relevant, and they are more likely to have more emphasis on the
project. So it follows that they should be read first.

But back to AI:

When the AI reads a file, it reads from the top. If the token budget is
tight, old content gets truncated. As in any good engineering practice,
it's always *about the tradeoffs*.

Reverse order ensures the most recent—and most relevant—context is
always loaded first.

## The Index: Quick Reference Tables

`DECISIONS.md` and `LEARNINGS.md` now include auto-generated indexes.

* **For AI agents**, the index allows scanning without reading full entries.
* **For humans**, it's a table of contents.

The same structure serves two very different readers.

## The Configuration: .contextrc

Projects can now customize ctx behavior via `.contextrc`.

This makes ctx usable in real teams, not just personal projects.

Priority order: CLI flags > environment variables > .contextrc > defaults

## The Flags: Global CLI Options

Three new global flags work with any command.

These enable automation: 

CI pipelines, scripts, and long-running tools can now integrate 
`ctx` without hacks or workarounds.

## The Refactoring: Under the Hood

These aren't user-visible changes.

They are the kind of work you only appreciate later, when everything
else becomes easier to build.

## What We Learned Building v0.2.0

### 1. Raw Data Isn't Knowledge

`JSONL` transcripts contain **everything**, and I mean "**everything**":
They even contain hidden system messages that Anthropic injects to the
LLM's conversation to treat humans better: It's immense.

But "*everything*" isn't useful until it is transformed into something
a human can **reason** about.

### 2. Enforcement > Documentation

!!! quote "The Prompt is a Guideline"
    The code is more what you'd call '*guidelines*' than actual rules.
    
    —**Hector Barbossa**

Rules written in Markdown are **suggestions**.

Rules enforced by the CLI **shape behavior**; both for humans and AI.

### 3. Token Budget Is UX

File order decides what the AI sees.

That makes it a **user experience** concern, not an *implementation detail*.

### 4. Meta-Tools Compound

Tools that analyze their own development tend to generalize well.

The journal system started as a way to understand ctx itself.

It immediately became useful for everything else.

## v0.2.0 in The Numbers

This was a heavy release. The numbers reflect that:

| Metric                       | v0.1.2 | v0.2.0 |
|------------------------------|--------|--------|
| Commits since last           | -      | 86     |
| New commands                 | 15     | 21     |
| Slash commands               | 7      | 11     |
| Lines of Go                  | ~6,500 | ~9,200 |
| Session files (this project) | 40     | 54     |

The binary grew. The capability grew **more**.

## What's Next

But those are future posts.

This one was about making the **past** usable.

## Get Started

```bash
go install github.com/ActiveMemory/ctx/cmd/ctx@latest
ctx init
```

!!! quote "The Archaeological Record"
    `v0.2.0` is the archaeology release because it makes the past accessible.

Session transcripts aren't just logs anymore: They are a **searchable**,
**exportable**, **analyzable** record of how your project evolved.

**The AI remembers**. Now you can too.

---

*This blog post was generated with the help of `ctx` using the
`/ctx-blog` slash command, with full access to git history,
session files, decision logs, and learning logs from the
v0.2.0 development window.*
