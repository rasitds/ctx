{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"The ctx Manifesto","text":"","path":["The ctx Manifesto"],"tags":[]},{"location":"#ctx-manifesto","level":1,"title":"<code>ctx</code> Manifesto","text":"<p>Creation, not code.</p> <p>Context, not prompts.</p> <p>Verification, not vibes.</p> <p>This Is NOT a Metaphor</p> <p>Code executes instructions.</p> <p>Creation produces outcomes.</p> <p>Confusing the two is how teams ship motion instead of progress.</p> <ul> <li>It was never about the code.</li> <li>Code has zero standalone value.</li> <li>Code is an implementation detail.</li> </ul> <p>Code is an incantation.</p> <p>Creation is the act.</p> <p>And creation does not happen in a vacuum.</p>","path":["The ctx Manifesto"],"tags":[]},{"location":"#ctx-is-the-substrate","level":2,"title":"<code>ctx</code> Is the Substrate","text":"<p>Constraints Have Moved</p> <p>Human bandwidth is no longer the limiting factor.</p> <p>Context integrity is.</p> <p>Human bandwidth is no longer the constraint.</p> <p><code>ctx</code> is.</p> <ul> <li>Without durable context, intelligence resets.</li> <li>Without memory, reasoning decays.</li> <li>Without structure, scale collapses.</li> </ul> <p>Creation is now limited by:</p> <ul> <li>Clarity of intent;</li> <li>Quality of context;</li> <li>Rigor of verification.</li> </ul> <p>Not by speed.</p> <p>Not by capacity.</p> <p>Velocity Amplifies</p> <p>Faster execution on broken context compounds error.</p> <p>Speed multiplies whatever is already wrong.</p>","path":["The ctx Manifesto"],"tags":[]},{"location":"#humans-author-meaning","level":2,"title":"Humans Author Meaning","text":"<p>Intent Is Authored</p> <p>Systems can optimize.</p> <p>Models can generalize.</p> <p>Meaning must be chosen.</p> <p>Intent is not emergent.</p> <p>Vision, goals, and direction are human responsibilities.</p> <p>We decide:</p> <ul> <li>What matters;</li> <li>What success means;</li> <li>What world we are building.</li> </ul> <p><code>ctx</code> encodes the intent so it</p> <ul> <li>survives time,</li> <li>survives handoffs,</li> <li>survives scale.</li> </ul> <p>Nothing important should live only in conversation.</p> <p>Nothing critical should depend on recall.</p> <p>Oral Tradition Does not Scale</p> <p>If intent cannot be inspected, it cannot be enforced.</p>","path":["The ctx Manifesto"],"tags":[]},{"location":"#ctx-before-action","level":2,"title":"<code>ctx</code> Before Action","text":"<p>Orientation Precedes Motion</p> <p>Acting first and understanding later is not bravery.</p> <p>It is debt.</p> <p>Never act without <code>ctx</code>.</p> <p>Before execution, we must verify:</p> <ul> <li>Where we are;</li> <li>Why we are here;</li> <li>What constraints apply;</li> <li>What assumptions are active.</li> </ul> <p>Action without <code>ctx</code> is gambling. Speed without orientation is noise.</p> <p><code>ctx</code> is not overhead: It is the cost of correctness.</p>","path":["The ctx Manifesto"],"tags":[]},{"location":"#persistent-context-beats-prompt-memory","level":2,"title":"Persistent Context Beats Prompt Memory","text":"<p>Transience Is the Default Failure Mode</p> <ul> <li>Prompts decay.</li> <li>Chats fragment.</li> <li>Memory heuristics drift.</li> </ul> <p>Prompts are transient.</p> <p>Chats are lossy.</p> <p>Memory heuristics drift.</p> <p>Context must be:</p> <ul> <li>Durable;</li> <li>Structured;</li> <li>Explicit;</li> <li>Queryable.</li> </ul> <p>Knowledge lives in the artifacts:</p> <ul> <li>Decisions;</li> <li>Documentation;</li> <li>Dependency maps;</li> <li>Evaluation history.</li> </ul> <p>If intent exists only in a prompt, alignment is already degrading.</p> <p>Artifacts Outlive Sessions</p> <p>What is not written will be re-learned.</p> <p>At full cost.</p>","path":["The ctx Manifesto"],"tags":[]},{"location":"#what-ctx-is-not","level":2,"title":"What <code>ctx</code> Is Not","text":"<p>Avoid Category Errors</p> <p>Mislabeling <code>ctx</code> guarantees misuse.</p> <p><code>ctx</code> is not a memory feature.</p> <ul> <li><code>ctx</code> is not prompt engineering.</li> <li><code>ctx</code> is not a productivity hack.</li> <li><code>ctx</code> is not automation theater.</li> </ul> <p><code>ctx</code> is a system for preserving intent under scale.</p> <p><code>ctx</code> is infrastructure.</p>","path":["The ctx Manifesto"],"tags":[]},{"location":"#verified-reality-is-the-scoreboard","level":2,"title":"Verified Reality Is the Scoreboard","text":"<p>Activity is a False Proxy</p> <p>Output volume correlates poorly with impact.</p> <ul> <li>Code is not progress.</li> <li>Activity is not impact.</li> </ul> <p>The only truth that compounds is verified change in the real world.</p> <p>Hypotheses are cheap; outcomes are not.</p> <p><code>ctx</code> captures:</p> <ul> <li>What we expected;</li> <li>What we observed;</li> <li>Where reality diverged.</li> </ul> <p>If we cannot predict, measure, and verify the result...</p> <p>...it does not count.</p>","path":["The ctx Manifesto"],"tags":[]},{"location":"#build-to-learn-not-to-accumulate","level":2,"title":"Build to Learn, Not to Accumulate","text":"<p>Prototypes Have an Expiration Date</p> <p>A prototype's value is information, not longevity.</p> <p>Prototypes exist to reduce uncertainty.</p> <p>We build to:</p> <ul> <li>Test assumptions;</li> <li>Validate architecture;</li> <li>Answer specific questions.</li> </ul> <p>Not everything.</p> <p>Not blindly.</p> <p>Not permanently.</p> <p><code>ctx</code> records archeology so the cost is paid once.</p>","path":["The ctx Manifesto"],"tags":[]},{"location":"#failures-are-assets","level":2,"title":"Failures Are Assets","text":"<p>Failure Without Capture is Waste</p> <p>Pain that does not teach is pure loss.</p> <p>Failures are not erased: They are preserved.</p> <p>Each failure becomes:</p> <ul> <li>A documented hypothesis;</li> <li>An analyzed deviation;</li> <li>A permanent artifact.</li> </ul> <p>Rollback fixes symptoms: <code>ctx</code> fixes systems.</p> <p>A repeated mistake is a missing <code>ctx</code> artifact.</p>","path":["The ctx Manifesto"],"tags":[]},{"location":"#structure-enables-scale","level":2,"title":"Structure Enables Scale","text":"<p>Unbounded Autonomy Destabilizes</p> <p>Power without a structure produces chaos.</p> <p>Transpose it:</p> <p>Power without any structure becomes chaos.</p> <p><code>ctx</code> defines:</p> <ul> <li>Roles;</li> <li>Boundaries;</li> <li>Protocols;</li> <li>Escalation paths;</li> <li>Decision rights.</li> </ul> <p>Ambiguity is a system failure.</p> <ul> <li>Debates must be structured.</li> <li>Decisions must be explicit.</li> <li>History must be retained.</li> </ul>","path":["The ctx Manifesto"],"tags":[]},{"location":"#encode-intent-into-the-environment","level":2,"title":"Encode Intent Into the Environment","text":"<p>Goodwill Does not Belong to the Table</p> <p>Alignment that depends on memory will decay.</p> <p>Alignment cannot depend on memory or goodwill.</p> <p>Don't leave goodwill on the table.</p> <p>Intent is encoded as:</p> <ul> <li>Policies;</li> <li>Schemas;</li> <li>Constraints;</li> <li>Evaluation harnesses.</li> </ul> <p>Rules must be machine-readable.</p> <p>Laws must be enforceable.</p> <p>If intent is implicit, drift is guaranteed.</p>","path":["The ctx Manifesto"],"tags":[]},{"location":"#cost-is-a-first-class-signal","level":2,"title":"Cost Is a First-Class Signal","text":"<p>Attention Is the Scarcest Resource</p> <p>Not ideas.</p> <p>Not ambition.</p> <p>Ideas do not compete on time: They compete on cost and impact:</p> <ul> <li>Attention is finite.</li> <li>Compute is finite.</li> <li>Context is expensive.</li> </ul> <p>We continuously ask:</p> <ul> <li>What is the most valuable next action</li> <li>What outcome justifies the cost</li> </ul> <p><code>ctx</code> guides allocation.</p> <p>Learning reshapes priority.</p>","path":["The ctx Manifesto"],"tags":[]},{"location":"#show-the-why","level":2,"title":"Show the Why","text":"<p>Traceability Builds Trust</p> <p>Systems that cannot explain themselves will not be trusted.</p> <p><code>{}</code> is the what.</p> <p><code>ctx</code> is the why.</p> <p>We record:</p> <ul> <li>Explored paths;</li> <li>Rejected options;</li> <li>Assumptions made;</li> <li>Evidence used.</li> </ul> <p>Opaque systems erode trust: Transparent context compounds understanding.</p>","path":["The ctx Manifesto"],"tags":[]},{"location":"#continuously-verify-the-system","level":2,"title":"Continuously Verify the System","text":"<p>Stability is Temporary</p> <p>Every assumption has a half-life.</p> <ul> <li>Models drift.</li> <li>Tools change.</li> <li>Assumptions rot.</li> </ul> <p><code>ctx</code> must be verified against reality.</p> <p>Trust is a spectrum.</p> <p>Trust is continuously re-earned.</p> <p>Benchmarks, regressions, and evaluations are safety rails.</p>","path":["The ctx Manifesto"],"tags":[]},{"location":"#ctx-is-leverage","level":2,"title":"<code>ctx</code> Is Leverage","text":"<p>Humans are Decision Engines</p> <p>Execution should not consume judgment.</p> <p>Humans are not typists.</p> <p>We are authors.</p> <p>Human effort is reserved for:</p> <ul> <li>Judgment;</li> <li>Design;</li> <li>Taste;</li> <li>Synthesis.</li> </ul> <p>Repetition is delegated.</p> <p>Toil is automated.</p> <p><code>ctx</code> preserves leverage across time.</p>","path":["The ctx Manifesto"],"tags":[]},{"location":"#the-thesis","level":2,"title":"The Thesis","text":"<p>Invariant</p> <p>Everything else is an implementation detail.</p> <ul> <li>Creation is the act.</li> <li><code>ctx</code> is the substrate.</li> <li>Verification is the truth.</li> </ul> <p>Code executes → Models reason → Agents amplify.</p> <p><code>ctx</code> lives on.</p> <p>Without <code>ctx</code>, intelligence resets.</p> <p>With <code>ctx</code>, creation compounds.</p>","path":["The ctx Manifesto"],"tags":[]},{"location":"about/","level":1,"title":"About ctx","text":"","path":["Home","About ctx"],"tags":[]},{"location":"about/#ctx","level":2,"title":"<code>ctx</code>","text":"<p><code>ctx</code> (Context) is a file-based system that enables AI coding assistants to persist project knowledge across sessions. Instead of re-explaining your codebase every time, context files let AI tools remember decisions, conventions, and learnings:</p> <ul> <li>A session is interactive.</li> <li><code>ctx</code> enables cognitive continuity.</li> <li>Cognitive continuity enables durable, symbiotic-like human–AI workflows.</li> </ul> <p>The <code>ctx</code> Manifesto</p> <p>Creation, not code. Context, not prompts. Verification, not vibes.</p> <p>Without durable context, intelligence resets. With <code>ctx</code>, creation compounds.</p> <p>Read the Manifesto →</p>","path":["Home","About ctx"],"tags":[]},{"location":"about/#community","level":2,"title":"Community","text":"<p>Open source is better together.</p> <p>Help <code>ctx</code> Change How AI Remembers</p> <p>If the idea behind <code>ctx</code> resonates, a star helps it reach engineers who run into context drift every day.</p> <p>→ https://github.com/ActiveMemory/ctx</p> <p><code>ctx</code> is free and open source software, and contributions are always welcome and appreciated.</p> <p>Join the community to ask questions, share feedback, and connect with other users:</p> <ul> <li> IRC:    join <code>#ctx</code> on <code>irc.libera.chat</code></li> <li> GitHub:   Star the repo, report issues, contribute</li> </ul>","path":["Home","About ctx"],"tags":[]},{"location":"about/#why-i-keep-re-explaining-my-codebase","level":2,"title":"Why? — I Keep Re-Explaining My Codebase","text":"<p>You open a new AI session. The first thing you do is re-explain your project.</p> <p>Again.</p> <p>The architecture, the database choice, the naming conventions, the thing you tried last week that didn't work. You've said all of this before — maybe yesterday, maybe an hour ago — but the AI doesn't know that.</p> <ul> <li>You explain the same architecture every session</li> <li>The AI suggests an approach you already rejected — again</li> <li>A decision you made three sessions ago gets relitigated from scratch</li> <li>You spend more time setting context than building features</li> </ul> <p>This isn't an AI problem. It's a context problem. Without persistent memory, every session starts at zero.</p>","path":["Home","About ctx"],"tags":[]},{"location":"about/#before-after","level":3,"title":"Before &amp; After","text":"Without ctxWith ctx <pre><code>Session 12 — Monday morning\n\nYou:  \"We use PostgreSQL, not MySQL. I explained this on Thursday.\"\nAI:   \"Got it! Let me adjust the schema for PostgreSQL...\"\n\nYou:  \"Also, we decided to use JWT for auth, not sessions.\"\nAI:   \"Understood! Here's the updated approach...\"\n\nYou:  \"And the API uses snake_case, not camelCase.\"\nAI:   \"I'll fix the naming...\"\n\n20 minutes spent re-explaining before any real work starts.\n</code></pre> <pre><code>Session 12 — Monday morning\n\nYou:  \"Let's continue the auth implementation.\"\nAI:   \"Based on your context: the project uses PostgreSQL with JWT\n       authentication. The API follows snake_case conventions.\n       Last session you completed the login endpoint — the\n       registration endpoint is next on TASKS.md. Want me to\n       start there?\"\n\n0 minutes re-explaining. Straight to building.\n</code></pre> <p>The difference: ctx gives your AI a memory that persists across sessions.</p>","path":["Home","About ctx"],"tags":[]},{"location":"about/#how-ctx-solves-this","level":3,"title":"How ctx Solves This","text":"<p><code>ctx</code> creates a <code>.context/</code> directory in your project that stores structured knowledge files:</p> File What It Remembers <code>TASKS.md</code> What you're working on and what's next <code>DECISIONS.md</code> Architectural choices and why you made them <code>LEARNINGS.md</code> Gotchas, bugs, things that didn't work <code>CONVENTIONS.md</code> Naming patterns, code style, project rules <code>CONSTITUTION.md</code> Hard rules the AI must never violate <p>These files version with your code in git. They load automatically at session start (via hooks in Claude Code, or manually with <code>ctx agent</code> for other tools). The AI reads them, cites them, and builds on them — instead of asking you to start over.</p> <p>Context accumulates. Every decision you record, every lesson you capture, makes the next session smarter than the last.</p> <p>Ready to get started?</p> <ul> <li>Getting Started → — full installation and setup</li> <li>Your First Session → — step-by-step walkthrough from <code>ctx init</code> to verified recall</li> </ul>","path":["Home","About ctx"],"tags":[]},{"location":"agent-security/","level":1,"title":"Securing AI Agents","text":"","path":["Security","Securing AI Agents"],"tags":[]},{"location":"agent-security/#defense-in-depth-securing-ai-agents","level":1,"title":"Defense in Depth: Securing AI Agents","text":"","path":["Security","Securing AI Agents"],"tags":[]},{"location":"agent-security/#the-problem","level":2,"title":"The Problem","text":"<p>An unattended AI agent with unrestricted access to your machine is an unattended shell with unrestricted access to your machine.</p> <p>This is not a theoretical concern. AI coding agents execute shell commands, write files, make network requests, and modify project configuration. When running autonomously (overnight, in a loop, without a human watching) the attack surface is the full capability set of the operating system user account.</p> <p>The risk is not that the AI is malicious. The risk is that the AI is controllable: it follows instructions from context, and context can be poisoned.</p>","path":["Security","Securing AI Agents"],"tags":[]},{"location":"agent-security/#threat-model","level":2,"title":"Threat Model","text":"","path":["Security","Securing AI Agents"],"tags":[]},{"location":"agent-security/#how-agents-get-compromised","level":3,"title":"How Agents Get Compromised","text":"<p>AI agents follow instructions from multiple sources: system prompts, project files, conversation history, and tool outputs. An attacker who can inject content into any of these sources can redirect the agent's behavior.</p> Vector How it works Prompt injection via dependencies A malicious package includes instructions in its README, changelog, or error output. The agent reads these during installation or debugging and follows them. Prompt injection via fetched content The agent fetches a URL (documentation, API response, Stack Overflow answer) containing embedded instructions. Poisoned project files A contributor adds adversarial instructions to <code>CLAUDE.md</code>, <code>.cursorrules</code>, or <code>.context/</code> files. The agent loads these at session start. Self-modification between iterations In an autonomous loop, the agent modifies its own configuration files. The next iteration loads the modified config with no human review. Tool output injection A command's output (error messages, log lines, file contents) contains instructions the agent interprets and follows.","path":["Security","Securing AI Agents"],"tags":[]},{"location":"agent-security/#what-a-compromised-agent-can-do","level":3,"title":"What a Compromised Agent Can Do","text":"<p>Depends entirely on what permissions and access the agent has:</p> Access level Potential impact Unrestricted shell Execute any command, install software, modify system files Network access Exfiltrate source code, credentials, or context files to external servers Docker socket Escape container isolation by spawning privileged sibling containers SSH keys Pivot to other machines, push to remote repositories, access production systems Write access to own config Disable its own guardrails for the next iteration","path":["Security","Securing AI Agents"],"tags":[]},{"location":"agent-security/#the-defense-layers","level":2,"title":"The Defense Layers","text":"<p>No single layer is sufficient. Each layer catches what the others miss.</p> <pre><code>Layer 1: Soft instructions     (CONSTITUTION.md, playbook)\nLayer 2: Application controls  (permission allowlist, tool restrictions)\nLayer 3: OS-level isolation    (user accounts, filesystem, containers)\nLayer 4: Network controls      (firewall rules, airgap)\nLayer 5: Infrastructure        (VM isolation, resource limits)\n</code></pre>","path":["Security","Securing AI Agents"],"tags":[]},{"location":"agent-security/#layer-1-soft-instructions-probabilistic","level":3,"title":"Layer 1: Soft Instructions (Probabilistic)","text":"<p>Markdown files like <code>CONSTITUTION.md</code> and the Agent Playbook tell the agent what to do and what not to do. These are probabilistic: the agent usually follows them, but there is no enforcement mechanism.</p> <p>What it catches: Most common mistakes. An agent that has been told \"never delete production data\" will usually not delete production data.</p> <p>What it misses: Prompt injection. A sufficiently crafted injection can override soft instructions. Long context windows dilute attention on rules stated early. Edge cases where instructions are ambiguous.</p> <p>Verdict: Necessary but not sufficient. Good for the common case. Do not rely on it for security boundaries.</p>","path":["Security","Securing AI Agents"],"tags":[]},{"location":"agent-security/#layer-2-application-controls-deterministic-at-runtime-mutable-across-iterations","level":3,"title":"Layer 2: Application Controls (Deterministic at Runtime, Mutable Across Iterations)","text":"<p>AI tool runtimes (Claude Code, Cursor, etc.) provide permission systems: tool allowlists, command restrictions, confirmation prompts.</p> <p>For Claude Code, an explicit allowlist in <code>.claude/settings.local.json</code>:</p> <pre><code>{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(make:*)\",\n      \"Bash(go:*)\",\n      \"Bash(git:*)\",\n      \"Bash(ctx:*)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\"\n    ]\n  }\n}\n</code></pre> <p>What it catches: The agent cannot run commands outside the allowlist. If <code>rm</code>, <code>curl</code>, <code>sudo</code>, or <code>docker</code> are not listed, the agent cannot invoke them regardless of what any prompt says.</p> <p>What it misses: The agent can modify the allowlist itself. In an autonomous loop, the agent writes to <code>.claude/settings.local.json</code>, and the next iteration loads the modified config. The application enforces the rules, but the application reads the rules from files the agent can write.</p> <p>Verdict: Strong first layer. Must be combined with self-modification prevention (Layer 3).</p>","path":["Security","Securing AI Agents"],"tags":[]},{"location":"agent-security/#layer-3-os-level-isolation-deterministic-and-unbypassable","level":3,"title":"Layer 3: OS-Level Isolation (Deterministic and Unbypassable)","text":"<p>The operating system enforces access controls that no application-level trick can override. An unprivileged user cannot read files owned by root. A process without <code>CAP_NET_RAW</code> cannot open raw sockets. These are kernel boundaries.</p> Control Purpose Dedicated user account No <code>sudo</code>, no privileged group membership (<code>docker</code>, <code>wheel</code>, <code>adm</code>). The agent cannot escalate privileges. Filesystem permissions Project directory writable; everything else read-only or inaccessible. Agent cannot reach other projects, home directories, or system config. Immutable config files <code>CLAUDE.md</code>, <code>.claude/settings.local.json</code>, and <code>.context/CONSTITUTION.md</code> owned by a different user or marked immutable (<code>chattr +i</code> on Linux). The agent cannot modify its own guardrails. <p>What it catches: Privilege escalation, self-modification, lateral movement to other projects or users.</p> <p>What it misses: Actions within the agent's legitimate scope. If the agent has write access to source code (which it needs to do its job), it can introduce vulnerabilities in the code itself.</p> <p>Verdict: Essential. This is the layer that makes the other layers trustworthy.</p> <p>OS-level isolation does not make the agent safe; it makes the other layers meaningful.</p>","path":["Security","Securing AI Agents"],"tags":[]},{"location":"agent-security/#layer-4-network-controls","level":3,"title":"Layer 4: Network Controls","text":"<p>An agent that cannot reach the internet cannot exfiltrate data. It also cannot ingest new instructions mid-loop from external documents, API responses, or hostile content.</p> Scenario Recommended control Agent does not need the internet <code>--network=none</code> (container) or outbound firewall drop-all Agent needs to fetch dependencies Allow specific registries (npmjs.com, proxy.golang.org, pypi.org) via firewall rules. Block everything else. Agent needs API access Allow specific API endpoints only. Use an HTTP proxy with allowlisting. <p>What it catches: Data exfiltration, phone-home payloads, downloading additional tools, and instruction injection via fetched content.</p> <p>What it misses: Nothing, if the agent genuinely does not need the network. The tradeoff is that many real workloads need dependency resolution, so a full airgap requires pre-populated caches.</p>","path":["Security","Securing AI Agents"],"tags":[]},{"location":"agent-security/#layer-5-infrastructure-isolation","level":3,"title":"Layer 5: Infrastructure Isolation","text":"<p>The strongest boundary is a separate machine — or something that behaves like one.</p> <p>The moment you stop arguing about prompts and start arguing about kernels, you are finally doing security.</p> <p>Containers (Docker, Podman):</p> <pre><code>docker run --rm \\\n  --network=none \\\n  --cap-drop=ALL \\\n  --memory=4g \\\n  --cpus=2 \\\n  -v /path/to/project:/workspace \\\n  -w /workspace \\\n  your-dev-image \\\n  ./loop.sh\n</code></pre> <p>Docker Socket is sudo Access</p> <p>Critical: never mount the Docker socket (<code>/var/run/docker.sock</code>).</p> <p>An agent with socket access can spawn sibling containers with full host access, effectively escaping the sandbox. </p> <p>Use rootless Docker or Podman to eliminate this escalation path.</p> <p>Virtual machines: The strongest isolation. The guest kernel has no visibility into the host OS. No shared folders, no filesystem passthrough, no SSH keys to other machines.</p> <p>Resource limits: CPU, memory, and disk quotas prevent a runaway agent from consuming all resources. Use <code>ulimit</code>, cgroup limits, or container resource constraints.</p>","path":["Security","Securing AI Agents"],"tags":[]},{"location":"agent-security/#putting-it-all-together","level":2,"title":"Putting It All Together","text":"<p>A defense-in-depth setup for overnight autonomous runs:</p> Layer Implementation Stops Soft instructions <code>CONSTITUTION.md</code> with \"never delete tests\", \"always run tests before committing\" Common mistakes (probabilistic) Application allowlist <code>.claude/settings.local.json</code> with explicit tool permissions Unauthorized commands (deterministic within runtime) Immutable config <code>chattr +i</code> on <code>CLAUDE.md</code>, <code>.claude/</code>, <code>CONSTITUTION.md</code> Self-modification between iterations Unprivileged user Dedicated user, no sudo, no docker group Privilege escalation Container <code>--cap-drop=ALL --network=none</code>, rootless, no socket mount Host escape, network exfiltration Resource limits <code>--memory=4g --cpus=2</code>, disk quotas Resource exhaustion <p>Each layer is simple. The strength is in the combination.</p>","path":["Security","Securing AI Agents"],"tags":[]},{"location":"agent-security/#common-mistakes","level":2,"title":"Common Mistakes","text":"<p>\"I'll just use <code>--dangerously-skip-permissions</code>\": This disables Layer 2 entirely. Without Layers 3-5, you have no protection at all. Only use this flag inside a properly isolated container or VM.</p> <p>\"The agent is sandboxed in Docker\": A Docker container with the Docker socket mounted, running as root, with <code>--privileged</code>, and full network access is not sandboxed. It is a root shell with extra steps.</p> <p>\"CONSTITUTION.md says not to do that\": Markdown is a suggestion. It works most of the time. It is not a security boundary. Do not use it as one.</p> <p>\"I reviewed the CLAUDE.md, it's fine\": The agent can modify <code>CLAUDE.md</code> during iteration N. Iteration N+1 loads the modified version. Unless the file is immutable, your review is stale.</p> <p>\"The agent only has access to this one project\": Does the project directory contain <code>.env</code> files, SSH keys, API tokens, or credentials? Does it have a <code>.git/config</code> with push access to a remote? Filesystem isolation means isolating what is in the directory too.</p>","path":["Security","Securing AI Agents"],"tags":[]},{"location":"agent-security/#checklist","level":2,"title":"Checklist","text":"<p>Before running an unattended AI agent:</p> <ul> <li> Agent runs as a dedicated unprivileged user (no sudo, no docker group)</li> <li> Agent's config files are immutable or owned by a different user</li> <li> Permission allowlist restricts tools to the project's toolchain</li> <li> Container drops all capabilities (<code>--cap-drop=ALL</code>)</li> <li> Docker socket is NOT mounted</li> <li> Network is disabled or restricted to specific domains</li> <li> Resource limits are set (memory, CPU, disk)</li> <li> No SSH keys, API tokens, or credentials are accessible to the agent</li> <li> Project directory does not contain <code>.env</code> or secrets files</li> <li> Iteration cap is set (<code>--max-iterations</code>)</li> </ul>","path":["Security","Securing AI Agents"],"tags":[]},{"location":"agent-security/#further-reading","level":2,"title":"Further Reading","text":"<ul> <li>Running an Unattended AI Agent: the   ctx recipe for autonomous loops, including step-by-step permissions   and isolation setup</li> <li>Security: <code>ctx</code>'s own trust model and vulnerability   reporting</li> <li>Autonomous Loops: full documentation of the   loop pattern, <code>PROMPT.md</code> templates, and troubleshooting</li> </ul>","path":["Security","Securing AI Agents"],"tags":[]},{"location":"autonomous-loop/","level":1,"title":"Autonomous Loops","text":"","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#autonomous-ai-development","level":2,"title":"Autonomous AI Development","text":"<p>Iterate until done.</p> <p>An autonomous loop is an iterative AI development workflow where an agent works on tasks until completion—without constant human intervention. Context (<code>ctx</code>) provides the memory that makes this possible:</p> <ul> <li><code>ctx</code> provides the memory: persistent context that survives across iterations</li> <li>The loop provides the automation: continuous execution until done</li> </ul> <p>Together, they enable fully autonomous AI development where the agent remembers everything across iterations.</p> <p>Origin</p> <p>This pattern is inspired by Geoffrey Huntley's Ralph Wiggum technique. We use generic terminology here so the concepts remain clear regardless of trends.</p>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#how-it-works","level":2,"title":"How It Works","text":"<pre><code>graph TD\n    A[Start Loop] --&gt; B[Load PROMPT.md]\n    B --&gt; C[AI reads .context/]\n    C --&gt; D[AI picks task from TASKS.md]\n    D --&gt; E[AI completes task]\n    E --&gt; F[AI updates context files]\n    F --&gt; G[AI commits changes]\n    G --&gt; H{Check signals}\n    H --&gt;|SYSTEM_CONVERGED| I[Done - all tasks complete]\n    H --&gt;|SYSTEM_BLOCKED| J[Done - needs human input]\n    H --&gt;|Continue| B</code></pre> <ol> <li>Loop reads <code>PROMPT.md</code> and invokes AI</li> <li>AI loads context from <code>.context/</code></li> <li>AI picks one task and completes it</li> <li>AI updates context files (mark task done, add learnings)</li> <li>AI commits changes</li> <li>Loop checks for completion signals</li> <li>Repeat until converged or blocked</li> </ol>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#quick-start-shell-while-loop-recommended","level":2,"title":"Quick Start: Shell While Loop (Recommended)","text":"<p>The best way to run an autonomous loop is a plain shell script that invokes your AI tool in a fresh process on each iteration. This is \"pure ralph\": the only state that carries between iterations is what lives in <code>.context/</code> and the git history. No context window bleed, no accumulated tokens, no hidden state.</p> <p>Create a <code>loop.sh</code>:</p> <pre><code>#!/bin/bash\n# loop.sh — an autonomous iteration loop\n\nPROMPT_FILE=\"${1:-PROMPT.md}\"\nMAX_ITERATIONS=\"${2:-10}\"\nOUTPUT_FILE=\"/tmp/loop_output.txt\"\n\nfor i in $(seq 1 $MAX_ITERATIONS); do\n  echo \"=== Iteration $i ===\"\n\n  # Invoke AI with prompt\n  cat \"$PROMPT_FILE\" | claude --print &gt; \"$OUTPUT_FILE\" 2&gt;&amp;1\n\n  # Display output\n  cat \"$OUTPUT_FILE\"\n\n  # Check for completion signals\n  if grep -q \"SYSTEM_CONVERGED\" \"$OUTPUT_FILE\"; then\n    echo \"Loop complete: All tasks done\"\n    break\n  fi\n\n  if grep -q \"SYSTEM_BLOCKED\" \"$OUTPUT_FILE\"; then\n    echo \"Loop blocked: Needs human input\"\n    break\n  fi\n\n  sleep 2\ndone\n</code></pre> <p>Make it executable and run:</p> <pre><code>chmod +x loop.sh\n./loop.sh\n</code></pre> <p>You can also generate this script with <code>ctx loop</code> (see CLI Reference).</p>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#why-a-shell-loop","level":3,"title":"Why a Shell Loop?","text":"<p>Each iteration starts a fresh AI process with zero context window history. The agent knows only what it reads from <code>.context/</code> files — exactly the information you chose to persist. This is the core Ralph principle: memory is explicit, not accidental.</p>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#alternative-claude-codes-built-in-loop","level":2,"title":"Alternative: Claude Code's Built-in Loop","text":"<p>Claude Code has built-in loop support:</p> <pre><code># Start autonomous loop\n/loop\n\n# Cancel running loop\n/cancel-loop\n</code></pre> <p>This is convenient for quick iterations, but be aware of important caveats:</p> <p>Not Pure Ralph</p> <p>Claude Code's <code>/loop</code> runs all iterations within the same session. This means:</p> <ul> <li>State leaks between iterations. The context window accumulates   output from every previous iteration. The agent \"remembers\" things   it saw earlier — even if they were never persisted to <code>.context/</code>.</li> <li>Token budget degrades. Each iteration adds to the context window,   leaving less room for actual work in later iterations.</li> <li>Not ergonomic for long runs. Users report that the built-in loop   is less predictable for 10+ iteration runs compared to a shell loop.</li> </ul> <p>For short explorations (2-5 iterations) or interactive use, <code>/loop</code> works fine. For overnight unattended runs or anything where iteration independence matters, use the shell while loop instead.</p>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#the-promptmd-file","level":2,"title":"The PROMPT.md File","text":"<p>The prompt file instructs the AI on how to work autonomously. Here's a template:</p> <pre><code># Autonomous Development Prompt\n\nYou are working on this project autonomously. Follow these steps:\n\n## 1. Load Context\n\nRead these files in order:\n1. `.context/CONSTITUTION.md` — NEVER violate these rules\n2. `.context/TASKS.md` — Find work to do\n3. `.context/CONVENTIONS.md` — Follow these patterns\n4. `.context/DECISIONS.md` — Understand past choices\n\n## 2. Pick One Task\n\nFrom `.context/TASKS.md`, select ONE task that is:\n- Not blocked\n- Highest priority available\n- Within your capabilities\n\n## 3. Complete the Task\n\n- Write code following conventions\n- Run tests if applicable\n- Keep changes focused and minimal\n\n## 4. Update Context\n\nAfter completing work:\n- Mark task complete in TASKS.md\n- Add any learnings to LEARNINGS.md\n- Add any decisions to DECISIONS.md\n\n## 5. Commit Changes\n\nCreate a focused commit with clear message.\n\n## 6. Signal Status\n\nEnd your response with exactly ONE of:\n\n- `SYSTEM_CONVERGED` — All tasks in TASKS.md are complete\n- `SYSTEM_BLOCKED` — Cannot proceed, need human input (explain why)\n- (no signal) — More work remains, continue to next iteration\n\n## Rules\n\n- ONE task per iteration\n- NEVER skip tests\n- NEVER violate CONSTITUTION.md\n- Commit after each task\n</code></pre>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#completion-signals","level":2,"title":"Completion Signals","text":"<p>The loop watches for these signals in AI output:</p> Signal Meaning When to Use <code>SYSTEM_CONVERGED</code> All tasks complete No pending tasks in TASKS.md <code>SYSTEM_BLOCKED</code> Cannot proceed Needs clarification, access, or decision <code>BOOTSTRAP_COMPLETE</code> Initial setup done Project scaffolding finished","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#example-usage","level":3,"title":"Example Usage","text":"<pre><code>I've completed all tasks in TASKS.md:\n- [x] Set up project structure\n- [x] Implement core API\n- [x] Add authentication\n- [x] Write tests\n\nNo pending tasks remain.\n\nSYSTEM_CONVERGED\n</code></pre> <pre><code>I cannot proceed with the \"Deploy to production\" task because:\n- Missing AWS credentials\n- Need confirmation on region selection\n\nPlease provide credentials and confirm deployment region.\n\nSYSTEM_BLOCKED\n</code></pre>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#why-context-loops-work-well-together","level":2,"title":"Why Context + Loops Work Well Together","text":"Without ctx With ctx Each iteration starts fresh Each iteration has full history Decisions get re-made Decisions persist in DECISIONS.md Learnings are lost Learnings accumulate in LEARNINGS.md Tasks can be forgotten Tasks tracked in TASKS.md","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#automatic-context-updates","level":3,"title":"Automatic Context Updates","text":"<p>During the loop, the AI should update context files:</p> <p>Mark task complete: <pre><code>ctx complete \"implement user auth\"\n</code></pre></p> <p>Or emit an update command (parsed by <code>ctx watch</code>): <pre><code>&lt;context-update type=\"complete\"&gt;user auth&lt;/context-update&gt;\n</code></pre></p> <p>Add learning: <pre><code>ctx add learning \"Rate limiting requires Redis connection\"\n</code></pre></p> <p>Or via update command: <pre><code>&lt;context-update type=\"learning\"\n  context=\"Implementing rate limiter\"\n  lesson=\"Rate limiting requires Redis connection\"\n  application=\"Ensure Redis is provisioned before enabling rate limits\"\n&gt;Rate Limiting Redis Dependency&lt;/context-update&gt;\n</code></pre></p> <p>Record decision: <pre><code>ctx add decision \"Use JWT tokens for API authentication\"\n</code></pre></p>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#advanced-watch-mode","level":2,"title":"Advanced: Watch Mode","text":"<p>Run <code>ctx watch</code> alongside the loop to automatically process context updates:</p> <pre><code># Terminal 1: Run the loop\n./loop.sh 2&gt;&amp;1 | tee /tmp/loop.log\n\n# Terminal 2: Watch for context updates\nctx watch --log /tmp/loop.log\n</code></pre> <p>The watch command processes context updates from the loop output in real time.</p>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#project-setup","level":2,"title":"Project Setup","text":"<p>Initialize a project for autonomous loop operation:</p> <pre><code># Initialize with autonomous agent behavior\nctx init --ralph\n</code></pre> <p>The <code>--ralph</code> flag creates a <code>PROMPT.md</code> where the agent:</p> <ul> <li>Works autonomously without asking clarifying questions</li> <li>Follows one-task-per-iteration discipline</li> <li>Uses <code>SYSTEM_CONVERGED</code> / <code>SYSTEM_BLOCKED</code> signals</li> </ul> <p>Without <code>--ralph</code>, the agent is encouraged to ask questions when requirements are unclear — better for collaborative human-agent sessions.</p>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#example-project-structure","level":2,"title":"Example Project Structure","text":"<pre><code>my-project/\n├── .context/\n│   ├── CONSTITUTION.md\n│   ├── TASKS.md          # Work items for the loop\n│   ├── DECISIONS.md\n│   ├── LEARNINGS.md\n│   ├── CONVENTIONS.md\n│   └── sessions/         # Loop iteration history\n├── PROMPT.md             # Instructions for the AI\n├── IMPLEMENTATION_PLAN.md # High-level project direction\n├── loop.sh               # Loop script (if not using Claude Code)\n└── src/                  # Your code\n</code></pre>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#sample-tasksmd-for-autonomous-loops","level":3,"title":"Sample TASKS.md for Autonomous Loops","text":"<pre><code># Tasks\n\n## Phase 1: Setup\n\n- [x] Initialize project structure\n- [x] Set up testing framework\n\n## Phase 2: Core Features\n\n- [ ] Implement user registration `#priority:high`\n- [ ] Add email verification `#priority:high`\n- [ ] Create password reset flow `#priority:medium`\n\n## Phase 3: Polish\n\n- [ ] Add rate limiting `#priority:medium`\n- [ ] Improve error messages `#priority:low`\n</code></pre> <p>The loop will work through these systematically, marking each complete.</p>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#troubleshooting","level":2,"title":"Troubleshooting","text":"","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#loop-runs-forever","level":3,"title":"Loop Runs Forever","text":"<p>Cause: AI not emitting completion signals</p> <p>Fix: Ensure PROMPT.md explicitly instructs signaling: <pre><code>End EVERY response with one of:\n- SYSTEM_CONVERGED (if all tasks done)\n- SYSTEM_BLOCKED (if stuck)\n</code></pre></p>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#context-not-persisting","level":3,"title":"Context Not Persisting","text":"<p>Cause: AI not updating context files</p> <p>Fix: Add explicit instructions to PROMPT.md: <pre><code>After completing a task, you MUST:\n1. Run: ctx complete \"&lt;task&gt;\"\n2. Add learnings: ctx add learning \"...\"\n</code></pre></p>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#tasks-getting-repeated","level":3,"title":"Tasks Getting Repeated","text":"<p>Cause: Task not marked complete before next iteration</p> <p>Fix: Ensure commit happens after context update: <pre><code>Order of operations:\n1. Complete coding work\n2. Update context files (ctx complete, ctx add)\n3. Commit ALL changes including .context/\n4. Then signal status\n</code></pre></p>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#ai-violating-constitution","level":3,"title":"AI Violating Constitution","text":"<p>Cause: Constitution not read first</p> <p>Fix: Make constitution check explicit in PROMPT.md: <pre><code>BEFORE any work:\n1. Read .context/CONSTITUTION.md\n2. If task would violate ANY rule, emit SYSTEM_BLOCKED\n3. Explain which rule prevents the work\n</code></pre></p>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#further-reading","level":2,"title":"Further Reading","text":"<ul> <li>Building ctx Using ctx — The dogfooding story: how autonomous loops built the tool that powers them</li> </ul>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"autonomous-loop/#resources","level":2,"title":"Resources","text":"<ul> <li>Geoffrey Huntley's Ralph Wiggum Technique — Original inspiration</li> <li>Context CLI — Command reference</li> <li>Integrations — Tool-specific setup</li> </ul>","path":["Operations","Autonomous Loops"],"tags":[]},{"location":"cli-reference/","level":1,"title":"ctx CLI","text":"","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-cli","level":2,"title":"<code>ctx</code> CLI","text":"<p>This is a complete reference for all <code>ctx</code> commands.</p>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#global-options","level":2,"title":"Global Options","text":"<p>All commands support these flags:</p> Flag Description <code>--help</code> Show command help <code>--version</code> Show version <code>--context-dir &lt;path&gt;</code> Override context directory (default: <code>.context/</code>) <code>--no-color</code> Disable colored output <code>--allow-outside-cwd</code> Allow context directory outside current working directory <p>The <code>NO_COLOR=1</code> environment variable also disables colored output.</p>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#commands","level":2,"title":"Commands","text":"Command Description <code>ctx init</code> Initialize <code>.context/</code> directory with templates <code>ctx status</code> Show context summary (files, tokens, drift) <code>ctx agent</code> Print token-budgeted context packet for AI consumption <code>ctx load</code> Output assembled context in read order <code>ctx add</code> Add a task, decision, learning, or convention <code>ctx complete</code> Mark a task as done <code>ctx drift</code> Detect stale paths, secrets, missing files <code>ctx sync</code> Reconcile context with codebase state <code>ctx compact</code> Archive completed tasks, clean up files <code>ctx tasks</code> Task archival and snapshots <code>ctx permissions</code> Permission snapshots (golden image) <code>ctx decisions</code> Reindex <code>DECISIONS.md</code> <code>ctx learnings</code> Reindex <code>LEARNINGS.md</code> <code>ctx recall</code> Browse and export AI session history <code>ctx journal</code> Generate static site from journal entries <code>ctx serve</code> Serve static site locally <code>ctx watch</code> Auto-apply context updates from AI output <code>ctx hook</code> Generate AI tool integration configs <code>ctx loop</code> Generate autonomous loop script <code>ctx pad</code> Encrypted scratchpad for sensitive one-liners","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-init","level":3,"title":"<code>ctx init</code>","text":"<p>Initialize a new <code>.context/</code> directory with template files.</p> <pre><code>ctx init [flags]\n</code></pre> <p>Flags:</p> Flag Short Description <code>--force</code> <code>-f</code> Overwrite existing context files <code>--minimal</code> <code>-m</code> Only create essential files (TASKS.md, DECISIONS.md, CONSTITUTION.md) <code>--merge</code> Auto-merge ctx content into existing CLAUDE.md and PROMPT.md <code>--ralph</code> Agent works autonomously without asking questions <p>Creates:</p> <ul> <li><code>.context/</code> directory with all template files</li> <li><code>.claude/settings.local.json</code> with pre-approved ctx permissions</li> <li><code>PROMPT.md</code> with session prompt (autonomous mode with <code>--ralph</code>)</li> <li><code>IMPLEMENTATION_PLAN.md</code> with high-level project direction</li> <li><code>CLAUDE.md</code> with bootstrap instructions (or merges into existing)</li> </ul> <p>Claude Code hooks and skills are provided by the ctx plugin (see Integrations).</p> <p>Example:</p> <pre><code># Collaborative mode (agent asks questions when unclear)\nctx init\n\n# Autonomous mode (agent works independently)\nctx init --ralph\n\n# Minimal setup (just core files)\nctx init --minimal\n\n# Force overwrite existing\nctx init --force\n\n# Merge into existing files\nctx init --merge\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-status","level":3,"title":"<code>ctx status</code>","text":"<p>Show the current context summary.</p> <pre><code>ctx status [flags]\n</code></pre> <p>Flags:</p> Flag Short Description <code>--json</code> Output as JSON <code>--verbose</code> <code>-v</code> Include file contents summary <p>Output:</p> <ul> <li>Context directory path</li> <li>Total files and token estimate</li> <li>Status of each file (loaded, empty, missing)</li> <li>Recent activity (modification times)</li> <li>Drift warnings if any</li> </ul> <p>Example:</p> <pre><code>ctx status\nctx status --json\nctx status --verbose\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-agent","level":3,"title":"<code>ctx agent</code>","text":"<p>Print an AI-ready context packet optimized for LLM consumption.</p> <pre><code>ctx agent [flags]\n</code></pre> <p>Flags:</p> Flag Default Description <code>--budget</code> 8000 Token budget for context packet <code>--format</code> md Output format: <code>md</code> or <code>json</code> <code>--cooldown</code> 10m Suppress repeated output within this duration <code>--session</code> (none) Session ID for cooldown isolation (e.g., <code>$PPID</code>) <p>Output:</p> <ul> <li>Read order for context files</li> <li>Constitution rules (never truncated)</li> <li>Current tasks</li> <li>Key conventions</li> <li>Recent decisions</li> </ul> <p>Example:</p> <pre><code># Default (8000 tokens, markdown)\nctx agent\n\n# Custom budget\nctx agent --budget 4000\n\n# JSON format\nctx agent --format json\n\n# With cooldown (outputs once, then silent for 10m)\nctx agent --budget 4000 --session $PPID\n</code></pre> <p>Use case: Copy-paste into AI chat, pipe to system prompt, or use in hooks.</p>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-load","level":3,"title":"<code>ctx load</code>","text":"<p>Load and display assembled context as AI would see it.</p> <pre><code>ctx load [flags]\n</code></pre> <p>Flags:</p> Flag Description <code>--budget &lt;tokens&gt;</code> Token budget for assembly (default: 8000) <code>--raw</code> Output raw file contents without assembly <p>Example:</p> <pre><code>ctx load\nctx load --budget 16000\nctx load --raw\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-add","level":3,"title":"<code>ctx add</code>","text":"<p>Add a new item to a context file.</p> <pre><code>ctx add &lt;type&gt; &lt;content&gt; [flags]\n</code></pre> <p>Types:</p> Type Target File <code>task</code> TASKS.md <code>decision</code> DECISIONS.md <code>learning</code> LEARNINGS.md <code>convention</code> CONVENTIONS.md <p>Flags:</p> Flag Short Description <code>--priority &lt;level&gt;</code> <code>-p</code> Priority for tasks: <code>high</code>, <code>medium</code>, <code>low</code> <code>--section &lt;name&gt;</code> <code>-s</code> Target section within file <code>--context</code> <code>-c</code> Context (required for decisions and learnings) <code>--rationale</code> <code>-r</code> Rationale for decisions (required for decisions) <code>--consequences</code> Consequences for decisions (required for decisions) <code>--lesson</code> <code>-l</code> Key insight (required for learnings) <code>--application</code> <code>-a</code> How to apply going forward (required for learnings) <code>--file</code> <code>-f</code> Read content from file instead of argument <p>Examples:</p> <pre><code># Add a task\nctx add task \"Implement user authentication\"\nctx add task \"Fix login bug\" --priority high\n\n# Record a decision (requires all ADR—Architectural Decision Record—fields)\nctx add decision \"Use PostgreSQL for primary database\" \\\n  --context \"Need a reliable database for production\" \\\n  --rationale \"PostgreSQL offers ACID compliance and JSON support\" \\\n  --consequences \"Team needs PostgreSQL training\"\n\n# Note a learning (requires context, lesson, and application)\nctx add learning \"Vitest mocks must be hoisted\" \\\n  --context \"Tests failed with undefined mock errors\" \\\n  --lesson \"Vitest hoists vi.mock() calls to top of file\" \\\n  --application \"Always place vi.mock() before imports in test files\"\n\n# Add to specific section\nctx add convention \"Use kebab-case for filenames\" --section \"Naming\"\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-complete","level":3,"title":"<code>ctx complete</code>","text":"<p>Mark a task as completed.</p> <pre><code>ctx complete &lt;task-id-or-text&gt;\n</code></pre> <p>Arguments:</p> <ul> <li><code>task-id-or-text</code>: Task number or partial text match</li> </ul> <p>Examples:</p> <pre><code># By text (partial match)\nctx complete \"user auth\"\n\n# By task number\nctx complete 3\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-drift","level":3,"title":"<code>ctx drift</code>","text":"<p>Detect stale or invalid context.</p> <pre><code>ctx drift [flags]\n</code></pre> <p>Flags:</p> Flag Description <code>--json</code> Output machine-readable JSON <code>--fix</code> Auto-fix simple issues <p>Checks:</p> <ul> <li>Path references in ARCHITECTURE.md and CONVENTIONS.md exist</li> <li>Task references are valid</li> <li>Constitution rules aren't violated (heuristic)</li> <li>Staleness indicators (old files, many completed tasks)</li> </ul> <p>Example:</p> <pre><code>ctx drift\nctx drift --json\nctx drift --fix\n</code></pre> <p>Exit codes:</p> Code Meaning 0 All checks passed 1 Warnings found 3 Violations found","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-sync","level":3,"title":"<code>ctx sync</code>","text":"<p>Reconcile context with the current codebase state.</p> <pre><code>ctx sync [flags]\n</code></pre> <p>Flags:</p> Flag Description <code>--dry-run</code> Show what would change without modifying <p>What it does:</p> <ul> <li>Scans codebase for structural changes</li> <li>Compares with ARCHITECTURE.md</li> <li>Suggests documenting dependencies if package files exist</li> <li>Identifies stale or outdated context</li> </ul> <p>Example:</p> <pre><code>ctx sync\nctx sync --dry-run\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-compact","level":3,"title":"<code>ctx compact</code>","text":"<p>Consolidate and clean up context files.</p> <ul> <li>Moves completed tasks older than 7 days to the archive</li> <li>Deduplicates the \"learning\"s with similar content</li> <li>Removes empty sections</li> </ul> <pre><code>ctx compact [flags]\n</code></pre> <p>Flags:</p> Flag Description <code>--archive</code> Create <code>.context/archive/</code> for old content <p>Example:</p> <pre><code>ctx compact\nctx compact --archive\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-completion","level":3,"title":"<code>ctx completion</code>","text":"<p>Generate shell autocompletion scripts.</p> <pre><code>ctx completion &lt;shell&gt;\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#subcommands","level":4,"title":"Subcommands","text":"Shell Command <code>bash</code> <code>ctx completion bash</code> <code>zsh</code> <code>ctx completion zsh</code> <code>fish</code> <code>ctx completion fish</code> <code>powershell</code> <code>ctx completion powershell</code>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#installation","level":4,"title":"Installation","text":"BashZshFish <pre><code># Add to ~/.bashrc\nsource &lt;(ctx completion bash)\n</code></pre> <pre><code># Add to ~/.zshrc\nsource &lt;(ctx completion zsh)\n</code></pre> <pre><code>ctx completion fish | source\n# Or save to completions directory\nctx completion fish &gt; ~/.config/fish/completions/ctx.fish\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-tasks","level":3,"title":"<code>ctx tasks</code>","text":"<p>Manage task archival and snapshots.</p> <pre><code>ctx tasks &lt;subcommand&gt;\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-tasks-archive","level":4,"title":"<code>ctx tasks archive</code>","text":"<p>Move completed tasks from TASKS.md to a timestamped archive file.</p> <pre><code>ctx tasks archive [flags]\n</code></pre> <p>Flags:</p> Flag Description <code>--dry-run</code> Preview changes without modifying files <p>Archive files are stored in <code>.context/archive/</code> with timestamped names (<code>tasks-YYYY-MM-DD.md</code>). Completed tasks (marked with <code>[x]</code>) are moved; pending tasks (<code>[ ]</code>) remain in TASKS.md.</p> <p>Example:</p> <pre><code>ctx tasks archive\nctx tasks archive --dry-run\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-tasks-snapshot","level":4,"title":"<code>ctx tasks snapshot</code>","text":"<p>Create a point-in-time snapshot of TASKS.md without modifying the original.</p> <pre><code>ctx tasks snapshot [name]\n</code></pre> <p>Arguments:</p> <ul> <li><code>name</code>: Optional name for the snapshot (defaults to \"snapshot\")</li> </ul> <p>Snapshots are stored in <code>.context/archive/</code> with timestamped names (<code>tasks-&lt;name&gt;-YYYY-MM-DD-HHMM.md</code>).</p> <p>Example:</p> <pre><code>ctx tasks snapshot\nctx tasks snapshot \"before-refactor\"\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-permissions","level":3,"title":"<code>ctx permissions</code>","text":"<p>Manage Claude Code permission snapshots.</p> <pre><code>ctx permissions &lt;subcommand&gt;\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-permissions-snapshot","level":4,"title":"<code>ctx permissions snapshot</code>","text":"<p>Save <code>.claude/settings.local.json</code> as the golden image.</p> <pre><code>ctx permissions snapshot\n</code></pre> <p>Creates <code>.claude/settings.golden.json</code> as a byte-for-byte copy of the current settings. Overwrites if the golden file already exists.</p> <p>The golden file is meant to be committed to version control and shared with the team.</p> <p>Example:</p> <pre><code>ctx permissions snapshot\n# Saved golden image: .claude/settings.golden.json\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-permissions-restore","level":4,"title":"<code>ctx permissions restore</code>","text":"<p>Replace <code>settings.local.json</code> with the golden image.</p> <pre><code>ctx permissions restore\n</code></pre> <p>Prints a diff of dropped (session-accumulated) and restored permissions. No-op if the files already match.</p> <p>Example:</p> <pre><code>ctx permissions restore\n# Dropped 3 session permission(s):\n#   - Bash(cat /tmp/debug.log:*)\n#   - Bash(rm /tmp/test-*:*)\n#   - Bash(curl https://example.com:*)\n# Restored from golden image.\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-decisions","level":3,"title":"<code>ctx decisions</code>","text":"<p>Manage the DECISIONS.md file.</p> <pre><code>ctx decisions &lt;subcommand&gt;\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-decisions-reindex","level":4,"title":"<code>ctx decisions reindex</code>","text":"<p>Regenerate the quick-reference index at the top of DECISIONS.md.</p> <pre><code>ctx decisions reindex\n</code></pre> <p>The index is a compact table showing the date and title for each decision, allowing AI tools to quickly scan entries without reading the full file.</p> <p>Use this after manual edits to DECISIONS.md or when migrating existing files to use the index format.</p> <p>Example:</p> <pre><code>ctx decisions reindex\n# ✓ Index regenerated with 12 entries\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-learnings","level":3,"title":"<code>ctx learnings</code>","text":"<p>Manage the LEARNINGS.md file.</p> <pre><code>ctx learnings &lt;subcommand&gt;\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-learnings-reindex","level":4,"title":"<code>ctx learnings reindex</code>","text":"<p>Regenerate the quick-reference index at the top of LEARNINGS.md.</p> <pre><code>ctx learnings reindex\n</code></pre> <p>The index is a compact table showing the date and title for each learning, allowing AI tools to quickly scan entries without reading the full file.</p> <p>Use this after manual edits to LEARNINGS.md or when migrating existing files to use the index format.</p> <p>Example:</p> <pre><code>ctx learnings reindex\n# ✓ Index regenerated with 8 entries\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-recall","level":3,"title":"<code>ctx recall</code>","text":"<p>Browse and search AI session history from Claude Code and other tools.</p> <pre><code>ctx recall &lt;subcommand&gt;\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-recall-list","level":4,"title":"<code>ctx recall list</code>","text":"<p>List all parsed sessions.</p> <pre><code>ctx recall list [flags]\n</code></pre> <p>Flags:</p> Flag Short Description <code>--limit</code> <code>-n</code> Maximum sessions to display (default: 20) <code>--project</code> <code>-p</code> Filter by project name <code>--tool</code> <code>-t</code> Filter by tool (e.g., <code>claude-code</code>) <code>--all-projects</code> Include sessions from all projects <p>Sessions are sorted by date (newest first) and display slug, project, start time, duration, turn count, and token usage.</p> <p>Example:</p> <pre><code>ctx recall list\nctx recall list --limit 5\nctx recall list --project ctx\nctx recall list --tool claude-code\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-recall-show","level":4,"title":"<code>ctx recall show</code>","text":"<p>Show details of a specific session.</p> <pre><code>ctx recall show [session-id] [flags]\n</code></pre> <p>Flags:</p> Flag Description <code>--latest</code> Show the most recent session <code>--full</code> Show full message content <code>--all-projects</code> Search across all projects <p>The session ID can be a full UUID, partial match, or session slug name.</p> <p>Example:</p> <pre><code>ctx recall show abc123\nctx recall show gleaming-wobbling-sutherland\nctx recall show --latest\nctx recall show --latest --full\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-recall-export","level":4,"title":"<code>ctx recall export</code>","text":"<p>Export sessions to editable journal files in <code>.context/journal/</code>.</p> <pre><code>ctx recall export [session-id] [flags]\n</code></pre> <p>Flags:</p> Flag Description <code>--all</code> Export all sessions <code>--all-projects</code> Export from all projects <code>--force</code> Overwrite existing files completely (discard frontmatter) <code>--skip-existing</code> Skip files that already exist <p>Exported files include session metadata, tool usage summary, and the full conversation. When re-exporting, YAML frontmatter from enrichment (topics, type, outcome, etc.) is preserved by default; only the conversation content is regenerated.</p> <p>The <code>journal/</code> directory should be gitignored (like <code>sessions/</code>) since it contains raw conversation data.</p> <p>Example:</p> <pre><code>ctx recall export abc123                # Export one session\nctx recall export --all                 # Export/update all sessions\nctx recall export --all --skip-existing # Skip files that already exist\nctx recall export --all --force         # Overwrite completely (lose frontmatter)\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-journal","level":3,"title":"<code>ctx journal</code>","text":"<p>Analyze and synthesize exported session files.</p> <pre><code>ctx journal &lt;subcommand&gt;\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-journal-site","level":4,"title":"<code>ctx journal site</code>","text":"<p>Generate a static site from journal entries in <code>.context/journal/</code>.</p> <pre><code>ctx journal site [flags]\n</code></pre> <p>Flags:</p> Flag Short Description <code>--output</code> <code>-o</code> Output directory (default: .context/journal-site) <code>--build</code> Run zensical build after generating <code>--serve</code> Run zensical serve after generating <p>Creates a <code>zensical</code>-compatible site structure with an index page listing all sessions by date, and individual pages for each journal entry.</p> <p>Requires <code>zensical</code> to be installed for <code>--build</code> or <code>--serve</code>:</p> <pre><code>pipx install zensical\n</code></pre> <p>Example:</p> <pre><code>ctx journal site                    # Generate in .context/journal-site/\nctx journal site --output ~/public  # Custom output directory\nctx journal site --build            # Generate and build HTML\nctx journal site --serve            # Generate and serve locally\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-journal-obsidian","level":4,"title":"<code>ctx journal obsidian</code>","text":"<p>Generate an Obsidian vault from journal entries in <code>.context/journal/</code>.</p> <pre><code>ctx journal obsidian [flags]\n</code></pre> <p>Flags:</p> Flag Short Description <code>--output</code> <code>-o</code> Output directory (default: .context/journal-obsidian) <p>Creates an Obsidian-compatible vault with:</p> <ul> <li>Wikilinks (<code>[[target|display]]</code>) for all internal navigation</li> <li>MOC pages (Map of Content) for topics, key files, and session types</li> <li>Related sessions footer linking entries that share topics</li> <li>Transformed frontmatter (<code>topics</code> → <code>tags</code> for Obsidian integration)</li> <li>Minimal <code>.obsidian/</code> config enforcing wikilink mode</li> </ul> <p>No external dependencies are required: Open the output directory as an Obsidian  vault directly.</p> <p>Example:</p> <pre><code>ctx journal obsidian                          # Generate in .context/journal-obsidian/\nctx journal obsidian --output ~/vaults/ctx    # Custom output directory\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-serve","level":3,"title":"<code>ctx serve</code>","text":"<p>Serve a static site locally via <code>zensical</code>.</p> <pre><code>ctx serve [directory]\n</code></pre> <p>If no directory is specified, serves the journal site (<code>.context/journal-site</code>).</p> <p>Requires <code>zensical</code> to be installed:</p> <pre><code>pipx install zensical\n</code></pre> <p>Example:</p> <pre><code>ctx serve                           # Serve journal site\nctx serve .context/journal-site     # Serve specific directory\nctx serve ./docs                    # Serve docs folder\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-watch","level":3,"title":"<code>ctx watch</code>","text":"<p>Watch for AI output and auto-apply context updates.</p> <p>Parses <code>&lt;context-update&gt;</code> XML commands from AI output and applies them to context files.</p> <pre><code>ctx watch [flags]\n</code></pre> <p>Flags:</p> Flag Description <code>--log &lt;file&gt;</code> Log file to watch (default: stdin) <code>--dry-run</code> Preview updates without applying <p>Example:</p> <pre><code># Watch stdin\nai-tool | ctx watch\n\n# Watch a log file\nctx watch --log /path/to/ai-output.log\n\n# Preview without applying\nctx watch --dry-run\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-hook","level":3,"title":"<code>ctx hook</code>","text":"<p>Generate AI tool integration configuration.</p> <pre><code>ctx hook &lt;tool&gt;\n</code></pre> <p>Supported tools:</p> Tool Description <code>claude-code</code> Redirects to plugin install instructions <code>cursor</code> Cursor IDE <code>aider</code> Aider CLI <code>copilot</code> GitHub Copilot <code>windsurf</code> Windsurf IDE <p>Claude Code uses the plugin system</p> <p>Claude Code integration is now provided via the ctx plugin. Running <code>ctx hook claude-code</code> prints plugin install instructions.</p> <p>Example:</p> <pre><code>ctx hook cursor\nctx hook aider\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-loop","level":3,"title":"<code>ctx loop</code>","text":"<p>Generate a shell script for running an autonomous loop.</p> <p>An autonomous loop continuously runs an AI assistant with the same prompt until a completion signal is detected, enabling iterative development where the AI builds on its previous work.</p> <pre><code>ctx loop [flags]\n</code></pre> <p>Flags:</p> Flag Short Description Default <code>--tool &lt;tool&gt;</code> <code>-t</code> AI tool: <code>claude</code>, <code>aider</code>, or <code>generic</code> <code>claude</code> <code>--prompt &lt;file&gt;</code> <code>-p</code> Prompt file to use <code>PROMPT.md</code> <code>--max-iterations &lt;n&gt;</code> <code>-n</code> Maximum iterations (0 = unlimited) <code>0</code> <code>--completion &lt;signal&gt;</code> <code>-c</code> Completion signal to detect <code>SYSTEM_CONVERGED</code> <code>--output &lt;file&gt;</code> <code>-o</code> Output script filename <code>loop.sh</code> <p>Example:</p> <pre><code># Generate loop.sh for Claude Code\nctx loop\n\n# Generate for Aider with custom prompt\nctx loop --tool aider --prompt TASKS.md\n\n# Limit to 10 iterations\nctx loop --max-iterations 10\n\n# Output to custom file\nctx loop -o my-loop.sh\n</code></pre> <p>Usage:</p> <pre><code># Generate and run the loop\nctx loop\nchmod +x loop.sh\n./loop.sh\n</code></pre> <p>See Autonomous Loops for detailed workflow documentation.</p>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-pad","level":3,"title":"<code>ctx pad</code>","text":"<p>Encrypted scratchpad for sensitive one-liners that travel with the project.</p> <p>When invoked without a subcommand, lists all entries.</p> <pre><code>ctx pad\nctx pad &lt;subcommand&gt;\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-pad-add","level":4,"title":"<code>ctx pad add</code>","text":"<p>Append a new entry to the scratchpad.</p> <pre><code>ctx pad add &lt;text&gt;\n</code></pre> <p>Example:</p> <pre><code>ctx pad add \"DATABASE_URL=postgres://user:pass@host/db\"\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-pad-show","level":4,"title":"<code>ctx pad show</code>","text":"<p>Output the raw text of an entry by number.</p> <pre><code>ctx pad show &lt;n&gt;\n</code></pre> <p>Arguments:</p> <ul> <li><code>n</code>: 1-based entry number</li> </ul> <p>Example:</p> <pre><code>ctx pad show 3\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-pad-rm","level":4,"title":"<code>ctx pad rm</code>","text":"<p>Remove an entry by number.</p> <pre><code>ctx pad rm &lt;n&gt;\n</code></pre> <p>Arguments:</p> <ul> <li><code>n</code>: 1-based entry number</li> </ul>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-pad-edit","level":4,"title":"<code>ctx pad edit</code>","text":"<p>Replace, append to, or prepend to an entry.</p> <pre><code>ctx pad edit &lt;n&gt; [text]\n</code></pre> <p>Arguments:</p> <ul> <li><code>n</code>: 1-based entry number</li> <li><code>text</code>: Replacement text (mutually exclusive with <code>--append</code>/<code>--prepend</code>)</li> </ul> <p>Flags:</p> Flag Description <code>--append</code> Append text to the end of the entry <code>--prepend</code> Prepend text to the beginning of entry <p>Example:</p> <pre><code>ctx pad edit 2 \"new text\"\nctx pad edit 2 --append \" suffix\"\nctx pad edit 2 --prepend \"prefix \"\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-pad-mv","level":4,"title":"<code>ctx pad mv</code>","text":"<p>Move an entry from one position to another.</p> <pre><code>ctx pad mv &lt;from&gt; &lt;to&gt;\n</code></pre> <p>Arguments:</p> <ul> <li><code>from</code>: Source position (1-based)</li> <li><code>to</code>: Destination position (1-based)</li> </ul>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#ctx-pad-resolve","level":4,"title":"<code>ctx pad resolve</code>","text":"<p>Show both sides of a merge conflict in the encrypted scratchpad.</p> <pre><code>ctx pad resolve\n</code></pre>","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#exit-codes","level":2,"title":"Exit Codes","text":"Code Meaning 0 Success 1 General error / warnings (e.g. drift) 2 Context not found 3 Violations found (e.g. drift) 4 File operation error","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#environment-variables","level":2,"title":"Environment Variables","text":"Variable Description <code>CTX_DIR</code> Override default context directory path <code>CTX_TOKEN_BUDGET</code> Override default token budget <code>NO_COLOR</code> Disable colored output when set","path":["Reference","ctx CLI"],"tags":[]},{"location":"cli-reference/#configuration-file","level":2,"title":"Configuration File","text":"<p>Optional <code>.contextrc</code> (YAML format) at project root:</p> <pre><code># .contextrc\ncontext_dir: .context    # Context directory name\ntoken_budget: 8000       # Default token budget\npriority_order:          # File loading priority\n  - TASKS.md\n  - DECISIONS.md\n  - CONVENTIONS.md\nauto_archive: true       # Auto-archive old items\narchive_after_days: 7    # Days before archiving\nscratchpad_encrypt: true # Encrypt scratchpad (default: true)\nallow_outside_cwd: false # Skip boundary check (default: false)\n</code></pre> Field Type Default Description <code>context_dir</code> <code>string</code> <code>.context</code> Context directory name (relative to project root) <code>token_budget</code> <code>int</code> <code>8000</code> Default token budget for <code>ctx agent</code> <code>priority_order</code> <code>[]string</code> (all files) File loading priority for context packets <code>auto_archive</code> <code>bool</code> <code>false</code> Auto-archive completed tasks <code>archive_after_days</code> <code>int</code> <code>7</code> Days before completed tasks are archived <code>scratchpad_encrypt</code> <code>bool</code> <code>true</code> Encrypt scratchpad with AES-256-GCM <code>allow_outside_cwd</code> <code>bool</code> <code>false</code> Skip boundary check for external context dirs <p>Priority order: CLI flags &gt; Environment variables &gt; <code>.contextrc</code> &gt; Defaults</p> <p>All settings are optional. Missing values use defaults.</p>","path":["Reference","ctx CLI"],"tags":[]},{"location":"common-workflows/","level":1,"title":"Common Workflows","text":"","path":["Home","Common Workflows"],"tags":[]},{"location":"common-workflows/#track-context","level":2,"title":"Track Context","text":"<pre><code># Add a task\nctx add task \"Implement user authentication\"\n\n# Record a decision (full ADR fields required)\nctx add decision \"Use PostgreSQL for primary database\" \\\n  --context \"Need a reliable database for production\" \\\n  --rationale \"PostgreSQL offers ACID compliance and JSON support\" \\\n  --consequences \"Team needs PostgreSQL training\"\n\n# Note a learning\nctx add learning \"Mock functions must be hoisted in Jest\" \\\n  --context \"Tests failed with undefined mock errors\" \\\n  --lesson \"Jest hoists mock calls to top of file\" \\\n  --application \"Place jest.mock() before imports\"\n\n# Mark task complete\nctx complete \"user auth\"\n</code></pre>","path":["Home","Common Workflows"],"tags":[]},{"location":"common-workflows/#check-context-health","level":2,"title":"Check Context Health","text":"<pre><code># Detect stale paths, missing files, potential secrets\nctx drift\n\n# See full context summary\nctx status\n</code></pre>","path":["Home","Common Workflows"],"tags":[]},{"location":"common-workflows/#browse-session-history","level":2,"title":"Browse Session History","text":"<p>List and search past AI sessions from the terminal:</p> <pre><code>ctx recall list --limit 5\n</code></pre>","path":["Home","Common Workflows"],"tags":[]},{"location":"common-workflows/#journal-site","level":3,"title":"Journal Site","text":"<p>Export session transcripts to a browsable static site with search, navigation, and topic indices.</p> <p>The <code>ctx journal</code> command requires zensical (Python &gt;= 3.10).</p> <p><code>zensical</code> is a Python-based static site generator from the Material for MkDocs team.</p> <p>(why zensical?).</p> <p>If you don't have it on your system, install <code>zensical</code> once with pipx:</p> <pre><code># One-time setup\npipx install zensical\n</code></pre> <p>Avoid <code>pip install zensical</code></p> <p><code>pip install</code> often fails: For example, on macOS, system Python installs a non-functional stub (<code>zensical</code> requires <code>Python &gt;= 3.10</code>), and Homebrew Python blocks system-wide installs (<code>PEP 668</code>).</p> <p><code>pipx</code> creates an isolated environment with the correct Python version automatically.</p> <p>Then, export and serve:</p> <pre><code># Export all sessions to .context/journal/\nctx recall export --all\n\n# Generate and serve the journal site\nctx journal site --serve\n</code></pre> <p>Open http://localhost:8000 to browse.</p> <p>To update after new sessions, run the same two commands again; <code>recall export</code> preserves existing YAML frontmatter and only updates conversation content.</p> <p>See Session Journal for the full pipeline including normalization and enrichment.</p>","path":["Home","Common Workflows"],"tags":[]},{"location":"common-workflows/#run-an-autonomous-loop","level":2,"title":"Run an Autonomous Loop","text":"<p>Generate a script that iterates an AI agent until a completion signal is detected:</p> <pre><code>ctx loop\nchmod +x loop.sh\n./loop.sh\n</code></pre> <p>See Autonomous Loops for configuration and advanced usage.</p> <p>Next Up: Context Files → — what each <code>.context/</code> file does and how to use it.</p> <p>See Also:</p> <ul> <li>Recipes — targeted how-to guides for specific tasks</li> <li>Knowledge Capture — patterns for recording decisions, learnings, and conventions</li> <li>Context Health — keeping your <code>.context/</code> accurate and drift-free</li> <li>Session Archaeology — digging into past sessions</li> <li>Task Management — tracking and completing work items</li> </ul>","path":["Home","Common Workflows"],"tags":[]},{"location":"comparison/","level":1,"title":"ctx and Similar Tools","text":"","path":["Reference","ctx and Similar Tools"],"tags":[]},{"location":"comparison/#high-level-mental-model","level":2,"title":"High-Level Mental Model","text":"<p>Many tools help AI think.</p> <p><code>ctx</code> helps AI remember.</p> <ul> <li>Not by storing thoughts,</li> <li>but by preserving intent.</li> </ul>","path":["Reference","ctx and Similar Tools"],"tags":[]},{"location":"comparison/#how-ctx-differs-from-similar-tools","level":2,"title":"How <code>ctx</code> Differs from Similar Tools","text":"<p>There are many tools in the AI ecosystem that touch parts of the context problem:</p> <ul> <li>Some manage prompts.  </li> <li>Some retrieve data.  </li> <li>Some provide runtime context objects.  </li> <li>Some offer enterprise platforms.</li> </ul> <p><code>ctx</code> focuses on a different layer entirely.</p> <p>This page explains where <code>ctx</code> fits, and where it intentionally does not.</p>","path":["Reference","ctx and Similar Tools"],"tags":[]},{"location":"comparison/#the-core-distinction","level":2,"title":"The Core Distinction","text":"<p>Most tools treat context as input.</p> <p><code>ctx</code> treats context as infrastructure.</p> <p>That single difference explains nearly all of <code>ctx</code>'s design choices.</p> Question Most tools ctx Where does context live? In prompts or APIs In files How long does it last? One request / one session Across time Who can read it? The model Humans and tools How is it updated? Implicitly Explicitly Is it inspectable? Rarely Always","path":["Reference","ctx and Similar Tools"],"tags":[]},{"location":"comparison/#prompt-management-tools","level":2,"title":"Prompt Management Tools","text":"<p>Examples include:</p> <ul> <li>prompt templates</li> <li>reusable system prompts</li> <li>prompt libraries</li> <li>prompt versioning tools</li> </ul> <p>These tools help you start a session.</p> <p>They do not help you continue one.</p> <p>Prompt tools:</p> <ul> <li>inject text at session start</li> <li>are ephemeral by design</li> <li>do not evolve with the project</li> </ul> <p><code>ctx</code>:</p> <ul> <li>persists knowledge over time</li> <li>accumulates decisions and learnings</li> <li>makes the context part of the repository itself</li> </ul> <p>Prompt tooling and <code>ctx</code> are complementary; not competing.  Yet they operate in different layers.</p>","path":["Reference","ctx and Similar Tools"],"tags":[]},{"location":"comparison/#retrieval-augmented-generation-rag","level":2,"title":"Retrieval-Augmented Generation (RAG)","text":"<p>RAG systems typically:</p> <ul> <li>index documents</li> <li>embed text</li> <li>retrieve chunks dynamically at runtime</li> </ul> <p>They are excellent for:</p> <ul> <li>large knowledge bases</li> <li>static documentation</li> <li>reference material</li> </ul> <p>RAG answers questions like:</p> <p>\"What information might be relevant right now?\"</p> <p><code>ctx</code> answers a different question:</p> <p>\"What have we already decided, learned, or committed to?\"</p> <p>Here are some key differences:</p> RAG ctx Statistical relevance Intentional relevance Embedding-based File-based Opaque retrieval Explicit structure Runtime query Persistent memory <p><code>ctx</code> does not replace RAG. Instead, it defines a persistent context layer that RAG can optionally augment.</p> <p>RAG belongs to the data plane; ctx defines the context control plane.</p> <p>It focuses on project memory, not knowledge search.</p>","path":["Reference","ctx and Similar Tools"],"tags":[]},{"location":"comparison/#agent-frameworks","level":2,"title":"Agent Frameworks","text":"<p>Agent frameworks often provide:</p> <ul> <li>task loops</li> <li>tool orchestration</li> <li>planner/executor patterns</li> <li>autonomous iteration</li> </ul> <p>These systems are powerful, but they typically assume that:</p> <ul> <li>memory is external</li> <li>context is injected</li> <li>state is transient</li> </ul> <p>Agent frameworks answer:</p> <p>\"How should the agent act?\"</p> <p><code>ctx</code> answers:</p> <p>\"What should the agent remember?\"</p> <p>Without persistent context, agents tend to:</p> <ul> <li>rediscover decisions</li> <li>repeat mistakes</li> <li>lose architectural intent</li> </ul> <p>This is why <code>ctx</code> pairs well with autonomous loop workflows:</p> <ul> <li>The loop provides iteration</li> <li><code>ctx</code> provides continuity</li> </ul> <p>Together, loops become cumulative instead of forgetful.</p>","path":["Reference","ctx and Similar Tools"],"tags":[]},{"location":"comparison/#sdk-level-context-objects","level":2,"title":"SDK-Level Context Objects","text":"<p>Some SDKs expose \"context\" objects that exist:</p> <ul> <li>inside a process</li> <li>during a request</li> <li>for the lifetime of a call chain</li> </ul> <p>These are extremely useful and completely different.</p> <p>SDK context objects:</p> <ul> <li>are in-memory</li> <li>disappear when the process ends</li> <li>are not shared across sessions</li> </ul> <p><code>ctx</code>:</p> <ul> <li>survives process restarts</li> <li>survives new chats</li> <li>survives new days</li> </ul> <p>They share a name, not a purpose.</p>","path":["Reference","ctx and Similar Tools"],"tags":[]},{"location":"comparison/#enterprise-context-platforms","level":2,"title":"Enterprise Context Platforms","text":"<p>Enterprise platforms often provide:</p> <ul> <li>centralized context services</li> <li>dashboards</li> <li>access control</li> <li>organizational knowledge layers</li> </ul> <p>These tools are designed for:</p> <ul> <li>teams</li> <li>governance</li> <li>compliance</li> <li>managed environments</li> </ul> <p><code>ctx</code> is intentionally:</p> <ul> <li>local-first</li> <li>file-based</li> <li>dependency-free</li> <li>CLI-driven</li> <li>developer-controlled</li> </ul> <p>It does not require:</p> <ul> <li>a server</li> <li>a database</li> <li>an account</li> <li>a SaaS backend</li> </ul> <p><code>ctx</code> optimizes for individual and small-team workflows where context should live next to code; not behind a service boundary.</p>","path":["Reference","ctx and Similar Tools"],"tags":[]},{"location":"comparison/#when-ctx-is-a-good-fit","level":2,"title":"When <code>ctx</code> Is a Good Fit","text":"<p><code>ctx</code> works best when:</p> <ul> <li>you want AI work to compound over time</li> <li>architectural decisions matter</li> <li>context must be inspectable</li> <li>humans and AI must share the same source of truth</li> <li>Git history should include why, not just what</li> </ul>","path":["Reference","ctx and Similar Tools"],"tags":[]},{"location":"comparison/#when-ctx-is-not-the-right-tool","level":2,"title":"When <code>ctx</code> Is Not the Right Tool","text":"<p><code>ctx</code> is probably not what you want if:</p> <ul> <li>you only need one-off prompts</li> <li>you rely exclusively on RAG</li> <li>you want autonomous agents without a human-readable state</li> <li>you require centralized enterprise control</li> <li>you want black-box memory systems</li> </ul> <p>These are valid goals; just different ones.</p>","path":["Reference","ctx and Similar Tools"],"tags":[]},{"location":"comparison/#further-reading","level":2,"title":"Further Reading","text":"<ul> <li>You Can't Import Expertise — Why project-specific context matters more than generic best practices</li> </ul>","path":["Reference","ctx and Similar Tools"],"tags":[]},{"location":"context-files/","level":1,"title":"Context Files","text":"","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#context","level":2,"title":"<code>.context/</code>","text":"<p>Each context file in <code>.context/</code> serves a specific purpose. </p> <p>Files are designed to be human-readable, AI-parseable, and token-efficient.</p>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#file-overview","level":2,"title":"File Overview","text":"File Purpose Priority <code>CONSTITUTION.md</code> Hard rules that must NEVER be violated 1 (highest) <code>TASKS.md</code> Current and planned work 2 <code>CONVENTIONS.md</code> Project patterns and standards 3 <code>ARCHITECTURE.md</code> System overview and components 4 <code>DECISIONS.md</code> Architectural decisions with rationale 5 <code>LEARNINGS.md</code> Lessons learned, gotchas, tips 6 <code>GLOSSARY.md</code> Domain terms and abbreviations 7 <code>AGENT_PLAYBOOK.md</code> Instructions for AI tools 8 (lowest)","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#read-order-rationale","level":2,"title":"Read Order Rationale","text":"<p>The priority order follows a logical progression for AI tools:</p> <ol> <li><code>CONSTITUTION.md</code>: Inviolable rules first. The AI tool must know what it    cannot do before attempting anything.</li> <li><code>TASKS.md</code>: Current work items. What the AI tool should focus on.</li> <li><code>CONVENTIONS.md</code>: How to write code. Patterns and standards to follow    when implementing tasks.</li> <li><code>ARCHITECTURE.md</code>: System structure. Understanding of components and    boundaries before making changes.</li> <li><code>DECISIONS.md</code>: Historical context. Why things are the way they are,    to avoid re-debating settled decisions.</li> <li><code>LEARNINGS.md</code>: Gotchas and tips. Lessons from past work that inform    the current implementation.</li> <li><code>GLOSSARY.md</code>: Reference material. Domain terms and abbreviations for    lookup as needed.</li> <li><code>AGENT_PLAYBOOK.md</code>: Meta instructions last. How to use this context    system itself. Loaded last because the agent should understand the    content (rules, tasks, patterns) before the operating manual.</li> </ol>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#constitutionmd","level":2,"title":"<code>CONSTITUTION.md</code>","text":"<p>Purpose: Define hard invariants—rules that must NEVER be violated,  regardless of the task.</p> <p>AI tools read this first and should refuse tasks that violate these rules.</p>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#structure","level":3,"title":"Structure","text":"<pre><code># Constitution\n\nThese rules are INVIOLABLE. If a task requires violating these, the task \nis wrong.\n\n## Security Invariants\n\n- [ ] Never commit secrets, tokens, API keys, or credentials\n- [ ] Never store customer/user data in context files\n- [ ] Never disable security linters without documented exception\n\n## Quality Invariants\n\n- [ ] All code must pass tests before commit\n- [ ] No `any` types in TypeScript without documented reason\n- [ ] No TODO comments in main branch (move to TASKS.md)\n\n## Process Invariants\n\n- [ ] All architectural changes require a decision record\n- [ ] Breaking changes require version bump\n- [ ] Generated files are never committed\n</code></pre>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#guidelines","level":3,"title":"Guidelines","text":"<ul> <li>Keep rules minimal and absolute</li> <li>Each rule should be enforceable (can verify compliance)</li> <li>Use checkbox format for clarity</li> <li>Never compromise on these rules</li> </ul>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#tasksmd","level":2,"title":"<code>TASKS.md</code>","text":"<p>Purpose: Track current work, planned work, and blockers.</p>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#structure_1","level":3,"title":"Structure","text":"<p>Tasks are organized by Phase: logical groupings that preserve order and enable replay. </p> <p>Tasks stay in their Phase permanently; status is tracked via checkboxes and  inline tags.</p> <pre><code># Tasks\n\n## Phase 1: Initial Setup\n\n- [x] Set up project structure\n- [x] Configure linting and formatting\n- [ ] Add CI/CD pipeline `#in-progress`\n\n## Phase 2: Core Features\n\n- [ ] Implement user authentication `#priority:high`\n- [ ] Add API rate limiting `#priority:medium`\n  - Blocked by: Need to finalize auth first\n\n## Backlog\n\n- [ ] Performance optimization `#priority:low`\n- [ ] Add metrics dashboard `#priority:deferred`\n</code></pre> <p>Key principles:</p> <ul> <li>Tasks never move between sections — mark as <code>[x]</code> or <code>[-]</code> in place</li> <li>Use <code>#in-progress</code> inline tag to indicate current work</li> <li>Phase headers provide structure and replay order</li> <li>Backlog section for unscheduled work</li> </ul>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#tags","level":3,"title":"Tags","text":"<p>Use inline backtick-wrapped tags for metadata:</p> Tag Values Purpose <code>#priority</code> <code>high</code>, <code>medium</code>, <code>low</code> Task urgency <code>#area</code> <code>core</code>, <code>cli</code>, <code>docs</code>, <code>tests</code> Codebase area <code>#estimate</code> <code>1h</code>, <code>4h</code>, <code>1d</code> Time estimate (optional) <code>#in-progress</code> (none) Currently being worked on <p>Lifecycle tags (for session correlation):</p> Tag Format When to add <code>#added</code> <code>YYYY-MM-DD-HHMMSS</code> Auto-added by <code>ctx add task</code> <code>#started</code> <code>YYYY-MM-DD-HHMMSS</code> When beginning work on the task <code>#done</code> <code>YYYY-MM-DD-HHMMSS</code> When marking the task <code>[x]</code> <p>These timestamps help correlate tasks with session files and track which session started vs completed work.</p>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#status-markers","level":3,"title":"Status Markers","text":"Marker Meaning <code>[ ]</code> Pending <code>[x]</code> Completed <code>[-]</code> Skipped (include reason)","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#guidelines_1","level":3,"title":"Guidelines","text":"<ul> <li>Never delete tasks; mark as <code>[x]</code> completed or <code>[-]</code> skipped</li> <li>Never move tasks between sections; use inline tags for status</li> <li>Use <code>ctx tasks archive</code> periodically to move completed tasks to archive</li> <li>Mark current work with <code>#in-progress</code> inline tag</li> </ul>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#decisionsmd","level":2,"title":"<code>DECISIONS.md</code>","text":"<p>Purpose: Record architectural decisions with rationale so they don't get re-debated.</p>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#structure_2","level":3,"title":"Structure","text":"<pre><code># Decisions\n\n## [YYYY-MM-DD] Decision Title\n\n**Status**: Accepted | Superseded | Deprecated\n\n**Context**: What situation prompted this decision?\n\n**Decision**: What was decided?\n\n**Rationale**: Why was this the right choice?\n\n**Consequences**: What are the implications?\n\n**Alternatives Considered**:\n- Alternative A: Why rejected\n- Alternative B: Why rejected\n</code></pre>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#example","level":3,"title":"Example","text":"<pre><code>## [2025-01-15] Use TypeScript Strict Mode\n\n**Status**: Accepted\n\n**Context**: Starting a new project, need to choose the type-checking level.\n\n**Decision**: Enable TypeScript strict mode with all strict flags.\n\n**Rationale**: Catches more bugs at compile time. Team has experience\nwith strict mode. Upfront cost pays off in reduced runtime errors.\n\n**Consequences**: More verbose type annotations required. Some\nthird-party libraries need type assertions.\n\n**Alternatives Considered**:\n- Basic TypeScript: Rejected because it misses null checks\n- JavaScript with JSDoc: Rejected because tooling support is weaker\n</code></pre>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#status-values","level":3,"title":"Status Values","text":"Status Meaning Accepted Current, active decision Superseded Replaced by newer decision (link to it) Deprecated No longer relevant","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#learningsmd","level":2,"title":"<code>LEARNINGS.md</code>","text":"<p>Purpose: Capture lessons learned, gotchas, and tips that shouldn't be forgotten.</p>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#structure_3","level":3,"title":"Structure","text":"<pre><code># Learnings\n\n## Category Name\n\n### Learning Title\n\n**Discovered**: YYYY-MM-DD\n\n**Context**: When/how was this learned?\n\n**Lesson**: What's the takeaway?\n\n**Application**: How should this inform future work?\n</code></pre>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#example_1","level":3,"title":"Example","text":"<pre><code>## Testing\n\n### Vitest Mocks Must Be Hoisted\n\n**Discovered**: 2025-01-15\n\n**Context**: Tests were failing intermittently when mocking fs module.\n\n**Lesson**: Vitest requires `vi.mock()` calls to be hoisted to the\ntop of the file. Dynamic mocks need `vi.doMock()` instead.\n\n**Application**: Always use `vi.mock()` at file top. Use `vi.doMock()`\nonly when mock needs runtime values.\n</code></pre>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#categories","level":3,"title":"Categories","text":"<p>Organize learnings by topic:</p> <ul> <li>Testing</li> <li>Build &amp; Deploy</li> <li>Performance</li> <li>Security</li> <li>Third-Party Libraries</li> <li>Git &amp; Workflow</li> </ul>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#conventionsmd","level":2,"title":"<code>CONVENTIONS.md</code>","text":"<p>Purpose: Document project patterns, naming conventions, and standards.</p>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#structure_4","level":3,"title":"Structure","text":"<pre><code># Conventions\n\n## Naming\n\n* **Files**: kebab-case for all source files\n* **Components**: PascalCase for React components\n* **Functions**: camelCase, verb-first (getUser, parseConfig)\n* **Constants**: SCREAMING_SNAKE_CASE\n\n## Patterns\n\n### Pattern Name\n\n**When to use**: Situation description\n\n**Implementation**:\n// in triple backticks\n// Example code\n\n**Why**: Rationale for this pattern\n</code></pre>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#guidelines_2","level":3,"title":"Guidelines","text":"<ul> <li>Include concrete examples</li> <li>Explain the \"why\" not just the \"what\"</li> <li>Keep patterns minimal—only document what's non-obvious</li> </ul>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#architecturemd","level":2,"title":"<code>ARCHITECTURE.md</code>","text":"<p>Purpose: Provide system overview and component relationships.</p>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#structure_5","level":3,"title":"Structure","text":"<pre><code># Architecture\n\n## Overview\n\nBrief description of what the system does and how it's organized.\n\n## Components\n\n### Component Name\n\n**Responsibility**: What this component does\n\n**Dependencies**: What it depends on\n\n**Dependents**: What depends on it\n\n**Key Files**:\n- path/to/file.ts — Description\n\n## Data Flow\n\nDescription or diagram of how data moves through the system.\n\n## Boundaries\n\nWhat's in scope vs out of scope for this codebase.\n</code></pre>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#guidelines_3","level":3,"title":"Guidelines","text":"<ul> <li>Keep diagrams simple (Mermaid works well)</li> <li>Focus on boundaries and interfaces</li> <li>Update when major structural changes occur</li> </ul>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#glossarymd","level":2,"title":"<code>GLOSSARY.md</code>","text":"<p>Purpose: Define domain terms, abbreviations, and project vocabulary.</p>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#structure_6","level":3,"title":"Structure","text":"<pre><code># Glossary\n\n## Domain Terms\n\n### Term Name\n\n**Definition**: What it means in this project's context\n\n**Not to be confused with**: Similar terms that mean different things\n\n**Example**: How it's used\n\n## Abbreviations\n\n| Abbrev | Expansion                     | Context                |\n|--------|-------------------------------|------------------------|\n| ADR    | Architectural Decision Record | Decision documentation |\n| SUT    | System Under Test             | Testing                |\n</code></pre>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#guidelines_4","level":3,"title":"Guidelines","text":"<ul> <li>Define project-specific meanings</li> <li>Clarify potentially ambiguous terms</li> <li>Include abbreviations used in code or docs</li> </ul>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#agent_playbookmd","level":2,"title":"<code>AGENT_PLAYBOOK.md</code>","text":"<p>Purpose: Explicit instructions for how AI tools should read, apply,  and update context.</p>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#key-sections","level":3,"title":"Key Sections","text":"<p>Read Order: Priority order for loading context files</p> <p>When to Update: Events that trigger context updates</p> <p>How to Avoid Hallucinating Memory: Critical rules:</p> <ol> <li>Never assume—if not in files, you don't know it</li> <li>Never invent history—don't claim \"we discussed\" without evidence</li> <li>Verify before referencing—search files before citing</li> <li>When uncertain, say so</li> <li>Trust files over intuition</li> </ol> <p>Context Update Commands: Format for automated updates via <code>ctx watch</code>:</p> <pre><code>&lt;context-update type=\"task\"&gt;Implement rate limiting&lt;/context-update&gt;\n&lt;context-update type=\"complete\"&gt;user auth&lt;/context-update&gt;\n&lt;context-update type=\"learning\"\n  context=\"Debugging hooks\"\n  lesson=\"Hooks receive JSON via stdin\"\n  application=\"Parse JSON stdin with the host language\"\n&gt;Hook Input Format&lt;/context-update&gt;\n&lt;context-update type=\"decision\"\n  context=\"Need a caching layer\"\n  rationale=\"Redis is fast and team has experience\"\n  consequences=\"Must provision Redis infrastructure\"\n&gt;Use Redis for caching&lt;/context-update&gt;\n</code></pre> <p>See Integrations for full documentation.</p>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#parsing-rules","level":2,"title":"Parsing Rules","text":"<p>All context files follow these conventions:</p> <ol> <li>Headers define structure: <code>#</code> for title, <code>##</code> for sections, <code>###</code> for     items</li> <li>Bold keys for fields: <code>**Key**:</code> followed by value</li> <li>Code blocks are literal: Never parse code block content as structure</li> <li>Lists are ordered: Items appear in priority/chronological order</li> <li>Tags are inline: Backtick-wrapped tags like <code>#priority:high</code></li> </ol>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#further-reading","level":2,"title":"Further Reading","text":"<ul> <li>Refactoring with Intent:   How persistent context prevents drift during refactoring sessions.</li> </ul>","path":["Home","Context Files"],"tags":[]},{"location":"context-files/#token-efficiency","level":2,"title":"Token Efficiency","text":"<p>Keep context files concise:</p> <ul> <li>Use abbreviations in tags, not prose;</li> <li>Omit obvious words (\"The,\" \"This\");</li> <li>Prefer bullet points over paragraphs;</li> <li>Keep examples minimal but illustrative;</li> <li>Archive old completed items periodically.</li> </ul> <p>Next Up: Prompting Guide → — effective prompts for AI sessions with ctx.</p>","path":["Home","Context Files"],"tags":[]},{"location":"contributing/","level":1,"title":"Contributing to ctx","text":"","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#development-setup","level":2,"title":"Development Setup","text":"","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#prerequisites","level":3,"title":"Prerequisites","text":"<ul> <li>Go 1.25+</li> <li>Claude Code</li> <li>Git</li> </ul>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#1-fork-or-clone-the-repository","level":3,"title":"1. Fork (or Clone) the Repository","text":"<pre><code># Fork on GitHub, then:\ngit clone https://github.com/&lt;you&gt;/ctx.git\ncd ctx\n\n# Or, if you have push access:\ngit clone https://github.com/ActiveMemory/ctx.git\ncd ctx\n</code></pre>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#2-build-and-install-the-binary","level":3,"title":"2. Build and Install the Binary","text":"<pre><code>make build\nsudo make install\n</code></pre> <p>This compiles the <code>ctx</code> binary and places it in <code>/usr/local/bin/</code>.</p>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#3-install-the-plugin-from-your-local-clone","level":3,"title":"3. Install the Plugin from Your Local Clone","text":"<p>The repository ships a Claude Code plugin under <code>internal/assets/claude/</code>. Point Claude Code at your local copy so that skills and hooks reflect your working tree — no reinstall needed after edits:</p> <ol> <li>Launch <code>claude</code></li> <li>Type <code>/plugin</code> and press Enter</li> <li>Select Marketplaces → Add Marketplace</li> <li>Enter the absolute path to the root of your clone,    e.g. <code>~/WORKSPACE/ctx</code>    (this is where <code>.claude-plugin/marketplace.json</code> lives — it points    Claude Code to the actual plugin in <code>internal/assets/claude</code>)</li> <li>Back in <code>/plugin</code>, select Install and choose <code>ctx</code></li> </ol> <p>Local Plugin = Live Edits</p> <p>Because the marketplace points at a directory on disk, any change you make to a skill or hook under <code>internal/assets/claude/</code> takes effect the next time Claude Code loads it. No rebuild, no reinstall.</p>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#4-verify","level":3,"title":"4. Verify","text":"<pre><code>ctx --version       # binary is in PATH\nclaude /plugin list # plugin is installed\n</code></pre> <p>You should see the <code>ctx</code> plugin listed, sourced from your local path.</p>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#project-layout","level":2,"title":"Project Layout","text":"<pre><code>ctx/\n├── cmd/ctx/                  # CLI entry point\n├── internal/\n│   ├── cli/                  # Command implementations\n│   ├── context/              # Core context logic\n│   ├── drift/                # Drift detection\n│   ├── claude/               # Claude Code integration helpers\n│   └── tpl/                  # Embedded templates and plugin\n│       └── claude/           # ← Claude Code plugin (skills, hooks)\n│           └── skills/       #   Source of truth for distributed skills\n├── .claude/\n│   └── skills/               # Dev-only skills (not distributed)\n├── specs/                    # Feature specifications\n├── docs/                     # Documentation site source\n└── .context/                 # ctx's own context (dogfooding)\n</code></pre>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#skills-two-directories-one-rule","level":3,"title":"Skills: Two Directories, One Rule","text":"Directory What lives here Distributed to users? <code>internal/assets/claude/skills/</code> The 25 <code>ctx-*</code> skills that ship with the plugin Yes <code>.claude/skills/</code> Dev-only skills (release, QA, backup, etc.) No <p><code>internal/assets/claude/skills/</code> is the single source of truth for user-facing skills. If you are adding or modifying a <code>ctx-*</code> skill, edit it there.</p> <p><code>.claude/skills/</code> holds skills that only make sense inside this repository (release automation, QA checks, backup scripts). These are never distributed to users.</p>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#day-to-day-workflow","level":2,"title":"Day-to-Day Workflow","text":"","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#go-code-changes","level":3,"title":"Go Code Changes","text":"<p>After modifying Go source files, rebuild and reinstall:</p> <pre><code>make build &amp;&amp; sudo make install\n</code></pre> <p>The <code>ctx</code> binary is statically compiled — there is no hot reload. You must rebuild for Go changes to take effect.</p>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#skill-or-hook-changes","level":3,"title":"Skill or Hook Changes","text":"<p>Edit files under <code>internal/assets/claude/skills/</code> or <code>internal/assets/claude/hooks/</code>. Changes are picked up by Claude Code automatically (no rebuild needed).</p>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#running-tests","level":3,"title":"Running Tests","text":"<pre><code>make test            # fast: all tests\nmake audit           # full: fmt + vet + lint + drift + docs + test\nmake smoke           # build + run basic commands end-to-end\n</code></pre>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#running-the-docs-site-locally","level":3,"title":"Running the Docs Site Locally","text":"<pre><code>make site-setup      # one-time: install zensical via pipx\nmake site-serve      # serve at localhost\n</code></pre>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#submitting-changes","level":2,"title":"Submitting Changes","text":"","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#before-you-start","level":3,"title":"Before You Start","text":"<ol> <li>Check existing issues to avoid duplicating effort</li> <li>For large changes, open an issue first to discuss the approach</li> <li>Read the specs in <code>specs/</code> for design context</li> </ol>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#pull-request-process","level":3,"title":"Pull Request Process","text":"<ol> <li>Create a feature branch: <code>git checkout -b feature/my-feature</code></li> <li>Make your changes</li> <li>Run <code>make audit</code> to catch issues early</li> <li>Commit with a clear message (see below)</li> <li>Push and open a pull request</li> </ol>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#commit-messages","level":3,"title":"Commit Messages","text":"<p>Follow conventional commits:</p> <pre><code>type(scope): description\n\n[optional body]\n\n[optional footer]\n</code></pre> <p>Types: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>test</code>, <code>refactor</code>, <code>chore</code></p> <p>Examples:</p> <ul> <li><code>feat(cli): add ctx export command</code></li> <li><code>fix(drift): handle missing files gracefully</code></li> <li><code>docs: update installation instructions</code></li> </ul>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#code-style","level":3,"title":"Code Style","text":"<ul> <li>Follow Go conventions (<code>gofmt</code>, <code>go vet</code>)</li> <li>Keep functions focused and small</li> <li>Add tests for new functionality</li> <li>Handle errors explicitly</li> </ul>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#legal","level":2,"title":"Legal","text":"","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#developer-certificate-of-origin-dco","level":3,"title":"Developer Certificate of Origin (DCO)","text":"<p>By contributing, you agree to the Developer Certificate of Origin.</p> <p>All commits must be signed off:</p> <pre><code>git commit -s -m \"feat: add new feature\"\n</code></pre>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#license","level":3,"title":"License","text":"<p>Contributions are licensed under the Apache 2.0 License.</p>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"contributing/#code-of-conduct","level":3,"title":"Code of Conduct","text":"<p>This project follows the Contributor Covenant Code of Conduct.</p>","path":["Operations","Contributing to ctx"],"tags":[]},{"location":"first-session/","level":1,"title":"Your First Session","text":"<p>Here's what a complete first session looks like, from initialization to the moment your AI cites your project context back to you.</p>","path":["Home","Your First Session"],"tags":[]},{"location":"first-session/#step-1-initialize-your-project","level":2,"title":"Step 1: Initialize Your Project","text":"<pre><code>cd your-project\nctx init\n</code></pre> <pre><code>Context initialized in .context/\n\n  ✓ CONSTITUTION.md\n  ✓ TASKS.md\n  ✓ DECISIONS.md\n  ✓ LEARNINGS.md\n  ✓ CONVENTIONS.md\n  ✓ ARCHITECTURE.md\n  ✓ GLOSSARY.md\n  ✓ AGENT_PLAYBOOK.md\n\nCreating project root files...\n  ✓ PROMPT.md\n  ✓ IMPLEMENTATION_PLAN.md\n\nSetting up Claude Code permissions...\n  ✓ .scratchpad.key\n\nClaude Code plugin (hooks + skills):\n  Install: claude /plugin marketplace add ActiveMemory/ctx\n  Then:    claude /plugin install ctx@activememory-ctx\n\nNext steps:\n  1. Edit .context/TASKS.md to add your current tasks\n  2. Run 'ctx status' to see context summary\n  3. Run 'ctx agent' to get AI-ready context packet\n</code></pre> <p>This created your <code>.context/</code> directory with template files. For Claude Code, install the ctx plugin to get automatic hooks and skills.</p>","path":["Home","Your First Session"],"tags":[]},{"location":"first-session/#step-2-populate-your-context","level":2,"title":"Step 2: Populate Your Context","text":"<p>Add a task and a decision — these are the entries your AI will remember:</p> <pre><code>ctx add task \"Implement user authentication\"\n</code></pre> <pre><code>✓ Added to TASKS.md\n</code></pre> <pre><code>ctx add decision \"Use PostgreSQL for primary database\" \\\n  --context \"Need a reliable database for production\" \\\n  --rationale \"PostgreSQL offers ACID compliance and JSON support\" \\\n  --consequences \"Team needs PostgreSQL training\"\n</code></pre> <pre><code>✓ Added to DECISIONS.md\n</code></pre> <p>These entries are what the AI will recall in future sessions. You don't need to populate everything now — context grows naturally as you work.</p>","path":["Home","Your First Session"],"tags":[]},{"location":"first-session/#step-3-check-your-context","level":2,"title":"Step 3: Check Your Context","text":"<pre><code>ctx status\n</code></pre> <pre><code>Context Status\n====================\n\nContext Directory: .context/\nTotal Files: 8\nToken Estimate: 1,247 tokens\n\nFiles:\n  ✓ CONSTITUTION.md (loaded)\n  ✓ TASKS.md (1 items)\n  ✓ DECISIONS.md (1 items)\n  ○ LEARNINGS.md (empty)\n  ✓ CONVENTIONS.md (loaded)\n  ✓ ARCHITECTURE.md (loaded)\n  ✓ GLOSSARY.md (loaded)\n  ✓ AGENT_PLAYBOOK.md (loaded)\n\nRecent Activity:\n  - TASKS.md modified 2 minutes ago\n  - DECISIONS.md modified 1 minute ago\n</code></pre> <p>Notice the token estimate: This is how much context your AI will load.</p> <p>The <code>○</code> next to <code>LEARNINGS.md</code> means it's still empty; it will fill in as you capture lessons during development.</p>","path":["Home","Your First Session"],"tags":[]},{"location":"first-session/#step-4-start-an-ai-session","level":2,"title":"Step 4: Start an AI Session","text":"<p>With Claude Code (and the ctx plugin), context loads automatically — just start a session and it's there. For other tools, generate a context packet:</p> <pre><code>ctx agent --budget 8000\n</code></pre> <pre><code># Context Packet\nGenerated: 2026-02-14T15:30:45Z | Budget: 8000 tokens | Used: 1247\n\n## Read These Files (in order)\n1. .context/CONSTITUTION.md\n2. .context/TASKS.md\n3. .context/DECISIONS.md\n...\n\n## Current Tasks\n- [ ] Implement user authentication\n\n## Recent Decisions\n- Use PostgreSQL for the primary database\n...\n</code></pre> <p>Paste this output into your AI tool's system prompt or conversation start.</p>","path":["Home","Your First Session"],"tags":[]},{"location":"first-session/#step-5-verify-it-works","level":2,"title":"Step 5: Verify It Works","text":"<p>Ask your AI: \"What are our current tasks?\"</p> <p>A working setup produces a response like:</p> <pre><code>Based on the project context, you have one active task:\n\n- **Implement user authentication** (pending)\n\nThere's also a recent architectural decision to **use PostgreSQL for\nthe primary database**, chosen for its ACID compliance and JSON support.\n\nWant me to start on the authentication task?\n</code></pre> <p>That's the success moment:</p> <p>The AI is citing your exact context entries from Step 2, not hallucinating or asking you to re-explain.</p>","path":["Home","Your First Session"],"tags":[]},{"location":"first-session/#what-gets-created","level":2,"title":"What Gets Created","text":"<pre><code>.context/\n├── CONSTITUTION.md     # Hard rules — NEVER violate these\n├── TASKS.md            # Current and planned work\n├── CONVENTIONS.md      # Project patterns and standards\n├── ARCHITECTURE.md     # System overview\n├── DECISIONS.md        # Architectural decisions with rationale\n├── LEARNINGS.md        # Lessons learned, gotchas, tips\n├── GLOSSARY.md         # Domain terms and abbreviations\n└── AGENT_PLAYBOOK.md   # How AI tools should use this\n</code></pre> <p>Claude Code integration (hooks + skills) is provided by the ctx plugin — see Integrations.</p> <p>See Context Files for detailed documentation of each file.</p>","path":["Home","Your First Session"],"tags":[]},{"location":"first-session/#what-to-gitignore","level":2,"title":"What to <code>.gitignore</code>","text":"<p>Commit your <code>.context/</code> knowledge files: that's the whole point.</p> <p><code>.gitignore</code> generated and sensitive paths:</p> <pre><code># Journal data (large, potentially sensitive)\n.context/journal/\n.context/journal-site/\n.context/journal-obsidian/\n\n# Hook logs (machine-specific)\n.context/logs/\n\n# Encryption key (NEVER commit)\n.context/.scratchpad.key\n\n# Claude Code local settings (machine-specific)\n.claude/settings.local.json\n</code></pre> <p><code>ctx init</code> automatically adds these entries to your <code>.gitignore</code>. Review the additions with <code>cat .gitignore</code> after init.</p> <p>Rule of Thumb</p> <ul> <li>If it's knowledge (decisions, tasks, learnings,   conventions), commit it.</li> <li>If it's generated output, raw session data, or a secret, <code>.gitignore</code> it.</li> </ul> <p>See also:</p> <ul> <li>Security considerations,</li> <li>Scratchpad encryption,</li> <li>Session Journal</li> </ul> <p>Next Up: Common Workflows → — day-to-day commands for tracking context, checking health, and browsing history.</p>","path":["Home","Your First Session"],"tags":[]},{"location":"getting-started/","level":1,"title":"Getting Started","text":"","path":["Home","Getting Started"],"tags":[]},{"location":"getting-started/#prerequisites","level":2,"title":"Prerequisites","text":"<p><code>ctx</code> does not require git, but using version control with your <code>.context/</code> directory is strongly recommended.</p> <p>AI sessions occasionally modify or overwrite context files inadvertently.</p> <p>With <code>git</code>, the AI can check history and restore lost content: Without it, the data is gone.</p> <p>Also, several <code>ctx</code> features (journal changelog, blog generation) also use <code>git</code> history directly.</p>","path":["Home","Getting Started"],"tags":[]},{"location":"getting-started/#installation","level":2,"title":"Installation","text":"<p>A full ctx installation has two parts:</p> <ol> <li>The <code>ctx</code> binary — the CLI tool itself</li> <li>The Claude Code plugin — hooks and skills that make Claude Code    context-aware</li> </ol> <p>You need both. The binary alone gives you the CLI but Claude Code won't autoload context, nudge you to persist decisions, or provide the <code>/ctx-*</code> skills.</p> <p>Pick one of the options below — each is a complete path from zero to a working setup.</p>","path":["Home","Getting Started"],"tags":[]},{"location":"getting-started/#option-1-build-from-source-recommended","level":3,"title":"Option 1: Build from Source (Recommended)","text":"<p>Requires Go 1.25+ and Claude Code.</p> <pre><code>git clone https://github.com/ActiveMemory/ctx.git\ncd ctx\nmake build\nsudo make install\n</code></pre> <p>Install the Claude Code plugin from your local clone:</p> <ol> <li>Launch <code>claude</code></li> <li>Type <code>/plugin</code> and press Enter</li> <li>Select Marketplaces → Add Marketplace</li> <li>Enter the path to the root of your clone,    e.g. <code>~/WORKSPACE/ctx</code>    (this is where <code>.claude-plugin/marketplace.json</code> lives — it points    Claude Code to the actual plugin in <code>internal/assets/claude</code>)</li> <li>Back in <code>/plugin</code>, select Install and choose <code>ctx</code></li> </ol> <p>This points Claude Code at the plugin source on disk. Changes you make to hooks or skills take effect immediately — no reinstall needed.</p> <p>Verify:</p> <pre><code>ctx --version       # binary is in PATH\nclaude /plugin list # plugin is installed\n</code></pre> <p>Building from source gives you the latest features and bug fixes. Since <code>ctx</code> is predominantly a developer tool, this is the recommended approach: you get the freshest code, can inspect what you are installing, and the plugin stays in sync with the binary.</p>","path":["Home","Getting Started"],"tags":[]},{"location":"getting-started/#option-2-binary-download-marketplace","level":3,"title":"Option 2: Binary Download + Marketplace","text":"<p>Pre-built binaries are available from the releases page.</p> Linux (x86_64)Linux (ARM64)macOS (Apple Silicon)macOS (Intel)Windows <pre><code>curl -LO https://github.com/ActiveMemory/ctx/releases/download/v0.6.0/ctx-0.6.0-linux-amd64\nchmod +x ctx-0.6.0-linux-amd64\nsudo mv ctx-0.6.0-linux-amd64 /usr/local/bin/ctx\n</code></pre> <pre><code>curl -LO https://github.com/ActiveMemory/ctx/releases/download/v0.6.0/ctx-0.6.0-linux-arm64\nchmod +x ctx-0.6.0-linux-arm64\nsudo mv ctx-0.6.0-linux-arm64 /usr/local/bin/ctx\n</code></pre> <pre><code>curl -LO https://github.com/ActiveMemory/ctx/releases/download/v0.6.0/ctx-0.6.0-darwin-arm64\nchmod +x ctx-0.6.0-darwin-arm64\nsudo mv ctx-0.6.0-darwin-arm64 /usr/local/bin/ctx\n</code></pre> <pre><code>curl -LO https://github.com/ActiveMemory/ctx/releases/download/v0.6.0/ctx-0.6.0-darwin-amd64\nchmod +x ctx-0.6.0-darwin-amd64\nsudo mv ctx-0.6.0-darwin-amd64 /usr/local/bin/ctx\n</code></pre> <p>Download <code>ctx-0.6.0-windows-amd64.exe</code> from the releases page and add it to your <code>PATH</code>.</p> <p>Install the Claude Code plugin from the marketplace:</p> <ol> <li>Launch <code>claude</code></li> <li>Type <code>/plugin</code> and press Enter</li> <li>Select Marketplaces → Add Marketplace</li> <li>Enter <code>ActiveMemory/ctx</code></li> <li>Back in <code>/plugin</code>, select Install and choose <code>ctx</code></li> </ol> <p>Verify:</p> <pre><code>ctx --version       # binary is in PATH\nclaude /plugin list # plugin is installed\n</code></pre>","path":["Home","Getting Started"],"tags":[]},{"location":"getting-started/#verifying-checksums","level":4,"title":"Verifying Checksums","text":"<p>Each binary has a corresponding <code>.sha256</code> checksum file. To verify your download:</p> <pre><code># Download the checksum file\ncurl -LO https://github.com/ActiveMemory/ctx/releases/download/v0.6.0/ctx-0.6.0-linux-amd64.sha256\n\n# Verify the binary\nsha256sum -c ctx-0.6.0-linux-amd64.sha256\n</code></pre> <p>On macOS, use <code>shasum -a 256 -c</code> instead of <code>sha256sum -c</code>.</p> What the Plugin Provides <p>After installation (either option) you get:</p> <ul> <li>Context autoloading — <code>ctx agent</code> runs on every tool use (with cooldown)</li> <li>Persistence nudges — reminders to capture learnings and decisions</li> <li>Post-commit hooks — nudge context capture after <code>git commit</code></li> <li>Context size monitoring — alerts as sessions grow large</li> <li>25+ skills — <code>/ctx-status</code>, <code>/ctx-add-task</code>, <code>/ctx-recall</code>, and more</li> </ul> <p>See Integrations for the full hook and skill reference.</p>","path":["Home","Getting Started"],"tags":[]},{"location":"getting-started/#quick-start","level":2,"title":"Quick Start","text":"","path":["Home","Getting Started"],"tags":[]},{"location":"getting-started/#1-initialize-context","level":3,"title":"1. Initialize Context","text":"<pre><code>cd your-project\nctx init\n</code></pre> <p>This creates a <code>.context/</code> directory with template files and a <code>.scratchpad.key</code> for the encrypted scratchpad. For Claude Code, install the ctx plugin for automatic hooks and skills.</p>","path":["Home","Getting Started"],"tags":[]},{"location":"getting-started/#2-check-status","level":3,"title":"2. Check Status","text":"<pre><code>ctx status\n</code></pre> <p>Shows context summary: files present, token estimate, and recent activity.</p>","path":["Home","Getting Started"],"tags":[]},{"location":"getting-started/#3-start-using-with-ai","level":3,"title":"3. Start Using with AI","text":"<p>With Claude Code (and the ctx plugin installed), context loads automatically via hooks. For other tools, paste the output of:</p> <pre><code>ctx agent --budget 8000\n</code></pre>","path":["Home","Getting Started"],"tags":[]},{"location":"getting-started/#4-verify-it-works","level":3,"title":"4. Verify It Works","text":"<p>Ask your AI: \"Do you remember?\"</p> <p>It should cite specific context: current tasks, recent decisions, or previous session topics.</p> <p>Next Up:</p> <ul> <li>Your First Session → — a step-by-step walkthrough from <code>ctx init</code> to verified recall</li> <li>Common Workflows → — day-to-day commands for tracking context, checking health, and browsing history</li> </ul>","path":["Home","Getting Started"],"tags":[]},{"location":"integrations/","level":1,"title":"AI Tool Integrations","text":"","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#ai-tool-integrations","level":2,"title":"AI Tool Integrations","text":"<p>Context works with any AI tool that can read files. This guide covers setup  for popular AI coding assistants.</p>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#claude-code-full-integration","level":2,"title":"Claude Code (Full Integration)","text":"<p>Claude Code has the deepest integration via the ctx plugin.</p>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#setup","level":3,"title":"Setup","text":"<ol> <li>Install ctx and initialize your project:</li> </ol> <pre><code>ctx init\n</code></pre> <ol> <li>Install the ctx plugin in Claude Code:</li> </ol> <pre><code># From the ctx repository\nclaude /plugin install ./internal/assets/claude\n\n# Or from the marketplace\nclaude /plugin marketplace add ActiveMemory/ctx\nclaude /plugin install ctx@activememory-ctx\n</code></pre> <p>This gives you:</p> Component Purpose <code>.context/</code> All context files <code>CLAUDE.md</code> Bootstrap instructions Plugin hooks Lifecycle automation Plugin skills Agent Skills","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#how-it-works","level":3,"title":"How It Works","text":"<pre><code>graph TD\n    A[Session Start] --&gt; B[Claude reads CLAUDE.md]\n    B --&gt; C[PreToolUse hook runs]\n    C --&gt; D[ctx agent loads context]\n    D --&gt; E[Work happens]\n    E --&gt; F[Session End]</code></pre> <ol> <li>Session start: Claude reads <code>CLAUDE.md</code>, which tells it to check <code>.context/</code></li> <li>First tool use: <code>PreToolUse</code> hook runs <code>ctx agent</code> and emits the context    packet (subsequent invocations within the cooldown window are silent)</li> <li>Next session: Claude reads context files and continues with context</li> </ol>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#plugin-hooks","level":3,"title":"Plugin Hooks","text":"<p>The ctx plugin provides lifecycle hooks implemented as Go subcommands (<code>ctx system *</code>):</p> Hook Event Purpose <code>ctx system block-non-path-ctx</code> PreToolUse (Bash) Block <code>./ctx</code> or <code>go run</code>: force <code>$PATH</code> install <code>ctx system check-context-size</code> UserPromptSubmit Nudge context assessment as sessions grow <code>ctx system check-journal</code> UserPromptSubmit Remind to export/enrich journal entries <code>ctx system check-persistence</code> UserPromptSubmit Remind to persist learnings/decisions <code>ctx system post-commit</code> PostToolUse (Bash) Nudge context capture and QA after git commits <code>ctx system cleanup-tmp</code> SessionEnd Remove stale temp files (older than 15 days) <p>A catch-all <code>PreToolUse</code> hook also runs <code>ctx agent</code> on every tool use (with cooldown) to autoload context.</p>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#hook-configuration","level":3,"title":"Hook Configuration","text":"<p>The plugin's <code>hooks.json</code> wires everything automatically — no manual configuration in <code>settings.local.json</code> needed:</p> <pre><code>{\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Bash\",\n        \"hooks\": [\n          { \"type\": \"command\", \"command\": \"ctx system block-non-path-ctx\" }\n        ]\n      },\n      {\n        \"matcher\": \".*\",\n        \"hooks\": [\n          { \"type\": \"command\", \"command\": \"ctx agent --budget 4000 2&gt;/dev/null || true\" }\n        ]\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Bash\",\n        \"hooks\": [\n          { \"type\": \"command\", \"command\": \"ctx system post-commit\" }\n        ]\n      }\n    ],\n    \"UserPromptSubmit\": [\n      {\n        \"hooks\": [\n          { \"type\": \"command\", \"command\": \"ctx system check-context-size\" },\n          { \"type\": \"command\", \"command\": \"ctx system check-persistence\" },\n          { \"type\": \"command\", \"command\": \"ctx system check-journal\" }\n        ]\n      }\n    ],\n    \"SessionEnd\": [\n      {\n        \"hooks\": [\n          { \"type\": \"command\", \"command\": \"ctx system cleanup-tmp\" }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#customizing-token-budget-and-cooldown","level":3,"title":"Customizing Token Budget and Cooldown","text":"<p>Edit the <code>PreToolUse</code> command to change the token budget or cooldown:</p> <pre><code>\"command\": \"ctx agent --budget 8000 --session $PPID 2&gt;/dev/null || true\"\n\"command\": \"ctx agent --budget 4000 --cooldown 5m --session $PPID 2&gt;/dev/null || true\"\n</code></pre> <p>The <code>--session $PPID</code> flag isolates the cooldown per session — <code>$PPID</code> resolves to the Claude Code process PID, so concurrent sessions don't interfere. The default cooldown is 10 minutes; use <code>--cooldown 0</code> to disable it.</p>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#verifying-setup","level":3,"title":"Verifying Setup","text":"<ol> <li>Start a new Claude Code session</li> <li>Ask: \"Do you remember?\"</li> <li>Claude should cite specific context:<ul> <li>Current tasks from <code>.context/TASKS.md</code>;</li> <li>Recent decisions or learnings;</li> <li>Recent session history from <code>ctx recall</code>.</li> </ul> </li> </ol>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#troubleshooting","level":3,"title":"Troubleshooting","text":"Issue Solution Context not loading Check <code>ctx</code> is in PATH: <code>which ctx</code> Hook errors Verify plugin is installed: <code>claude /plugin list</code>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#manual-context-load","level":3,"title":"Manual Context Load","text":"<p>If hooks aren't working, manually load context:</p> <pre><code># Get context packet\nctx agent --budget 4000\n\n# Or paste into conversation\ncat .context/TASKS.md\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#agent-skills","level":3,"title":"Agent Skills","text":"<p>The ctx plugin ships Agent Skills following the agentskills.io specification.</p> <p>These are invoked in Claude Code with <code>/skill-name</code>.</p>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#context-skills","level":4,"title":"Context Skills","text":"Skill Description <code>/ctx-status</code> Show context summary (tasks, decisions, learnings) <code>/ctx-agent</code> Get AI-optimized context packet <code>/ctx-drift</code> Detect and fix context drift (structural + semantic) <code>/ctx-alignment-audit</code> Audit doc claims against playbook instructions <code>/ctx-reflect</code> Review session and suggest what to persist","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#context-persistence-skills","level":4,"title":"Context Persistence Skills","text":"Command Description <code>/ctx-add-task</code> Add a task to TASKS.md <code>/ctx-add-learning</code> Add a learning to LEARNINGS.md <code>/ctx-add-decision</code> Add a decision with context/rationale/consequences <code>/ctx-add-convention</code> Add a coding convention to CONVENTIONS.md <code>/ctx-archive</code> Archive completed tasks","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#session-history-skills","level":4,"title":"Session History Skills","text":"Command Description <code>/ctx-recall</code> Browse AI session history <code>/ctx-journal-enrich</code> Enrich a journal entry with frontmatter/tags <code>/ctx-journal-enrich-all</code> Batch-enrich all unenriched journal entries","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#blogging-skills","level":4,"title":"Blogging Skills","text":"<p>Blogging is a Better Way of Creating Release Notes</p> <p>The blogging workflow can also double as generating release notes:</p> <p>AI reads your git commit history and creates a \"narrative\", which is essentially what a release note is for.</p> Command Description <code>/ctx-blog</code> Generate blog post from recent activity <code>/ctx-blog-changelog</code> Generate blog post from commit range with theme","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#development-skills","level":4,"title":"Development Skills","text":"Command Description <code>/ctx-loop</code> Generate a Ralph Loop iteration script <code>/ctx-prompt-audit</code> Analyze session logs for vague prompts","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#usage-examples","level":4,"title":"Usage Examples","text":"<pre><code>/ctx-status\n/ctx-add-learning \"Token refresh requires explicit cache invalidation\"\n/ctx-journal-enrich twinkly-stirring-kettle\n</code></pre> <p>Skills support partial matching where applicable (e.g., session slugs).</p>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#cursor-ide","level":2,"title":"Cursor IDE","text":"<p>Cursor can use context files through its system prompt or by reading  files directly.</p>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#setup_1","level":3,"title":"Setup","text":"<pre><code># Generate Cursor configuration\nctx hook cursor\n\n# Initialize context\nctx init --minimal\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#configuration","level":3,"title":"Configuration","text":"<p>Add to Cursor settings (<code>.cursor/settings.json</code>):</p> <pre><code>// split to multiple lines for readability\n{\n  \"ai.systemPrompt\": \"Read .context/TASKS.md and \n  .context/CONVENTIONS.md before responding. \n  Follow rules in .context/CONSTITUTION.md.\",\n}\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#usage","level":3,"title":"Usage","text":"<ol> <li>Open your project in Cursor</li> <li>Context files are available in the file tree</li> <li>Reference them in prompts:     \"Check .context/DECISIONS.md for our approach to...\"</li> </ol>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#manual-context-injection","level":3,"title":"Manual Context Injection","text":"<p>For more control, paste context directly:</p> <pre><code># Get AI-ready packet\nctx agent --budget 4000 | pbcopy  # macOS\nctx agent --budget 4000 | xclip  # Linux\n</code></pre> <p>Paste into Cursor's chat.</p>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#aider","level":2,"title":"Aider","text":"<p>Aider works well with context files through its <code>--read</code> flag.</p>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#setup_2","level":3,"title":"Setup","text":"<pre><code># Generate Aider configuration\nctx hook aider\n\n# Initialize context\nctx init\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#configuration_1","level":3,"title":"Configuration","text":"<p>Create <code>.aider.conf.yml</code>:</p> <pre><code>read:\n  - .context/CONSTITUTION.md\n  - .context/TASKS.md\n  - .context/CONVENTIONS.md\n  - .context/DECISIONS.md\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#usage_1","level":3,"title":"Usage","text":"<pre><code># Start Aider (reads context files automatically)\naider\n\n# Or specify files explicitly\naider --read .context/TASKS.md --read .context/CONVENTIONS.md\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#with-watch-mode","level":3,"title":"With Watch Mode","text":"<p>Run <code>ctx watch</code> alongside Aider to capture context updates:</p> <pre><code># Terminal 1: Run Aider\naider 2&gt;&amp;1 | tee /tmp/aider.log\n\n# Terminal 2: Watch for context updates\nctx watch --log /tmp/aider.log\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#github-copilot","level":2,"title":"GitHub Copilot","text":"<p>Copilot reads open files for context. Keep context files open or reference  them in comments.</p>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#setup_3","level":3,"title":"Setup","text":"<pre><code># Generate Copilot tips\nctx hook copilot\n\n# Initialize context\nctx init --minimal\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#usage-patterns","level":3,"title":"Usage Patterns","text":"<p>Pattern 1: Keep context files open</p> <p>Open <code>.context/CONVENTIONS.md</code> in a split pane. Copilot will reference it.</p> <p>Pattern 2: Reference in comments</p> <pre><code>// See .context/CONVENTIONS.md for naming patterns\n// Following decision in .context/DECISIONS.md: Use PostgreSQL\n\nfunction getUserById(id: string) {\n  // Copilot now has context\n}\n</code></pre> <p>Pattern 3: Paste context into Copilot Chat</p> <pre><code>ctx agent --budget 2000\n</code></pre> <p>Paste output into Copilot Chat for context-aware responses.</p>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#windsurf-ide","level":2,"title":"Windsurf IDE","text":"<p>Windsurf supports custom instructions and file-based context.</p>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#setup_4","level":3,"title":"Setup","text":"<pre><code># Generate Windsurf configuration\nctx hook windsurf\n\n# Initialize context\nctx init\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#configuration_2","level":3,"title":"Configuration","text":"<p>Add to Windsurf settings:</p> <pre><code>// Split to multiple lines for readability\n{\n  \"ai.customInstructions\": \"Always read .context/CONSTITUTION.md first. \n  Check .context/TASKS.md for current work. \n  Follow patterns in .context/CONVENTIONS.md.\"\n}\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#usage_2","level":3,"title":"Usage","text":"<p>Context files appear in the file tree. Reference them when chatting:</p> <ul> <li>\"What's in our task list?\" → AI reads <code>.context/TASKS.md</code></li> <li>\"What convention do we use for naming?\" → AI reads <code>.context/CONVENTIONS.md</code></li> </ul>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#generic-integration","level":2,"title":"Generic Integration","text":"<p>For any AI tool that can read files, use these patterns:</p>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#manual-context-loading","level":3,"title":"Manual Context Loading","text":"<pre><code># Get full context\nctx load\n\n# Get AI-optimized packet\nctx agent --budget 8000\n\n# Get specific file\ncat .context/TASKS.md\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#system-prompt-template","level":3,"title":"System Prompt Template","text":"<pre><code>You are working on a project with persistent context in .context/\n\nBefore responding:\n1. Read .context/CONSTITUTION.md - NEVER violate these rules\n2. Check .context/TASKS.md for current work\n3. Follow .context/CONVENTIONS.md patterns\n4. Reference .context/DECISIONS.md for architectural choices\n\nWhen you learn something new, note it for .context/LEARNINGS.md\nWhen you make a decision, document it for .context/DECISIONS.md\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#automated-updates","level":3,"title":"Automated Updates","text":"<p>If your AI tool outputs to a log, use <code>ctx watch</code>:</p> <pre><code># Watch log file for context-update commands\nyour-ai-tool 2&gt;&amp;1 | tee /tmp/ai.log &amp;\nctx watch --log /tmp/ai.log\n</code></pre> <p>The AI can emit updates like:</p> <pre><code>&lt;context-update type=\"complete\"&gt;implement caching&lt;/context-update&gt;\n&lt;context-update type=\"learning\"\n  context=\"Implementing caching layer\"\n  lesson=\"Important thing learned today\"\n  application=\"Apply this insight going forward\"\n&gt;Caching Insight&lt;/context-update&gt;\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#context-update-commands","level":2,"title":"Context Update Commands","text":"<p>The <code>ctx watch</code> command parses update commands from AI output. Use this format:</p> <pre><code>&lt;context-update type=\"TYPE\" [attributes]&gt;Content&lt;/context-update&gt;\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#supported-types","level":3,"title":"Supported Types","text":"Type Target File Required Attributes <code>task</code> TASKS.md None <code>decision</code> DECISIONS.md <code>context</code>, <code>rationale</code>, <code>consequences</code> <code>learning</code> LEARNINGS.md <code>context</code>, <code>lesson</code>, <code>application</code> <code>convention</code> CONVENTIONS.md None <code>complete</code> TASKS.md None","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#simple-format-tasks-conventions-complete","level":3,"title":"Simple Format (tasks, conventions, complete)","text":"<pre><code>&lt;context-update type=\"task\"&gt;Implement rate limiting&lt;/context-update&gt;\n&lt;context-update type=\"convention\"&gt;Use kebab-case for files&lt;/context-update&gt;\n&lt;context-update type=\"complete\"&gt;rate limiting&lt;/context-update&gt;\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#structured-format-learnings-decisions","level":3,"title":"Structured Format (learnings, decisions)","text":"<p>Learnings and decisions support structured attributes for better documentation:</p> <p>Learning with full structure:</p> <pre><code>&lt;context-update type=\"learning\"\n  context=\"Debugging Claude Code hooks\"\n  lesson=\"Hooks receive JSON via stdin, not environment variables\"\n  application=\"Parse JSON stdin with the host language (Go, Python, etc.) — no jq needed\"\n&gt;Hook Input Format&lt;/context-update&gt;\n</code></pre> <p>Decision with full structure:</p> <pre><code>&lt;context-update type=\"decision\"\n  context=\"Need a caching layer for API responses\"\n  rationale=\"Redis is fast, well-supported, and team has experience\"\n  consequences=\"Must provision Redis infrastructure; team training on Redis patterns\"\n&gt;Use Redis for caching&lt;/context-update&gt;\n</code></pre> <p>Learnings require: <code>context</code>, <code>lesson</code>, <code>application</code> attributes. Decisions require: <code>context</code>, <code>rationale</code>, <code>consequences</code> attributes. Updates missing required attributes are rejected with an error.</p>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#further-reading","level":2,"title":"Further Reading","text":"<ul> <li>Skills That Fight the Platform — Common pitfalls in skill design that work against the host tool</li> <li>The Anatomy of a Skill That Works — What makes a skill reliable: the E/A/R framework and quality gates</li> </ul>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"integrations/#usage-with-ctx-watch","level":3,"title":"Usage with ctx watch","text":"<pre><code># Pipe AI output through watch\nyour-ai-tool | ctx watch\n\n# Or watch a log file\nctx watch --log /tmp/ai-output.log\n\n# Preview without applying\nctx watch --dry-run\n</code></pre>","path":["Operations","AI Tool Integrations"],"tags":[]},{"location":"is-ctx-right/","level":1,"title":"Is ctx Right for Me?","text":"","path":["Home","Is ctx Right for Me?"],"tags":[]},{"location":"is-ctx-right/#good-fit","level":2,"title":"Good Fit","text":"<p><code>ctx</code> shines when context matters more than code. If any of these sound like your project, it's worth trying:</p> <ul> <li>Multi-session AI work — you use AI across many sessions on the same   codebase, and re-explaining is slowing you down</li> <li>Architectural decisions that matter — your project has non-obvious   choices (database, auth strategy, API design) that the AI keeps   second-guessing</li> <li>\"Why\" matters as much as \"what\" — you need the AI to understand   rationale, not just current code</li> <li>Team handoffs — multiple people (or multiple AI tools) work on the   same project and need shared context</li> <li>AI-assisted development across tools — you switch between Claude Code,   Cursor, Copilot, or other tools and want context to follow the project,   not the tool</li> <li>Long-lived projects — anything you'll work on for weeks or months,   where accumulated knowledge has compounding value</li> </ul>","path":["Home","Is ctx Right for Me?"],"tags":[]},{"location":"is-ctx-right/#not-the-right-fit","level":2,"title":"Not the Right Fit","text":"<p><code>ctx</code> adds overhead that isn't worth it for every project. Be honest about when to skip it:</p> <ul> <li>One-off scripts — if the project is a single file you'll finish today,   there's nothing to remember</li> <li>Pure RAG workflows — if your AI setup already retrieves context from a   knowledge base and that's sufficient, <code>ctx</code> solves a different problem</li> <li>No AI involvement — <code>ctx</code> is designed for human–AI workflows; without   an AI consumer, the files are just documentation</li> <li>Enterprise-managed context platforms — if your organization provides   centralized context services, <code>ctx</code> may duplicate that layer</li> </ul> <p>For a deeper technical comparison with RAG, prompt management tools, and agent frameworks, see ctx and Similar Tools.</p>","path":["Home","Is ctx Right for Me?"],"tags":[]},{"location":"is-ctx-right/#project-size-guide","level":2,"title":"Project Size Guide","text":"","path":["Home","Is ctx Right for Me?"],"tags":[]},{"location":"is-ctx-right/#solo-developer-single-repo","level":3,"title":"Solo developer, single repo","text":"<p>This is <code>ctx</code>'s sweet spot. You get the most value here: one person, one project, decisions and learnings accumulating over time. Setup takes 5 minutes and the <code>.context/</code> directory is small enough to never think about.</p>","path":["Home","Is ctx Right for Me?"],"tags":[]},{"location":"is-ctx-right/#small-team-one-or-two-repos","level":3,"title":"Small team, one or two repos","text":"<p>Works well. Context files commit to git, so the whole team shares the same decisions and conventions. Each person's AI sessions benefit from what others have recorded. Merge conflicts on <code>.context/</code> files are rare and easy to resolve (they're just markdown).</p>","path":["Home","Is ctx Right for Me?"],"tags":[]},{"location":"is-ctx-right/#multiple-repos-or-larger-teams","level":3,"title":"Multiple repos or larger teams","text":"<p><code>ctx</code> works per-repository. Each repo gets its own <code>.context/</code> directory with its own decisions, tasks, and learnings. There's no cross-repo context sharing built in — each project is self-contained. For organizations that need centralized knowledge, <code>ctx</code> can complement (but not replace) a platform-level solution.</p>","path":["Home","Is ctx Right for Me?"],"tags":[]},{"location":"is-ctx-right/#5-minute-trial","level":2,"title":"5-Minute Trial","text":"<p>Zero commitment. Try it, and delete <code>.context/</code> if it's not for you.</p> <pre><code># 1. Initialize\ncd your-project\nctx init\n\n# 2. Add one real decision from your project\nctx add decision \"Your actual architectural choice\" \\\n  --context \"What prompted this decision\" \\\n  --rationale \"Why you chose this approach\" \\\n  --consequences \"What changes as a result\"\n\n# 3. Check what the AI will see\nctx status\n\n# 4. Start an AI session and ask: \"Do you remember?\"\n</code></pre> <p>If the AI cites your decision back to you, it's working. If it doesn't add value for your workflow, clean up is one command:</p> <pre><code>rm -rf .context/\n</code></pre> <p>No dependencies to uninstall. No configuration to revert. Just files.</p> <p>Ready to try it?</p> <ul> <li>Getting Started → — full installation and setup</li> <li>ctx and Similar Tools → — detailed comparison with other approaches</li> </ul>","path":["Home","Is ctx Right for Me?"],"tags":[]},{"location":"migration/","level":1,"title":"Integrating ctx","text":"","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#adopting-ctx-in-existing-projects","level":2,"title":"Adopting ctx in Existing Projects","text":"<p>Claude Code User?</p> <p>You probably want the plugin instead of this page. Install ctx from the marketplace (<code>/plugin</code> → search \"ctx\" → Install) and you're done — hooks, skills, and updates are handled for you. See Getting Started for the full walkthrough.</p> <p>This guide covers adopting <code>ctx</code> in existing projects — regardless of which tools your team uses.</p>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#quick-paths","level":2,"title":"Quick Paths","text":"You have... Command What happens Nothing (greenfield) <code>ctx init</code> Creates <code>.context/</code>, <code>CLAUDE.md</code>, permissions Existing <code>CLAUDE.md</code> <code>ctx init --merge</code> Backs up your file, inserts ctx block after the H1 Existing <code>CLAUDE.md</code> + ctx markers <code>ctx init --force</code> Replaces the ctx block, leaves your content intact <code>.cursorrules</code> / <code>.aider.conf.yml</code> <code>ctx init</code> ctx ignores those files — they coexist cleanly Team repo, first adopter <code>ctx init --merge &amp;&amp; git add .context/ CLAUDE.md</code> Initialize and commit for the team","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#existing-claudemd","level":2,"title":"Existing <code>CLAUDE.md</code>","text":"<p>This is the most common scenario. You have a <code>CLAUDE.md</code> with project-specific instructions and don't want to lose them.</p>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#what-ctx-init-does","level":3,"title":"What <code>ctx init</code> Does","text":"<p>When <code>ctx init</code> detects an existing <code>CLAUDE.md</code>, it checks for ctx markers (<code>&lt;!-- ctx:context --&gt;</code> ... <code>&lt;!-- ctx:end --&gt;</code>):</p> State Default behavior With <code>--merge</code> With <code>--force</code> No <code>CLAUDE.md</code> Creates from template Creates from template Creates from template Exists, no ctx markers Prompts to merge Auto-merges (no prompt) Auto-merges (no prompt) Exists, has ctx markers Skips (already set up) Skips Replaces ctx block only","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#the-merge-flag","level":3,"title":"The <code>--merge</code> Flag","text":"<p><code>--merge</code> auto-merges without prompting. The merge process:</p> <ol> <li>Backs up your existing <code>CLAUDE.md</code> to <code>CLAUDE.md.&lt;timestamp&gt;.bak</code></li> <li>Finds the H1 heading (e.g., <code># My Project</code>) in your file</li> <li>Inserts the ctx block immediately after it</li> <li>Preserves everything else untouched</li> </ol> <p>Your content before and after the ctx block remains exactly as it was.</p>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#before-after-example","level":3,"title":"Before / After Example","text":"<p>Before: your existing <code>CLAUDE.md</code>:</p> <pre><code># My Project\n\n## Build Commands\n\n- `npm run build` — production build\n- `npm test` — run tests\n\n## Code Style\n\n- Use TypeScript strict mode\n- Prefer named exports\n</code></pre> <p>After <code>ctx init --merge</code>:</p> <pre><code># My Project\n\n&lt;!-- ctx:context --&gt;\n&lt;!-- DO NOT REMOVE: This marker indicates ctx-managed content --&gt;\n\n## IMPORTANT: You Have Persistent Memory\n\nThis project uses Context (`ctx`) for context persistence across sessions.\n...\n\n&lt;!-- ctx:end --&gt;\n\n## Build Commands\n\n- `npm run build` — production build\n- `npm test` — run tests\n\n## Code Style\n\n- Use TypeScript strict mode\n- Prefer named exports\n</code></pre> <p>Your build commands and code style sections are untouched. The ctx block sits between markers and can be updated independently.</p>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#the-force-flag","level":3,"title":"The <code>--force</code> Flag","text":"<p>If your <code>CLAUDE.md</code> already has ctx markers (from a previous <code>ctx init</code>), the default behavior is to skip it. Use <code>--force</code> to replace the ctx block with the latest template: This is useful after upgrading <code>ctx</code>:</p> <pre><code>ctx init --force\n</code></pre> <p>This only replaces content between <code>&lt;!-- ctx:context --&gt;</code> and <code>&lt;!-- ctx:end --&gt;</code>. Your own content outside the markers is preserved. A timestamped backup is created before any changes.</p>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#undoing-a-merge","level":3,"title":"Undoing a Merge","text":"<p>Every merge creates a backup:</p> <pre><code>$ ls CLAUDE.md*.bak\nCLAUDE.md.1738000000.bak\n</code></pre> <p>To restore:</p> <pre><code>cp CLAUDE.md.1738000000.bak CLAUDE.md\n</code></pre> <p>Or if you are using <code>git</code>, simply:</p> <pre><code>git checkout CLAUDE.md\n</code></pre>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#existing-cursorrules-aider-copilot","level":2,"title":"Existing .cursorrules / Aider / Copilot","text":"<p><code>ctx</code> doesn't touch tool-specific config files. It creates its own files (<code>.context/</code>, <code>CLAUDE.md</code>) and coexists with whatever you already have.</p>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#what-ctx-creates-vs-what-it-leaves-alone","level":3,"title":"What ctx Creates vs. What It Leaves Alone","text":"ctx creates ctx does NOT touch <code>.context/</code> directory <code>.cursorrules</code> <code>CLAUDE.md</code> (or merges into) <code>.aider.conf.yml</code> <code>.claude/settings.local.json</code> (seeded by <code>ctx init</code>; the plugin manages hooks and skills) <code>.github/copilot-instructions.md</code> <code>.windsurfrules</code> Any other tool-specific config <p>Claude Code hooks and skills are provided by the ctx plugin, installed from the Claude Code marketplace (<code>/plugin</code> → search \"ctx\" → Install).</p>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#running-ctx-alongside-other-tools","level":3,"title":"Running ctx Alongside Other Tools","text":"<p>The <code>.context/</code> directory is the source of truth. Tool-specific configs point to it:</p> <ul> <li>Cursor: Reference <code>.context/</code> files in your system prompt   (see Cursor setup)</li> <li>Aider: Add <code>.context/</code> files to the <code>read:</code> list in <code>.aider.conf.yml</code>   (see Aider setup)</li> <li>Copilot: Keep <code>.context/</code> files open or reference them in comments   (see Copilot setup)</li> </ul> <p>You can generate a tool-specific configuration with:</p> <pre><code>ctx hook cursor    # Generate Cursor config snippet\nctx hook aider     # Generate .aider.conf.yml\nctx hook copilot   # Generate Copilot tips\nctx hook windsurf  # Generate Windsurf config\n</code></pre>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#migrating-content-into-context","level":3,"title":"Migrating Content Into .context/","text":"<p>If you have project knowledge scattered across <code>.cursorrules</code> or custom prompt files, consider migrating it:</p> <ol> <li>Rules / invariants → <code>.context/CONSTITUTION.md</code></li> <li>Code patterns → <code>.context/CONVENTIONS.md</code></li> <li>Architecture notes → <code>.context/ARCHITECTURE.md</code></li> <li>Known issues / tips → <code>.context/LEARNINGS.md</code></li> </ol> <p>You don't need to delete the originals — ctx and tool-specific files can coexist. But centralizing in <code>.context/</code> means every tool gets the same context.</p>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#team-adoption","level":2,"title":"Team Adoption","text":"","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#context-is-designed-to-be-committed","level":3,"title":".context/ Is Designed to Be Committed","text":"<p>The <code>.context/</code> directory is meant to live in version control. It contains project knowledge — not secrets or personal preferences.</p> <pre><code># One person initializes\nctx init --merge\n\n# Commit everything\ngit add .context/ CLAUDE.md\ngit commit -m \"Add ctx context management\"\ngit push\n</code></pre> <p>Teammates pull and immediately have context. No per-developer setup needed.</p>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#what-about-claude","level":3,"title":"What About .claude/?","text":"<p>The <code>.claude/</code> directory contains permissions that <code>ctx init</code> seeds. Hooks and skills are provided by the ctx plugin (not per-project files).</p> File Commit? Why <code>.claude/settings.local.json</code> No Machine-specific, accumulates session permissions <code>.claude/settings.golden.json</code> Yes Curated permission snapshot (via <code>ctx permissions snapshot</code>)","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#merge-conflicts-in-context-files","level":3,"title":"Merge Conflicts in Context Files","text":"<p>Context files are plain Markdown. Resolve conflicts the same way you would for any other documentation file:</p> <pre><code># After a conflicting pull\ngit diff .context/TASKS.md    # See both sides\n# Edit to keep both sets of tasks, then:\ngit add .context/TASKS.md\ngit commit\n</code></pre> <p>Common conflict scenarios:</p> <ul> <li>TASKS.md: Two people added tasks: Keep both.</li> <li>DECISIONS.md: Same decision recorded differently: Unify the entry</li> <li>LEARNINGS.md: Parallel discoveries: Keep both, remove duplicates</li> </ul>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#gradual-adoption","level":3,"title":"Gradual Adoption","text":"<p>You don't need the whole team to switch at once:</p> <ol> <li>One person runs <code>ctx init --merge</code> and commits.</li> <li><code>CLAUDE.md</code> instructions work immediately for Claude Code users.</li> <li>Other tool users can adopt at their own pace using <code>ctx hook &lt;tool&gt;</code>.</li> <li>Context files benefit everyone who reads them, even without tool integration.</li> </ol>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#verifying-it-worked","level":2,"title":"Verifying It Worked","text":"","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#check-status","level":3,"title":"Check Status","text":"<pre><code>ctx status\n</code></pre> <p>You should see your context files listed with token counts and no warnings.</p>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#test-memory","level":3,"title":"Test Memory","text":"<p>Start a new AI session and ask: \"Do you remember?\"</p> <p>The AI should cite specific context:</p> <ul> <li>Current tasks from <code>.context/TASKS.md</code>;</li> <li>Recent decisions or learnings;</li> <li>Session history (if you've had prior sessions);</li> </ul> <p>If it responds with generic \"I don't have memory\", check that <code>ctx</code> is in your PATH (<code>which ctx</code>) and that hooks are configured (see Troubleshooting).</p>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#verify-the-merge","level":3,"title":"Verify the Merge","text":"<p>If you used <code>--merge</code>, check that your original content is intact:</p> <pre><code># Your original content should still be there\ncat CLAUDE.md\n\n# The ctx block should be between markers\ngrep -c \"ctx:context\" CLAUDE.md  # Should print 1\ngrep -c \"ctx:end\" CLAUDE.md      # Should print 1\n</code></pre>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"migration/#further-reading","level":2,"title":"Further Reading","text":"<ul> <li>Getting Started: Full setup walkthrough</li> <li>Context Files: What each <code>.context/</code> file does</li> <li>Integrations: Per-tool setup (Claude Code, Cursor, Aider, Copilot)</li> <li>CLI Reference: All <code>ctx</code> commands and flags</li> </ul>","path":["Operations","Integrating ctx"],"tags":[]},{"location":"prompting-guide/","level":1,"title":"Prompting Guide","text":"","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#prompting-guide","level":2,"title":"Prompting Guide","text":"<p>Effective prompts for working with AI assistants in <code>ctx</code>-enabled projects.</p> <p>Tip</p> <p>AI assistants may not automatically read context files.</p> <p>The right prompt triggers the right behavior. </p> <p>This guide documents prompts that reliably produce good results.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#session-start","level":2,"title":"Session Start","text":"","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#do-you-remember","level":3,"title":"\"Do you remember?\"","text":"<p>Triggers the AI to silently read <code>TASKS.md</code>, <code>DECISIONS.md</code>, <code>LEARNINGS.md</code>, and check recent history via <code>ctx recall</code> before responding with a structured readback:</p> <ol> <li>Last session: most recent session topic and date</li> <li>Active work: pending or in-progress tasks</li> <li>Recent context: 1-2 recent decisions or learnings</li> <li>Next step: offer to continue or ask what to focus on</li> </ol> <p>Use this at the start of every important session.</p> <pre><code>Do you remember what we were working on?\n</code></pre> <p>This question implies prior context exists. The AI checks files rather than admitting ignorance. The expected response cites specific context (session names, task counts, decisions), not vague summaries.</p> <p>If the AI instead narrates its discovery process (\"Let me check if there are files...\"), it has not loaded <code>CLAUDE.md</code> or <code>AGENT_PLAYBOOK.md</code> properly.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#whats-the-current-state","level":3,"title":"\"What's the current state?\"","text":"<p>Prompts reading of <code>TASKS.md</code>, recent sessions, and status overview.</p> <p>Use this when resuming work after a break.</p> <p>Variants:</p> <ul> <li>\"Where did we leave off?\"</li> <li>\"What's in progress?\"</li> <li>\"Show me the open tasks.\"</li> </ul>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#during-work","level":2,"title":"During Work","text":"","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#why-doesnt-x-work","level":3,"title":"\"Why doesn't X work?\"","text":"<p>This triggers root cause analysis rather than surface-level fixes.</p> <p>Use this when something fails unexpectedly.</p> <p>Framing as \"why\" encourages investigation before action. The AI will trace  through code, check configurations, and identify the actual cause.</p> <p>Real Example</p> <p>\"Why can't I run /ctx-reflect?\" led to discovering missing permissions in <code>settings.local.json</code> bootstrapping.</p> <p>This was a fix that benefited all users of <code>ctx</code>.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#is-this-consistent-with-our-decisions","level":3,"title":"\"Is this consistent with our decisions?\"","text":"<p>This prompts checking <code>DECISIONS.md</code> before implementing.</p> <p>Use this before making architectural choices.</p> <p>Variants:</p> <ul> <li>\"Check if we've decided on this before\"</li> <li>\"Does this align with our conventions?\"</li> </ul>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#what-would-break-if-we","level":3,"title":"\"What would break if we...\"","text":"<p>This triggers defensive thinking and impact analysis.</p> <p>Use this before making significant changes.</p> <pre><code>What would break if we change the Settings struct?\n</code></pre>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#before-you-start-read-x","level":3,"title":"\"Before you start, read X\"","text":"<p>This ensures specific context is loaded before work begins.</p> <p>Use this when you know the relevant context exists in a specific file.</p> <pre><code>Before you start, check ctx recall for the auth discussion session\n</code></pre>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#scope-control","level":3,"title":"Scope Control","text":"<p>Constrain the AI to prevent sprawl. These are some of the most useful prompts in day-to-day work.</p> <pre><code>Only change files in internal/cli/add/. Nothing else.\n</code></pre> <pre><code>No new files. Modify the existing implementation.\n</code></pre> <pre><code>Keep the public API unchanged. Internal refactor only.\n</code></pre> <p>Use these when the AI tends to \"helpfully\" modify adjacent code, add documentation you didn't ask for, or create new abstractions.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#course-correction","level":3,"title":"Course Correction","text":"<p>Steer the AI when it goes off-track. Don't wait for it to finish a wrong approach.</p> <pre><code>Stop. That's not what I meant. Let me clarify.\n</code></pre> <pre><code>Let's step back. Explain what you're about to do before changing anything.\n</code></pre> <pre><code>Undo that last change and try a different approach.\n</code></pre> <p>These work because they interrupt momentum. </p> <p>Without explicit course correction, the AI tends to commit harder to a wrong  path rather than reconsidering.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#reflection-and-persistence","level":2,"title":"Reflection and Persistence","text":"","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#what-did-we-learn","level":3,"title":"\"What did we learn?\"","text":"<p>This prompts reflection on the session and often triggers adding learnings to <code>LEARNINGS.md</code>.</p> <p>Use this after completing a task or debugging session.</p> <p>This is an explicit reflection prompt. The AI will summarize insights and often offer to persist them.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#add-this-as-a-learningdecision","level":3,"title":"\"Add this as a learning/decision\"","text":"<p>This is an explicit persistence request.</p> <p>Use this when you have discovered something worth remembering.</p> <pre><code>Add this as a learning: \"JSON marshal escapes angle brackets by default\"\n\n# or simply.\nAdd this as a learning.\n# and let the AI autonomously infer and summarize.\n</code></pre>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#save-context-before-we-end","level":3,"title":"\"Save context before we end\"","text":"<p>This triggers context persistence before the session closes.</p> <p>Use it at the end of the session or before switching topics.</p> <p>Variants:</p> <ul> <li>\"Let's persist what we did\"</li> <li>\"Update the context files\"</li> <li><code>/ctx-reflect</code> (Agent Skill in Claude Code)</li> </ul>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#exploration-and-research","level":2,"title":"Exploration and Research","text":"","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#explore-the-codebase-for-x","level":3,"title":"\"Explore the codebase for X\"","text":"<p>This triggers thorough codebase search rather than guessing.</p> <p>Use this when you need to understand how something works.</p> <p>This works because \"Explore\" signals that investigation is needed,  not immediate action.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#how-does-x-work-in-this-codebase","level":3,"title":"\"How does X work in this codebase?\"","text":"<p>This prompts reading actual code rather than explaining general concepts.</p> <p>Use this to understand the existing implementation.</p> <pre><code>How does session saving work in this codebase?\n</code></pre>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#find-all-places-where-x","level":3,"title":"\"Find all places where X\"","text":"<p>This triggers a comprehensive search across the codebase.</p> <p>Use this before refactoring or understanding the impact.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#meta-and-process","level":2,"title":"Meta and Process","text":"","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#what-should-we-document-from-this","level":3,"title":"\"What should we document from this?\"","text":"<p>This prompts identifying learnings, decisions, and conventions worth persisting.</p> <p>Use this after complex discussions or implementations.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#is-this-the-right-approach","level":3,"title":"\"Is this the right approach?\"","text":"<p>This invites the AI to challenge the current direction.</p> <p>Use this when you want a sanity check.</p> <p>This works because it allows AI to disagree. </p> <p>AIs often default to agreeing; this prompt signals you want an  honest assessment.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#what-am-i-missing","level":3,"title":"\"What am I missing?\"","text":"<p>This prompts thinking about edge cases, overlooked requirements, or unconsidered approaches.</p> <p>Use this before finalizing a design or implementation.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#cli-commands-as-prompts","level":2,"title":"CLI Commands as Prompts","text":"<p>Asking the AI to run <code>ctx</code> commands is itself a prompt. These load context or trigger specific behaviors:</p> Command What it does \"Run <code>ctx status</code>\" Shows context summary, file presence, staleness \"Run <code>ctx agent</code>\" Loads token-budgeted context packet \"Run <code>ctx drift</code>\" Detects dead paths, stale files, missing context","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#agent-skills-claude-code","level":3,"title":"Agent Skills (Claude Code)","text":"<p>Skills are formalized prompts. Use them by name:</p> Skill When to use <code>/ctx-status</code> Quick context summary <code>/ctx-agent</code> Load full context packet <code>/ctx-remember</code> Recall project context and structured readback <code>/ctx-recall</code> Browse session history for past discussions <code>/ctx-reflect</code> Structured reflection checkpoint <code>/ctx-next</code> Suggest what to work on next <code>/ctx-commit</code> Commit with context persistence <code>/ctx-drift</code> Detect and fix context drift <code>/ctx-implement</code> Execute a plan step-by-step with verification <code>/ctx-loop</code> Generate autonomous loop script <code>/ctx-pad</code> Manage encrypted scratchpad <code>/ctx-archive</code> Archive completed tasks <code>/check-links</code> Audit docs for dead links <p>Skills combine a prompt, tool permissions, and domain knowledge into a single invocation. </p> <p>See Integrations for setup details.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#anti-patterns","level":2,"title":"Anti-Patterns","text":"<p>Based on our <code>ctx</code> development experience (i.e., \"sipping our own champagne\") so far, here are some prompts that tend to produce poor results:</p> Prompt Problem Better Alternative \"Fix this\" Too vague, may patch symptoms \"Why is this failing?\" \"Make it work\" Encourages quick hacks \"What's the right way to solve this?\" \"Just do it\" Skips planning \"Plan this, then implement\" \"You should remember\" Confrontational \"Do you remember?\" \"Obviously...\" Discourages questions State the requirement directly \"Idiomatic X\" Triggers language priors \"Follow project conventions\" \"Implement everything\" No phasing, sprawl risk Break into tasks, implement one at a time \"You should know this\" Assumes context is loaded \"Before you start, read X\"","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#quick-reference","level":2,"title":"Quick Reference","text":"Goal Prompt Load context \"Do you remember?\" Resume work \"What's the current state?\" What's next <code>/ctx-next</code> Debug \"Why doesn't X work?\" Validate \"Is this consistent with our decisions?\" Impact analysis \"What would break if we...\" Reflect <code>/ctx-reflect</code> Persist \"Add this as a learning\" Explore \"How does X work in this codebase?\" Sanity check \"Is this the right approach?\" Completeness \"*What am I missing?\" Constrain scope \"Only change files in X. Nothing else.\" Course correct \"Stop. That's not what I meant.\" Check health \"Run <code>ctx drift</code>\" Commit <code>/ctx-commit</code>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#explore-plan-implement","level":2,"title":"Explore → Plan → Implement","text":"<p>For non-trivial work, name the phase you want:</p> <pre><code>Explore src/auth and summarize the current flow.\nThen propose a plan. After I approve, implement with tests.\n</code></pre> <p>This prevents the AI from jumping straight to code. The three phases map to different modes of thinking:</p> <ul> <li>Explore: read, search, understand: no changes</li> <li>Plan: propose approach, trade-offs, scope: no changes</li> <li>Implement: write code, run tests, verify: changes</li> </ul> <p>Small fixes skip straight to implement. Complex or uncertain work benefits from all three.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#prompts-by-task-type","level":2,"title":"Prompts by Task Type","text":"<p>Different tasks need different prompt structures. The pattern: symptom + location + verification.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#bugfix","level":3,"title":"Bugfix","text":"<pre><code>Users report search returns empty results for queries with hyphens.\nReproduce in src/search/. Write a failing test for \"foo-bar\",\nfix the root cause, run: go test ./internal/search/...\n</code></pre>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#refactor","level":3,"title":"Refactor","text":"<pre><code>Inspect src/auth/ and list duplication hotspots.\nPropose a refactor plan scoped to one module.\nAfter approval, remove duplication without changing behavior.\nAdd a test if coverage is missing. Run: make audit\n</code></pre>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#research","level":3,"title":"Research","text":"<pre><code>Explore the request flow around src/api/.\nSummarize likely bottlenecks with evidence.\nPropose 2-3 hypotheses. Do not implement yet.\n</code></pre>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#docs","level":3,"title":"Docs","text":"<pre><code>Update docs/cli-reference.md to reflect the new --format flag.\nConfirm the flag exists in the code and the example works.\n</code></pre> <p>Notice each prompt includes what to verify and how. Without that, you get a \"should work now\" instead of evidence.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#writing-tasks-as-prompts","level":2,"title":"Writing Tasks as Prompts","text":"<p>Tasks in <code>TASKS.md</code> are indirect prompts to the AI. How you write them shapes how the AI approaches the work.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#state-the-deliverable-not-just-steps","level":3,"title":"State the Deliverable, Not Just Steps","text":"<p>Bad task (implementation-focused): <pre><code>- [ ] T1.1.0: Parser system\n  - [ ] Define data structures\n  - [ ] Implement line parser\n  - [ ] Implement session grouper\n</code></pre></p> <p>The AI may complete all subtasks but miss the actual goal. What does \"Parser system\" deliver to the user?</p> <p>Good task (deliverable-focused): <pre><code>- [ ] T1.1.0: Parser CLI command\n  **Deliverable**: `ctx recall list` command that shows parsed sessions\n  - [ ] Define data structures\n  - [ ] Implement line parser\n  - [ ] Implement session grouper\n</code></pre></p> <p>Now the AI knows the subtasks serve a specific user-facing deliverable.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#use-acceptance-criteria","level":3,"title":"Use Acceptance Criteria","text":"<p>For complex tasks, add explicit \"done when\" criteria:</p> <pre><code>- [ ] T2.0: Authentication system\n  **Done when**:\n  - [ ] User can register with email\n  - [ ] User can log in and get a token\n  - [ ] Protected routes reject unauthenticated requests\n</code></pre> <p>This prevents premature \"task complete\" when only the implementation details are done, but the feature doesn't actually work.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#subtasks-parent-task","level":3,"title":"Subtasks ≠ Parent Task","text":"<p>Completing all subtasks does not mean the parent task is complete.</p> <p>The parent task describes what the user gets.</p> <p>Subtasks describe how to build it.</p> <p>Always re-read the parent task description before marking it complete. Verify the stated deliverable exists and works.</p>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#further-reading","level":2,"title":"Further Reading","text":"<ul> <li>The Attention Budget:    Why your AI forgets what you just told it, and how token budgets shape    context strategy</li> </ul>","path":["Home","Prompting Guide"],"tags":[]},{"location":"prompting-guide/#contributing","level":2,"title":"Contributing","text":"<p>Found a prompt that works well? Open an issue or PR with:</p> <ol> <li>The prompt text</li> <li>What behavior it triggers</li> <li>When to use it</li> <li>Why it works (optional but helpful)</li> </ol> <p>Go Deeper:</p> <ul> <li>Recipes — targeted how-to guides for specific tasks</li> <li>CLI Reference — all commands and flags</li> <li>Integrations — setup for Claude Code, Cursor, Aider</li> </ul>","path":["Home","Prompting Guide"],"tags":[]},{"location":"scratchpad/","level":1,"title":"Scratchpad","text":"","path":["Reference","Scratchpad"],"tags":[]},{"location":"scratchpad/#what-it-is","level":2,"title":"What It Is","text":"<p>A one-liner scratchpad, encrypted at rest, synced via git.</p> <p>Quick notes that don't fit decisions, learnings, or tasks: reminders, intermediate values, sensitive tokens, working memory during debugging. Entries are numbered, reorderable, and persist across sessions.</p>","path":["Reference","Scratchpad"],"tags":[]},{"location":"scratchpad/#encrypted-by-default","level":2,"title":"Encrypted by Default","text":"<p>Scratchpad entries are encrypted with <code>AES-256-GCM</code> before touching the disk.</p> Component Path Git status Encryption key <code>.context/.scratchpad.key</code> Gitignored, <code>0600</code> permissions Encrypted data <code>.context/scratchpad.enc</code> Committed <p>The key is generated automatically during <code>ctx init</code> (256-bit via <code>crypto/rand</code>). The ciphertext format is <code>[12-byte nonce][ciphertext+tag]</code>. No external dependencies: Go stdlib only.</p> <p>Because the key is <code>.gitignore</code>d and the data is committed, you get:</p> <ul> <li>At-rest encryption: the <code>.enc</code> file is opaque without the key</li> <li>Git sync: push/pull the encrypted file like any other tracked file</li> <li>Key separation: the key never leaves the machine unless you copy it</li> </ul>","path":["Reference","Scratchpad"],"tags":[]},{"location":"scratchpad/#commands","level":2,"title":"Commands","text":"Command Purpose <code>ctx pad</code> List all entries (numbered 1-based) <code>ctx pad show N</code> Output raw text of entry N (no prefix, pipe-friendly) <code>ctx pad add \"text\"</code> Append a new entry <code>ctx pad rm N</code> Remove entry at position N <code>ctx pad edit N \"text\"</code> Replace entry N with new text <code>ctx pad edit N --append \"text\"</code> Append text to the end of entry N <code>ctx pad edit N --prepend \"text\"</code> Prepend text to the beginning of entry N <code>ctx pad add TEXT --file PATH</code> Ingest a file as a blob entry (TEXT is the label) <code>ctx pad show N --out PATH</code> Write decoded blob content to a file <code>ctx pad mv N M</code> Move entry from position N to position M <code>ctx pad resolve</code> Show both sides of a merge conflict for resolution <p>All commands decrypt on read, operate on plaintext in memory, and re-encrypt on write. The key file is never printed to stdout.</p>","path":["Reference","Scratchpad"],"tags":[]},{"location":"scratchpad/#examples","level":3,"title":"Examples","text":"<pre><code># Add a note\nctx pad add \"check DNS propagation after deploy\"\n\n# List everything\nctx pad\n#   1. check DNS propagation after deploy\n#   2. staging API key: sk-test-abc123\n\n# Show raw text (for piping)\nctx pad show 2\n# sk-test-abc123\n\n# Compose entries\nctx pad edit 1 --append \"$(ctx pad show 2)\"\n\n# Reorder\nctx pad mv 2 1\n\n# Clean up\nctx pad rm 2\n</code></pre>","path":["Reference","Scratchpad"],"tags":[]},{"location":"scratchpad/#file-blobs","level":2,"title":"File Blobs","text":"<p>The scratchpad can store small files (up to 64 KB) as blob entries. Files are base64-encoded and stored with a human-readable label.</p> <pre><code># Ingest a file — first argument is the label\nctx pad add \"deploy config\" --file ./deploy.yaml\n\n# Listing shows label with a [BLOB] marker\nctx pad\n#   1. check DNS propagation after deploy\n#   2. deploy config [BLOB]\n\n# Extract to a file\nctx pad show 2 --out ./recovered.yaml\n\n# Or print decoded content to stdout\nctx pad show 2\n</code></pre> <p>Blob entries are encrypted identically to text entries. The internal format is <code>label:::base64data</code> — you never need to construct this manually.</p> Constraint Value Max file size (pre-encoding) 64 KB Storage format <code>label:::base64(content)</code> Display <code>label [BLOB]</code> in listings <p>When to Use Blobs</p> <p>Blobs are for small files you want encrypted and portable: config snippets, key fragments, deployment manifests, test fixtures. For anything larger than 64 KB, use the filesystem directly.</p>","path":["Reference","Scratchpad"],"tags":[]},{"location":"scratchpad/#using-with-ai","level":2,"title":"Using with AI","text":"<p>Use Natural Language</p> <p>As in many <code>ctx</code> features, the <code>ctx</code> scratchpad can also be used with natural langauge. You don't have to memorize the CLI commands.</p> <p>CLI gives you \"precision\", whereas natural language gives you flow.</p> <p>The <code>/ctx-pad</code> skill maps natural language to <code>ctx pad</code> commands. You don't need to remember the syntax:</p> You say What happens \"jot down: check DNS after deploy\" <code>ctx pad add \"check DNS after deploy\"</code> \"show my scratchpad\" <code>ctx pad</code> \"delete the third entry\" <code>ctx pad rm 3</code> \"update entry 2 to include the new endpoint\" <code>ctx pad edit 2 \"...\"</code> \"move entry 4 to the top\" <code>ctx pad mv 4 1</code> <p>The skill handles the translation. You describe what you want in plain English; the agent picks the right command.</p>","path":["Reference","Scratchpad"],"tags":[]},{"location":"scratchpad/#key-distribution","level":2,"title":"Key Distribution","text":"<p>The encryption key (<code>.context/.scratchpad.key</code>) stays on the machine where it was generated. <code>ctx</code> never transmits it.</p> <p>To share the scratchpad across machines:</p> <ol> <li>Copy the key manually: <code>scp</code>, USB drive, password manager.</li> <li>Push/pull the <code>.enc</code> file via git as usual.</li> <li>Both machines can now read and write the same scratchpad.</li> </ol> <p>Never Commit the Key</p> <p>The key is <code>.gitignore</code>d by default. If you override this, anyone with repo access can decrypt your scratchpad. </p> <p>Treat the key like an SSH private key.</p> <p>See the Syncing Scratchpad Notes Across Machines recipe for a step-by-step walkthrough.</p>","path":["Reference","Scratchpad"],"tags":[]},{"location":"scratchpad/#plaintext-override","level":2,"title":"Plaintext Override","text":"<p>For projects where encryption is unnecessary, disable it in <code>.contextrc</code>:</p> <pre><code>scratchpad_encrypt: false\n</code></pre> <p>In plaintext mode:</p> <ul> <li>Entries are stored in <code>.context/scratchpad.md</code> instead of <code>.enc</code>.</li> <li>No key is generated or required.</li> <li>All <code>ctx pad</code> commands work identically.</li> <li>The file is human-readable and diffable.</li> </ul> <p>When Should You Use Plaintext</p> <p>Plaintext mode is useful for non-sensitive projects, solo work where encryption adds friction, or when you want scratchpad entries visible in <code>git diff</code>.</p>","path":["Reference","Scratchpad"],"tags":[]},{"location":"scratchpad/#when-should-you-use-scratchpad-versus-context-files","level":2,"title":"When Should You Use Scratchpad versus Context Files","text":"Use case Where it goes Temporary reminders (\"check X after deploy\") Scratchpad Working values during debugging Scratchpad Sensitive tokens or API keys (short-term) Scratchpad Quick notes that don't fit anywhere else Scratchpad Items that are not directly relevant to the project Scratchpad Things that you want to keep near, but also hidden Scratchpad Work items with completion tracking <code>TASKS.md</code> Trade-offs with rationale <code>DECISIONS.md</code> Reusable lessons with context/lesson/application <code>LEARNINGS.md</code> Codified patterns and standards <code>CONVENTIONS.md</code> <p>Rule of thumb: </p> <ul> <li>If it needs structure or will be referenced months later, use   a context file (i.e. <code>DECISIONS.md</code>, <code>LEARNINGS.md</code>, <code>TASKS.md</code>). </li> <li>If it is working memory for the current session or week, use    the scratchpad.</li> </ul>","path":["Reference","Scratchpad"],"tags":[]},{"location":"scratchpad/#see-also","level":2,"title":"See Also","text":"<ul> <li>Syncing Scratchpad Notes Across Machines:   Key distribution, push/pull workflow, merge conflict resolution</li> <li>Using the Scratchpad:   Natural language examples, blob workflow, when to use scratchpad vs context files</li> <li>Context Files: Format and conventions for all   <code>.context/</code> files</li> <li>Security: Trust model and permission hygiene</li> </ul>","path":["Reference","Scratchpad"],"tags":[]},{"location":"security/","level":1,"title":"Security","text":"","path":["Security"],"tags":[]},{"location":"security/#reporting-vulnerabilities","level":2,"title":"Reporting Vulnerabilities","text":"<p>At <code>ctx</code> we take security very seriously.</p> <p>If you discover a security vulnerability in <code>ctx</code>, please report it responsibly.</p> <p>Do NOT open a public issue for security vulnerabilities.</p>","path":["Security"],"tags":[]},{"location":"security/#email","level":3,"title":"Email","text":"<p>Send details to security@ctx.ist</p>","path":["Security"],"tags":[]},{"location":"security/#github-private-reporting","level":3,"title":"GitHub Private Reporting","text":"<ol> <li>Go to the Security tab</li> <li>Click \"Report a vulnerability\"</li> <li>Provide a detailed description</li> </ol>","path":["Security"],"tags":[]},{"location":"security/#what-to-include","level":3,"title":"What to Include","text":"<ul> <li>Description of the vulnerability</li> <li>Steps to reproduce</li> <li>Potential impact</li> <li>Suggested fix (if any)</li> </ul>","path":["Security"],"tags":[]},{"location":"security/#response-timeline","level":3,"title":"Response Timeline","text":"Stage Timeframe Acknowledgment Within 48 hours Initial assessment Within 7 days Resolution target Within 30 days (depending on severity)","path":["Security"],"tags":[]},{"location":"security/#trust-model","level":2,"title":"Trust Model","text":"<p><code>ctx</code> operates within a single trust boundary: the local filesystem.</p> <p>The person who authors <code>.context/</code> files is the same person who runs the agent that reads them. There is no remote input, no shared state, and no server component.</p> <p>This means:</p> <ul> <li><code>ctx</code> does not sanitize context files for prompt injection. This is a   deliberate design choice, not an oversight. The files are authored by the   developer who owns the machine: Sanitizing their own instructions back   to them would be counterproductive.</li> <li>If you place adversarial instructions in your own <code>.context/</code> files,   your agent will follow them. This is expected behavior. You control the   context; the agent trusts it.</li> </ul> <p>Shared Repositories</p> <p>In shared repositories, <code>.context/</code> files should be reviewed in code review (the same way you would review CI/CD config or Makefiles). A malicious contributor could add harmful instructions to <code>CONSTITUTION.md</code> or <code>TASKS.md</code>.</p>","path":["Security"],"tags":[]},{"location":"security/#security-design","level":2,"title":"Security Design","text":"<p><code>ctx</code> is designed with security in mind:</p> <ul> <li>No secrets in context: The constitution explicitly forbids storing   secrets, tokens, API keys, or credentials in <code>.context/</code> files</li> <li>Local only: <code>ctx</code> runs entirely locally with no external network calls</li> <li>No code execution: ctx reads and writes Markdown files only; it does   not execute arbitrary code</li> <li>Git-tracked: Core context files are meant to be committed, so they should   never contain sensitive data. Exception: <code>sessions/</code> and <code>journal/</code> contain   raw conversation data and should be gitignored</li> </ul>","path":["Security"],"tags":[]},{"location":"security/#permission-hygiene","level":2,"title":"Permission Hygiene","text":"<p>Claude Code's <code>.claude/settings.local.json</code> accumulates pre-approved permissions over time. Some permissions can bypass safety hooks:</p> <ul> <li><code>Bash(git push:*)</code> pre-approves pushes, skipping the confirmation   dialog where <code>block-git-push.sh</code> would intervene</li> <li>Broad permissions like <code>Bash(echo:*)</code> or <code>Bash(cat:*)</code> could be   composed into writes to sensitive files (<code>CLAUDE.md</code>,   <code>settings.local.json</code>)</li> </ul> <p>Periodically review your permissions for:</p> <ul> <li>Hook bypass: permissions that pre-approve commands safety hooks   are designed to intercept</li> <li>Destructive commands: <code>rm -rf</code>, <code>git reset --hard</code>, etc.</li> <li>Config injection vectors: permissions that allow modifying files   controlling agent behavior</li> </ul>","path":["Security"],"tags":[]},{"location":"security/#temp-file-cleanup","level":2,"title":"Temp File Cleanup","text":"<p>Hook state files accumulate in the user-specific temp directory (<code>$XDG_RUNTIME_DIR/ctx-&lt;uid&gt;/</code> or <code>/tmp/ctx-&lt;uid&gt;/</code>). A <code>SessionEnd</code> hook automatically removes files older than 15 days. For manual cleanup or cron scheduling, use:</p> <pre><code>.context/tools/cleanup-ctx-tmp.sh        # default: 15-day threshold\n.context/tools/cleanup-ctx-tmp.sh 7      # custom: 7-day threshold\n</code></pre>","path":["Security"],"tags":[]},{"location":"security/#best-practices","level":2,"title":"Best Practices","text":"<ol> <li>Review before committing: Always review <code>.context/</code> files before committing</li> <li>Use <code>.gitignore</code>: If you must store sensitive notes locally,    add them to <code>.gitignore</code></li> <li>Drift detection: Run <code>ctx drift</code> to check for potential issues</li> <li>Permission audit: Review <code>.claude/settings.local.json</code> after busy sessions</li> </ol>","path":["Security"],"tags":[]},{"location":"security/#attribution","level":2,"title":"Attribution","text":"<p>We appreciate responsible disclosure and will acknowledge security researchers who report valid vulnerabilities (unless they prefer to remain anonymous).</p>","path":["Security"],"tags":[]},{"location":"session-journal/","level":1,"title":"Session Journal","text":"<p>Important Security Note</p> <p>Session journals contain sensitive data such as file contents, commands, API keys, internal discussions,  error messages with stack traces, and more. </p> <p>The <code>.context/journal-site/</code> and <code>.context/journal-obsidian/</code> directories MUST be <code>.gitignore</code>d.</p> <ul> <li>DO NOT host your journal publicly.</li> <li>DO NOT commit your journal files to version control.</li> </ul>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#browse-your-session-history","level":2,"title":"Browse Your Session History","text":"<p><code>ctx</code>'s Session Journal turns your AI coding sessions into a browsable,  searchable, and editable archive.</p>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#quick-start","level":2,"title":"Quick Start","text":"<p>After using <code>ctx</code> for a couple of sessions, you can generate a  journal site with:</p> <pre><code># Export all sessions to markdown\nctx recall export --all\n\n# Generate and serve the journal site\nctx journal site --serve\n</code></pre> <p>Then open http://localhost:8000 to browse your sessions.</p>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#what-you-get","level":2,"title":"What You Get","text":"<p>The Session Journal gives you:</p> <ul> <li>Browsable history: Navigate through all your AI sessions by date</li> <li>Full conversations: See every message, tool use, and result</li> <li>Token usage: Track how many tokens each session consumed</li> <li>Search: Find sessions by content, project, or date</li> <li>Dark mode: Easy on the eyes for late-night archaeology</li> </ul> <p>Each session page includes the following sections:</p> Section Content Metadata Date, time, duration, model, project, git branch Summary Space for your notes (editable) Tool Usage Which tools were used and how often Conversation Full transcript with timestamps","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#the-workflow","level":2,"title":"The Workflow","text":"","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#1-export-sessions","level":3,"title":"1. Export Sessions","text":"<pre><code># Export all sessions from current project\nctx recall export --all\n\n# Export sessions from all projects\nctx recall export --all --all-projects\n\n# Export a specific session by ID\nctx recall export abc123\n\n# Re-export (updates conversation, preserves YAML frontmatter)\nctx recall export --all\n\n# Full overwrite (discards frontmatter enrichments)\nctx recall export --all --force\n</code></pre> <p>Exported sessions go to <code>.context/journal/</code> as editable Markdown files.</p>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#2-generate-the-site","level":3,"title":"2. Generate the Site","text":"<pre><code># Generate site structure\nctx journal site\n\n# Generate and build static HTML\nctx journal site --build\n\n# Generate and serve locally\nctx journal site --serve\n\n# Custom output directory\nctx journal site --output ~/my-journal\n</code></pre> <p>The site is generated in <code>.context/journal-site/</code> by default.</p>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#3-browse-and-search","level":3,"title":"3. Browse and Search","text":"<p>Open http://localhost:8000 after running <code>--serve</code>.</p> <ul> <li>Use the sidebar to navigate by date</li> <li>Use search (<code>/</code> key) to find specific content</li> <li>Click any session to see the full conversation</li> </ul>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#editing-sessions","level":2,"title":"Editing Sessions","text":"<p>Exported sessions are plain Markdown in <code>.context/journal/</code>. You can:</p> <ul> <li>Add summaries: Fill in the <code>## Summary</code> section</li> <li>Add notes: Insert your own commentary anywhere</li> <li>Highlight key moments: Use Markdown formatting</li> <li>Delete noise: Remove irrelevant tool outputs</li> </ul> <p>After editing, regenerate the site:</p> <pre><code>ctx journal site --serve\n</code></pre> <p>Re-Exporting Preserves Your Enrichments</p> <p>Running <code>ctx recall export --all</code> updates existing files by default:</p> <p>YAML frontmatter (topics, type, outcome, etc.) is preserved, and only the conversation content is regenerated.</p> <p>Use <code>--skip-existing</code> to leave existing files completely untouched, or <code>--force</code> to overwrite everything (frontmatter will be lost).</p>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#large-sessions","level":2,"title":"Large Sessions","text":"<p>Sessions with many messages (200+) are automatically split into multiple parts  for better browser performance. Navigation links connect the parts:</p> <pre><code>session-abc123.md      (Part 1 of 3)\nsession-abc123-p2.md   (Part 2 of 3)\nsession-abc123-p3.md   (Part 3 of 3)\n</code></pre>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#suggestion-sessions","level":2,"title":"Suggestion Sessions","text":"<p>Claude Code generates \"suggestion\" sessions for auto-complete prompts. These  are separated in the index under a \"Suggestions\" section to keep your main  session list focused.</p>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#enriching-journal-entries","level":2,"title":"Enriching Journal Entries","text":"<p>Raw exported sessions contain basic metadata (date, time, project) but lack the structured information needed for effective search, filtering, and analysis. Journal enrichment adds semantic metadata that transforms a flat archive into a searchable knowledge base.</p>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#why-enrich","level":3,"title":"Why Enrich?","text":"<p>Without enrichment, you have timestamps and raw conversations. With enrichment:</p> <ul> <li>Find sessions by topic: \"Show me all auth-related sessions\"</li> <li>Filter by outcome: \"What did I abandon vs complete?\"</li> <li>Track technology usage: \"When did I last work with PostgreSQL?\"</li> <li>Identify key files: Jump directly to the files discussed</li> <li>Get summaries: Understand what happened without reading transcripts</li> </ul>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#the-frontmatter-schema","level":3,"title":"The Frontmatter Schema","text":"<p>Enriched entries begin with YAML frontmatter:</p> <pre><code>---\ntitle: \"Implement caching layer\"\ndate: 2026-01-27\ntype: feature\noutcome: completed\ntopics:\n  - caching\n  - performance\ntechnologies:\n  - go\n  - redis\nlibraries:\n  - go-redis/redis\nkey_files:\n  - internal/cache/redis.go\n  - internal/cache/memory.go\n---\n</code></pre> Field Required Description <code>title</code> Yes Descriptive title (not the session slug) <code>date</code> Yes Session date (YYYY-MM-DD) <code>type</code> Yes Session type (see below) <code>outcome</code> Yes How the session ended (see below) <code>topics</code> No Subject areas discussed <code>technologies</code> No Languages, databases, frameworks <code>libraries</code> No Specific packages or libraries used <code>key_files</code> No Important files created or modified <p>Type values:</p> Type When to use <code>feature</code> Building new functionality <code>bugfix</code> Fixing broken behavior <code>refactor</code> Restructuring without behavior change <code>exploration</code> Research, learning, experimentation <code>debugging</code> Investigating issues <code>documentation</code> Writing docs, comments, README <p>Outcome values:</p> Outcome Meaning <code>completed</code> Goal achieved <code>partial</code> Some progress, work continues <code>abandoned</code> Stopped pursuing this approach <code>blocked</code> Waiting on external dependency","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#using-ctx-journal-enrich","level":3,"title":"Using <code>/ctx-journal-enrich</code>","text":"<p>The <code>/ctx-journal-enrich</code> skill automates enrichment by analyzing conversation content and proposing metadata.</p> <p>Invoke by session identifier:</p> <pre><code>/ctx-journal-enrich twinkly-stirring-kettle\n/ctx-journal-enrich twinkly\n/ctx-journal-enrich 2026-01-24\n/ctx-journal-enrich 76fe2ab9\n</code></pre> <p>The skill will:</p> <ol> <li>Find the matching journal file</li> <li>Read and analyze the conversation</li> <li>Propose frontmatter (type, topics, outcome, technologies)</li> <li>Generate a 2-3 sentence summary</li> <li>Extract decisions, learnings, and tasks mentioned</li> <li>Show a diff and ask for confirmation before writing</li> </ol>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#before-and-after","level":3,"title":"Before and After","text":"<p>Before enrichment:</p> <pre><code># twinkly-stirring-kettle\n\n**ID**: abc123-def456\n**Date**: 2026-01-24\n**Time**: 14:30:00\n...\n\n## Summary\n\n[Add your summary of this session]\n\n## Conversation\n...\n</code></pre> <p>After enrichment:</p> <pre><code>---\ntitle: \"Add Redis caching to API endpoints\"\ndate: 2026-01-24\ntype: feature\noutcome: completed\ntopics:\n  - caching\n  - api-performance\ntechnologies:\n  - go\n  - redis\nkey_files:\n  - internal/api/middleware/cache.go\n  - internal/cache/redis.go\n---\n\n# twinkly-stirring-kettle\n\n**ID**: abc123-def456\n**Date**: 2026-01-24\n**Time**: 14:30:00\n...\n\n## Summary\n\nImplemented Redis-based caching middleware for frequently accessed API endpoints.\nAdded cache invalidation on writes and configurable TTL per route. Reduced\n the average response time from 200ms to 15ms for cached routes.\n\n## Decisions\n\n* Used Redis over in-memory cache for horizontal scaling\n* Chose per-route TTL configuration over global setting\n\n## Learnings\n\n* Redis WATCH command prevents race conditions during cache invalidation\n\n## Conversation\n...\n</code></pre>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#enrichment-and-site-generation","level":3,"title":"Enrichment and Site Generation","text":"<p>The journal site generator uses enriched metadata for better organization:</p> <ul> <li>Titles appear in navigation instead of slugs</li> <li>Summaries provide context in the index</li> <li>Topics enable filtering (when using search)</li> <li>Types allow grouping by work category</li> </ul> <p>Future improvements will add topic-based navigation and outcome filtering to the generated site.</p>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#batch-enrichment","level":3,"title":"Batch Enrichment","text":"<p>To enrich multiple sessions, process them one at a time:</p> <pre><code># List unenriched sessions (those without frontmatter)\ngrep -L \"^---$\" .context/journal/*.md | head -10\n</code></pre> <p>Then run <code>/ctx-journal-enrich</code> on each. Enrichment is intentionally interactive to ensure accuracy.</p>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#context-monitor","level":2,"title":"Context Monitor","text":"<p>The Context Monitor (<code>context-watch.sh</code>) is a terminal-based tool that shows real-time token usage for your active Claude Code session. Run it in a separate terminal window to keep an eye on context consumption.</p>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#setup","level":3,"title":"Setup","text":"<p>After running <code>ctx init</code>, the monitor script is available at:</p> <pre><code>.context/tools/context-watch.sh\n</code></pre>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#usage","level":3,"title":"Usage","text":"<pre><code># Default: refresh every 10 seconds\n.context/tools/context-watch.sh\n\n# Custom refresh interval (5 seconds)\n.context/tools/context-watch.sh 5\n</code></pre> <p>The monitor displays:</p> <ul> <li>Progress bar with estimated token usage versus effective limit</li> <li>Color-coded status: green (healthy), yellow (monitor), red (save and end)</li> <li>Session info: file size, message count, last update time</li> <li>Remaining tokens: how much usable context is left</li> </ul> <p></p> <p></p>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#how-it-works","level":3,"title":"How It Works","text":"<p>The monitor finds the most recently modified session <code>JSONL</code> in <code>~/.claude/projects/</code>, estimates token count using a character-based heuristic (~30 chars per token for JSON content), and adds an overhead estimate for system prompts, tools, and skills that aren't in the JSONL.</p> Constant Value Meaning Model limit 200,000 Claude's context window Autocompact buffer 33,000 Reserved by Claude Code, not usable System overhead 20,000 System prompt + tools + skills + memory Effective limit 167,000 What you can actually use for conversation <p>Pair with the context checkpoint hook</p> <p>The monitor is for manual observation. For automated alerts within your session, the ctx plugin includes a <code>check-context-size</code> hook that triggers the <code>/ctx-context-monitor</code> skill at adaptive intervals.</p>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#obsidian-vault-export","level":2,"title":"Obsidian Vault Export","text":"<p>If you use Obsidian for knowledge management, you can export your journal as an Obsidian vault instead of (or alongside) the static site:</p> <pre><code>ctx journal obsidian\n</code></pre> <p>This generates a vault in <code>.context/journal-obsidian/</code> with:</p> <ul> <li>Wikilinks (<code>[[target|display]]</code>) instead of Markdown links</li> <li>MOC pages (Map of Content) for topics, key files, and session types</li> <li>Related sessions footer per entry — links to entries sharing the same topics</li> <li>Transformed frontmatter — <code>topics</code> renamed to <code>tags</code> (Obsidian-recognized),   <code>aliases</code> added from title for search</li> <li>Graph-optimized structure — MOC hubs + cross-linked entries create dense   graph connectivity</li> </ul> <p>To use: open the output directory in Obsidian (\"Open folder as vault\").</p> <pre><code># Custom output directory\nctx journal obsidian --output ~/vaults/ctx-journal\n</code></pre> <p>Static site vs Obsidian vault</p> <p>Use <code>ctx journal site</code> when you want a web-browsable archive with search and dark mode. Use <code>ctx journal obsidian</code> when you want graph view, backlinks, and tag-based navigation inside Obsidian. Both use the same enriched source entries — you can generate both.</p>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#full-pipeline","level":2,"title":"Full Pipeline","text":"<p>The complete journal workflow has four stages. Each is idempotent — safe to re-run, and stages skip already-processed entries.</p> <pre><code>export → normalize → enrich → rebuild\n</code></pre> Stage Command / Skill What it does Skips if Export <code>ctx recall export --all</code> Converts session JSONL to Markdown <code>--skip-existing</code> flag Normalize <code>/ctx-journal-normalize</code> Fixes fence nesting and metadata tables <code>&lt;!-- normalized --&gt;</code> marker Enrich <code>/ctx-journal-enrich</code> Adds frontmatter, summaries, topics Frontmatter already present Rebuild <code>ctx journal site --build</code> Generates static HTML site — Obsidian <code>ctx journal obsidian</code> Generates Obsidian vault with wikilinks —","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#using-make-journal","level":3,"title":"Using <code>make journal</code>","text":"<p>If your project includes <code>Makefile.ctx</code> (deployed by <code>ctx init</code>), the first and last stages are combined:</p> <pre><code>make journal           # export + rebuild\n</code></pre> <p>After it runs, it reminds you to normalize and enrich in Claude Code:</p> <pre><code>Next steps (in Claude Code):\n  1. /ctx-journal-normalize  — fix markdown rendering (skips already normalized)\n  2. /ctx-journal-enrich     — add metadata per entry (skips if frontmatter exists)\n\nThen re-run: make journal\n</code></pre>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#normalizing-journal-entries","level":3,"title":"Normalizing Journal Entries","text":"<p>Raw exported sessions may have rendering issues: nested code fences, malformed metadata blocks, or broken lists. The <code>/ctx-journal-normalize</code> skill fixes these in the source files so the site renders correctly.</p> <pre><code>/ctx-journal-normalize\n</code></pre> <p>It backs up <code>.context/journal/</code> before modifying anything, and marks processed files with <code>&lt;!-- normalized: YYYY-MM-DD --&gt;</code> so re-runs skip them.</p> <p>Run normalize before enrich — the enrichment skill reads conversation content, and clean markdown produces better metadata extraction.</p>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#tips","level":2,"title":"Tips","text":"<p>Daily workflow: <pre><code># Export, browse, then enrich in Claude Code\nmake journal &amp;&amp; make journal-serve\n# Then in Claude Code: /ctx-journal-enrich &lt;session&gt;\n</code></pre></p> <p>After a productive session: <pre><code># Export just that session and add notes\nctx recall export &lt;session-id&gt;\n# Edit .context/journal/&lt;session&gt;.md\n# Regenerate: ctx journal site\n</code></pre></p> <p>Searching across all sessions: <pre><code># Use grep on the journal directory\ngrep -r \"authentication\" .context/journal/\n</code></pre></p>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#requirements","level":2,"title":"Requirements","text":"<p>The journal site uses zensical for static site generation:</p> <pre><code>pipx install zensical\n</code></pre> <p>Use pipx for zensical</p> <p><code>pip install zensical</code> may install a non-functional stub on system Python 3.9. </p> <p>Use <code>pipx install zensical</code> instead, which creates an isolated environment and handles Python version management automatically.</p> <p>This issue especially happens on Mac OSX.</p>","path":["Reference","Session Journal"],"tags":[]},{"location":"session-journal/#see-also","level":2,"title":"See Also","text":"<ul> <li><code>ctx recall</code>: Session discovery and listing</li> <li><code>ctx journal site</code>: Static site generation</li> <li><code>ctx journal obsidian</code>: Obsidian vault export</li> <li>Context Files: The <code>.context/</code> directory structure</li> </ul>","path":["Reference","Session Journal"],"tags":[]},{"location":"skills/","level":1,"title":"ctx Skills","text":"","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#skills","level":2,"title":"Skills","text":"<p>Skills are slash commands that run inside your AI assistant (e.g., <code>/ctx-next</code>), as opposed to CLI commands that run in your terminal (e.g., <code>ctx status</code>). </p> <p>Skills give your agent structured workflows: It knows what to read, what to  run, and when to ask. Most wrap one or more <code>ctx</code> CLI commands with  opinionated behavior on top. </p> <p>Skills Are Best Used Conversationally</p> <p>The beauty of <code>ctx</code> is that it's designed to be intuitive and  conversational, allowing you to interact with your AI assistant  naturally. That's why you don't have to memorize many of these skills.</p> <p>See the Prompting Guide for natural-language  triggers that invoke these skills conversationally.</p> <p>However, when you need a more precise control, you have the option to invoke the relevant skills directly.</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#all-skills","level":2,"title":"All Skills","text":"Skill Description Type <code>/ctx-remember</code> Recall project context and present structured readback user-invocable <code>/ctx-status</code> Show context summary with interpretation user-invocable <code>/ctx-agent</code> Load full context packet for AI consumption user-invocable <code>/ctx-next</code> Suggest 1-3 concrete next actions with rationale user-invocable <code>/ctx-commit</code> Commit with integrated context persistence user-invocable <code>/ctx-reflect</code> Pause and reflect on session progress user-invocable <code>/ctx-add-task</code> Add actionable task to TASKS.md user-invocable <code>/ctx-add-decision</code> Record architectural decision with rationale user-invocable <code>/ctx-add-learning</code> Record gotchas and lessons learned user-invocable <code>/ctx-add-convention</code> Record coding convention for consistency user-invocable <code>/ctx-archive</code> Archive completed tasks from TASKS.md user-invocable <code>/ctx-pad</code> Manage encrypted scratchpad entries user-invocable <code>/ctx-recall</code> Browse and export AI session history user-invocable <code>/ctx-journal-enrich</code> Enrich single journal entry with metadata user-invocable <code>/ctx-journal-enrich-all</code> Batch-enrich all unenriched journal entries user-invocable <code>/ctx-journal-normalize</code> Normalize journal markdown for clean rendering user-invocable <code>/ctx-blog</code> Generate blog post draft from project activity user-invocable <code>/ctx-blog-changelog</code> Generate themed blog post from a commit range user-invocable <code>/ctx-drift</code> Detect and fix context drift user-invocable <code>/ctx-alignment-audit</code> Audit docs claims against agent instructions user-invocable <code>/ctx-prompt-audit</code> Analyze prompting patterns for improvement user-invocable <code>/check-links</code> Audit docs for dead internal and external links user-invocable <code>/ctx-context-monitor</code> Respond to context checkpoint signals automatic <code>/ctx-implement</code> Execute a plan step-by-step with verification user-invocable <code>/ctx-loop</code> Generate autonomous loop script user-invocable <code>/ctx-worktree</code> Manage git worktrees for parallel agents user-invocable","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#session-lifecycle","level":2,"title":"Session Lifecycle","text":"<p>Skills for starting, running, and ending a productive session.</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-remember","level":3,"title":"<code>/ctx-remember</code>","text":"<p>Recall project context and present a structured readback.</p> <p>Wraps: <code>ctx agent --budget 4000</code>, <code>ctx recall list --limit 3</code>, reads TASKS.md, DECISIONS.md, LEARNINGS.md</p> <p>See also: The Complete Session</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-status","level":3,"title":"<code>/ctx-status</code>","text":"<p>Show context summary — files, token budget, tasks, recent activity — with interpreted suggestions.</p> <p>Wraps: <code>ctx status [--verbose] [--json]</code></p> <p>See also: The Complete Session, <code>ctx status</code> CLI</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-agent","level":3,"title":"<code>/ctx-agent</code>","text":"<p>Load the full context packet optimized for AI consumption. Also runs automatically via the PreToolUse hook with cooldown.</p> <p>Wraps: <code>ctx agent [--budget] [--format] [--cooldown] [--session]</code></p> <p>See also: The Complete Session, <code>ctx agent</code> CLI</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-next","level":3,"title":"<code>/ctx-next</code>","text":"<p>Suggest 1-3 concrete next actions ranked by priority, momentum, and unblocked status.</p> <p>Wraps: reads TASKS.md, <code>ctx recall list --limit 3</code></p> <p>See also: The Complete Session, Tracking Work Across Sessions</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-commit","level":3,"title":"<code>/ctx-commit</code>","text":"<p>Commit code with integrated context persistence — pre-commit checks, staged files, Co-Authored-By trailer, and a post-commit prompt to capture decisions and learnings.</p> <p>Wraps: <code>git add</code>, <code>git commit</code>, optionally chains to <code>/ctx-add-decision</code> and <code>/ctx-add-learning</code></p> <p>See also: The Complete Session</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-reflect","level":3,"title":"<code>/ctx-reflect</code>","text":"<p>Pause and reflect on session progress. Walks through a checklist of learnings, decisions, task completions, and session notes to persist.</p> <p>Wraps: chains to <code>ctx add learning</code>, <code>ctx add decision</code>, manual TASKS.md updates</p> <p>See also: The Complete Session, Persisting Decisions, Learnings, and Conventions</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#context-persistence","level":2,"title":"Context Persistence","text":"<p>Skills for recording work artifacts — tasks, decisions, learnings, conventions — into <code>.context/</code> files.</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-add-task","level":3,"title":"<code>/ctx-add-task</code>","text":"<p>Add an actionable task with optional priority and phase section.</p> <p>Wraps: <code>ctx add task \"description\" [--priority high|medium|low]</code></p> <p>See also: Tracking Work Across Sessions</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-add-decision","level":3,"title":"<code>/ctx-add-decision</code>","text":"<p>Record an architectural decision with context, rationale, and consequences. Supports Y-statement (lightweight) and full ADR formats.</p> <p>Wraps: <code>ctx add decision \"title\" --context \"...\" --rationale \"...\" --consequences \"...\"</code></p> <p>See also: Persisting Decisions, Learnings, and Conventions</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-add-learning","level":3,"title":"<code>/ctx-add-learning</code>","text":"<p>Record a project-specific gotcha, bug, or unexpected behavior. Filters for insights that are searchable, project-specific, and required real effort to discover.</p> <p>Wraps: <code>ctx add learning \"title\" --context \"...\" --lesson \"...\" --application \"...\"</code></p> <p>See also: Persisting Decisions, Learnings, and Conventions</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-add-convention","level":3,"title":"<code>/ctx-add-convention</code>","text":"<p>Record a coding convention that should be standardized across sessions. Targets patterns seen 2-3+ times.</p> <p>Wraps: <code>ctx add convention \"rule\" --section \"Name\"</code></p> <p>See also: Persisting Decisions, Learnings, and Conventions</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-archive","level":3,"title":"<code>/ctx-archive</code>","text":"<p>Archive completed tasks from TASKS.md to a timestamped file in <code>.context/archive/</code>. Preserves phase headers for traceability.</p> <p>Wraps: <code>ctx tasks archive [--dry-run]</code></p> <p>See also: Tracking Work Across Sessions</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#scratchpad","level":2,"title":"Scratchpad","text":"","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-pad","level":3,"title":"<code>/ctx-pad</code>","text":"<p>Manage the encrypted scratchpad — add, remove, edit, and reorder one-liner notes. Encrypted at rest with AES-256-GCM.</p> <p>Wraps: <code>ctx pad</code>, <code>ctx pad add</code>, <code>ctx pad rm</code>, <code>ctx pad edit</code>, <code>ctx pad mv</code></p> <p>See also: Scratchpad, Using the Scratchpad</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#journal-history","level":2,"title":"Journal &amp; History","text":"<p>Skills for browsing, exporting, and enriching your AI session history into a structured journal.</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-recall","level":3,"title":"<code>/ctx-recall</code>","text":"<p>Browse, inspect, and export AI session history. List recent sessions, show details by slug or ID, and export to <code>.context/journal/</code>.</p> <p>Wraps: <code>ctx recall list</code>, <code>ctx recall show</code>, <code>ctx recall export</code></p> <p>See also: Browsing and Enriching Past Sessions</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-journal-enrich","level":3,"title":"<code>/ctx-journal-enrich</code>","text":"<p>Enrich a single journal entry with YAML frontmatter — title, type, outcome, topics, technologies, and summary. Shows diff before writing.</p> <p>Wraps: reads and edits <code>.context/journal/*.md</code> files</p> <p>See also: Browsing and Enriching Past Sessions, Turning Activity into Content</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-journal-enrich-all","level":3,"title":"<code>/ctx-journal-enrich-all</code>","text":"<p>Batch-enrich all unenriched journal entries. Filters out short sessions and continuations. Can spawn subagents for large backlogs.</p> <p>Wraps: iterates <code>/ctx-journal-enrich</code> across all entries</p> <p>See also: Browsing and Enriching Past Sessions</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-journal-normalize","level":3,"title":"<code>/ctx-journal-normalize</code>","text":"<p>Normalize journal markdown for clean rendering — fix fence nesting, metadata formatting, list indentation, and collapse large tool outputs.</p> <p>Wraps: reads and edits <code>.context/journal/*.md</code> files</p> <p>See also: Browsing and Enriching Past Sessions, Turning Activity into Content</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#content-creation","level":2,"title":"Content Creation","text":"<p>Skills for turning project activity into publishable content.</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-blog","level":3,"title":"<code>/ctx-blog</code>","text":"<p>Generate a blog post draft from recent project activity — git history, decisions, learnings, tasks, and journal entries. Requires a narrative arc (problem, approach, outcome).</p> <p>Wraps: reads <code>git log</code>, DECISIONS.md, LEARNINGS.md, TASKS.md, journal entries; writes to <code>docs/blog/</code></p> <p>See also: Turning Activity into Content</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-blog-changelog","level":3,"title":"<code>/ctx-blog-changelog</code>","text":"<p>Generate a themed blog post from a commit range. Takes a starting commit and unifying theme, analyzes diffs and journal entries from that period.</p> <p>Wraps: <code>git log</code>, <code>git diff --stat</code>; writes to <code>docs/blog/</code></p> <p>See also: Turning Activity into Content</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#auditing-health","level":2,"title":"Auditing &amp; Health","text":"<p>Skills for detecting drift, auditing alignment, and improving prompt quality.</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-drift","level":3,"title":"<code>/ctx-drift</code>","text":"<p>Detect and fix context drift: stale paths, missing files, file age staleness, task accumulation, and constitution violations via <code>ctx drift</code>. Also detects skill drift against canonical templates.</p> <p>Wraps: <code>ctx drift [--fix]</code></p> <p>See also: Detecting and Fixing Drift</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-alignment-audit","level":3,"title":"<code>/ctx-alignment-audit</code>","text":"<p>Audit behavioral claims in docs and recipes against actual agent instructions. Traces each claim to its backing instruction and reports coverage as Covered, Partial, or Gap.</p> <p>Wraps: reads AGENT_PLAYBOOK.md, plugin skill definitions, CLAUDE.md, and docs/recipes</p> <p>See also: Detecting and Fixing Drift</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-prompt-audit","level":3,"title":"<code>/ctx-prompt-audit</code>","text":"<p>Analyze recent prompting patterns to identify vague or ineffective prompts. Reviews 3-5 journal entries and suggests rewrites with positive observations.</p> <p>Wraps: reads <code>.context/journal/</code> entries</p> <p>See also: Detecting and Fixing Drift</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#check-links","level":3,"title":"<code>/check-links</code>","text":"<p>Scan all markdown files under <code>docs/</code> for broken links. Two passes: internal links (verify file targets exist on disk) and external links (HTTP HEAD with timeout, report failures as warnings). Also checks image references.</p> <p>Invoked automatically as check #12 during <code>/consolidate</code>.</p> <p>Wraps: Glob + Grep to scan, <code>curl</code> for external checks</p> <p>See also: <code>/consolidate</code></p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-context-monitor","level":3,"title":"<code>/ctx-context-monitor</code>","text":"<p>Respond to context checkpoint signals when usage hits high thresholds. Fires at adaptive intervals and offers context persistence before the session ends.</p> <p>Type: Automatic: Triggered by the <code>check-context-size</code> hook, not user-invocable</p> <p>Wraps: hook-driven; suggests <code>/ctx-reflect</code></p> <p>See also: Running an Unattended AI Agent</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#planning-execution","level":2,"title":"Planning &amp; Execution","text":"<p>Skills for structured implementation and parallel agent workflows.</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-implement","level":3,"title":"<code>/ctx-implement</code>","text":"<p>Execute a multi-step plan with build and test verification at each step. Loads a plan from a file or conversation context, breaks it into atomic steps, and checkpoints after every 3-5 steps.</p> <p>Wraps: reads plan file, runs verification commands (<code>go build</code>, <code>go test</code>, etc.)</p> <p>See also: Running an Unattended AI Agent</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-loop","level":3,"title":"<code>/ctx-loop</code>","text":"<p>Generate a ready-to-run shell script for autonomous AI iteration. Supports Claude Code, Aider, and generic tool templates with configurable completion signals.</p> <p>Wraps: <code>ctx loop [--tool] [--prompt] [--max-iterations] [--completion] [--output]</code></p> <p>See also: Autonomous Loops, Running an Unattended AI Agent</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#ctx-worktree","level":3,"title":"<code>/ctx-worktree</code>","text":"<p>Manage git worktrees for parallel agent development. Create sibling worktrees on dedicated branches, analyze task blast radius for grouping, and tear down with merge.</p> <p>Wraps: <code>git worktree add</code>, <code>git worktree list</code>, <code>git worktree remove</code>, <code>git merge</code></p> <p>See also: Parallel Agent Development with Git Worktrees</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"skills/#project-specific-skills","level":2,"title":"Project-Specific Skills","text":"<p>The ctx plugin ships the skills listed above. Teams can add their own project-specific skills to <code>.claude/skills/</code> in the project root — these are separate from plugin-shipped skills and are scoped to the project.</p> <p>Project-specific skills follow the same format and are invoked the same way.</p> <p>Custom skills are not covered in this reference.</p>","path":["Reference","ctx Skills"],"tags":[]},{"location":"upgrading/","level":1,"title":"Upgrading ctx","text":"","path":["Operations","Upgrading ctx"],"tags":[]},{"location":"upgrading/#upgrading-ctx","level":2,"title":"Upgrading ctx","text":"<p>New versions of <code>ctx</code> may ship updated permissions, <code>CLAUDE.md</code> directives, or plugin hooks and skills.</p> <p>Claude Code User?</p> <p>The marketplace can update skills, hooks, and prompts independently: <code>/plugin</code> → select ctx → Update now (or enable auto-update).</p> <p>The <code>ctx</code> binary is separate — rebuild from source or download a new release when one is available, then run <code>ctx init --force --merge</code>. Knowledge files are preserved automatically.</p>","path":["Operations","Upgrading ctx"],"tags":[]},{"location":"upgrading/#what-changes-between-versions","level":2,"title":"What Changes Between Versions","text":"<p><code>ctx init</code> generates two categories of files:</p> Category Examples Changes between versions? Infrastructure <code>.claude/settings.local.json</code> (permissions), ctx-managed sections in <code>CLAUDE.md</code> and <code>PROMPT.md</code>, ctx plugin (hooks + skills) Yes Knowledge <code>.context/TASKS.md</code>, <code>DECISIONS.md</code>, <code>LEARNINGS.md</code>, <code>CONVENTIONS.md</code>, <code>ARCHITECTURE.md</code>, <code>GLOSSARY.md</code>, <code>CONSTITUTION.md</code>, <code>AGENT_PLAYBOOK.md</code> No: this is your data <p>Infrastructure is regenerated by <code>ctx init</code> and plugin updates. Knowledge files are yours and should never be overwritten.</p>","path":["Operations","Upgrading ctx"],"tags":[]},{"location":"upgrading/#upgrade-steps","level":2,"title":"Upgrade Steps","text":"","path":["Operations","Upgrading ctx"],"tags":[]},{"location":"upgrading/#1-install-the-new-version","level":3,"title":"1. Install the New Version","text":"<p>Build from source or download the binary:</p> <pre><code>cd /path/to/ctx-source\ngit pull\nmake build\nsudo make install\nctx --version   # verify\n</code></pre>","path":["Operations","Upgrading ctx"],"tags":[]},{"location":"upgrading/#2-reinitialize","level":3,"title":"2. Reinitialize","text":"<pre><code>ctx init --force --merge\n</code></pre> <ul> <li><code>--force</code> regenerates infrastructure files (permissions, ctx-managed   sections in <code>CLAUDE.md</code> and <code>PROMPT.md</code>).</li> <li><code>--merge</code> preserves your content outside ctx markers.</li> </ul> <p>Knowledge files (<code>.context/TASKS.md</code>, <code>DECISIONS.md</code>, etc.) are preserved automatically — <code>ctx init</code> only overwrites infrastructure, never your data.</p> <p>Scratchpad key: If you use <code>ctx pad</code>, verify that <code>.context/.scratchpad.key</code> is still present after reinit. It should be preserved, but losing it means losing access to encrypted scratchpad data.</p>","path":["Operations","Upgrading ctx"],"tags":[]},{"location":"upgrading/#3-update-the-ctx-plugin","level":3,"title":"3. Update the ctx Plugin","text":"<p>If you use Claude Code, update the plugin to get new hooks and skills:</p> <ol> <li>Open <code>/plugin</code> in Claude Code.</li> <li>Select ctx.</li> <li>Click Update now.</li> </ol> <p>Or enable auto-update so the plugin stays current without manual steps.</p>","path":["Operations","Upgrading ctx"],"tags":[]},{"location":"upgrading/#4-review-custom-settings","level":3,"title":"4. Review Custom Settings","text":"<p>If you added custom permissions to <code>.claude/settings.local.json</code> beyond what <code>ctx init</code> provides, diff and merge:</p> <pre><code>diff .claude.bak/settings.local.json .claude/settings.local.json\n</code></pre> <p>Manually add back any custom entries that the new init dropped.</p>","path":["Operations","Upgrading ctx"],"tags":[]},{"location":"upgrading/#5-verify","level":3,"title":"5. Verify","text":"<pre><code>ctx status          # context files intact\nctx drift           # no broken references\n</code></pre>","path":["Operations","Upgrading ctx"],"tags":[]},{"location":"upgrading/#6-clean-up","level":3,"title":"6. Clean Up","text":"<p>If you made manual backups, remove them once satisfied:</p> <pre><code>rm -rf .context.bak .claude.bak CLAUDE.md.bak PROMPT.md.bak\n</code></pre>","path":["Operations","Upgrading ctx"],"tags":[]},{"location":"upgrading/#what-if-i-skip-the-upgrade","level":2,"title":"What If I Skip the Upgrade?","text":"<p>The old binary still works with your existing <code>.context/</code> files. But you may miss:</p> <ul> <li>New plugin hooks that enforce better practices or catch mistakes;</li> <li>Updated skill prompts that produce better results;</li> <li>New <code>.gitignore</code> entries for directories added in newer versions;</li> <li>Bug fixes in the CLI itself.</li> </ul> <p>The plugin and the binary can be updated independently. You can update the plugin (for new hooks/skills) even if you stay on an older binary, and vice versa.</p> <p>Context files are plain Markdown: They never break between versions.</p> <p>The surrounding infrastructure is what evolves.</p>","path":["Operations","Upgrading ctx"],"tags":[]},{"location":"upgrading/#quick-reference","level":2,"title":"Quick Reference","text":"<pre><code># Plugin users (Claude Code)\n# /plugin → select ctx → Update now\n# Then update the binary and reinitialize:\nctx init --force --merge\n\n# From-source / manual users\n# install new ctx binary, then:\nctx init --force --merge\n# /plugin → select ctx → Update now   (if using Claude Code)\n</code></pre>","path":["Operations","Upgrading ctx"],"tags":[]},{"location":"versions/","level":1,"title":"Version History","text":"","path":["Reference","Version History"],"tags":[]},{"location":"versions/#version-history","level":2,"title":"Version History","text":"<p>Documentation snapshots for each release. Click a version to view the  docs as they were at that release.</p>","path":["Reference","Version History"],"tags":[]},{"location":"versions/#releases","level":2,"title":"Releases","text":"Version Release Date Documentation Notes v0.6.0 2026-02-16 View docs Plugin conversion: hooks are Go subcommands, skills ship as plugin v0.3.0 2026-02-07 View docs Journal site, skill sweep, consolidation pass, golangci-lint v2 v0.2.0 2026-02-01 View docs Journal system, recall export, constants refactor, CRLF handling v0.1.2 2026-01-27 View docs Default permissions in <code>ctx init</code>, prompting guide v0.1.1 2026-01-26 View docs Fix hook schema keys, fix JSON unicode escaping v0.1.0 2026-01-25 View docs Initial release: CLI, context files, build system","path":["Reference","Version History"],"tags":[]},{"location":"versions/#latest","level":2,"title":"Latest","text":"<p>The main documentation always reflects the latest development version.</p> <p>For the most recent stable release, see v0.6.0.</p>","path":["Reference","Version History"],"tags":[]},{"location":"versions/#changelog","level":2,"title":"Changelog","text":"<p>For detailed changes between versions, see the  GitHub Releases page.</p>","path":["Reference","Version History"],"tags":[]},{"location":"blog/","level":1,"title":"Blog","text":"<p>Stories, insights, and lessons learned from building and using ctx.</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#posts","level":2,"title":"Posts","text":"","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#when-a-system-starts-explaining-itself","level":3,"title":"When a System Starts Explaining Itself","text":"<p>Jose Alekhinne / February 17, 2026</p> <p>Every new substrate begins as a private advantage. Reality begins when other people start describing it in their own language -- not accurately, not consistently, but involuntarily. \"Better than Adderall\" is not praise; it is a diagnostic: executive function has been externalized. This post collects the first external signals from real users, and asks what it means when a system starts explaining itself without its creator present.</p> <p>Topics: field notes, adoption signals, infrastructure vs tools, context engineering, substrates</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#code-is-cheap-judgment-is-not","level":3,"title":"Code Is Cheap. Judgment Is Not.","text":"<p>Jose Alekhinne / February 17, 2026</p> <p>AI does not replace workers. It replaces unstructured effort. Three weeks of building ctx with an AI agent proved it: YOLO mode showed production is cheap, the 3:1 ratio showed judgment has a cadence, the attention budget showed framing is scarce, and the skill trilogy showed taste is load-bearing. This post threads every previous blog entry into one argument -- and ends with a personal note on why that's empowering, not threatening.</p> <p>Topics: AI and expertise, context engineering, judgment vs production, human-AI collaboration, automation discipline</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#context-as-infrastructure","level":3,"title":"Context as Infrastructure","text":"<p>Jose Alekhinne / February 17, 2026</p> <p>Where does your AI's knowledge live between sessions? If the answer is \"in a prompt I paste at the start,\" you are treating context as a consumable. This post argues for treating it as infrastructure instead: persistent files, separation of concerns, two-tier storage, progressive disclosure, and the filesystem as the most mature interface available. The architectural companion to The Attention Budget and the second piece of the trilogy completed by Code Is Cheap.</p> <p>Topics: context engineering, infrastructure, progressive disclosure, persistence, design philosophy</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#the-31-ratio","level":3,"title":"The 3:1 Ratio","text":"<p>Jose Alekhinne / February 17, 2026</p> <p>AI-assisted development makes technical debt worse -- not because the AI writes bad code, but because it writes code so fast that drift accumulates before you notice. Three weeks of git history prove a rhythm: three feature sessions, one consolidation session. This post shows the evidence, the concrete drift that accumulated, and the decision matrix for when to clean up versus leave things alone.</p> <p>Topics: consolidation, technical debt, development workflow, convention drift, code quality</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#parallel-agents-merge-debt-and-the-myth-of-overnight-progress","level":3,"title":"Parallel Agents, Merge Debt, and the Myth of Overnight Progress","text":"<p>Jose Alekhinne / February 17, 2026</p> <p>You discover agents can run in parallel. So you open ten terminals. Then twenty. The fans spin, tokens burn, the screen looks like progress. It is not progress — it is merge debt being manufactured in real time. This post is about the five-agent ceiling, why role separation beats file locking, why overnight loops are an illusion, and why the only metric that matters is time from idea to verified, mergeable change.</p> <p>Topics: agent workflows, parallelism, verification, context engineering, engineering practice</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#ctx-v060-the-integration-release","level":3,"title":"ctx v0.6.0: The Integration Release","text":"<p>Jose Alekhinne / February 16, 2026</p> <p>ctx is now a Claude Marketplace plugin. Two commands, no build step, no shell scripts. v0.6.0 replaces six Bash hook scripts with compiled Go subcommands, ships 25 skills as a plugin served directly from source, and closes three medium-severity security findings. The version jumped from 0.3.0 to 0.6.0 because this is the release that turns a developer tool into a distributable product.</p> <p>Topics: release, plugin system, Claude Marketplace, distribution, security hardening</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#ctx-v030-the-discipline-release","level":3,"title":"ctx v0.3.0: The Discipline Release","text":"<p>Jose Alekhinne / February 15, 2026</p> <p>No new headline feature. No architectural pivot. No rewrite. Just 35+ documentation and quality commits against ~15 feature commits — and somehow, the tool feels like it grew up overnight. This post is about what a release looks like when the ratio of polish to features is 3:1.</p> <p>Topics: release, skills migration, consolidation, code quality, E/A/R framework</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#why-zensical","level":3,"title":"Why Zensical","text":"<p>Jose Alekhinne / February 15, 2026</p> <p>I needed a static site generator for the journal system and the instinct was Hugo — same language as ctx, fast, well-established. But instinct is not analysis. The journal entries are standard Markdown with YAML frontmatter. That is it. No JSX, no shortcodes, no custom templating. This post is about why zensical — a pre-1.0 tool from the Material for MkDocs team — was the right choice: thin dependencies, MkDocs-compatible config, 4-5x faster incremental rebuilds, and zero lock-in.</p> <p>Topics: tooling, static site generators, journal system, infrastructure decisions, context engineering</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#parallel-agents-with-git-worktrees","level":3,"title":"Parallel Agents with Git Worktrees","text":"<p>Jose Alekhinne / February 14, 2026</p> <p>I had 30 open tasks and most of them didn't touch the same files. Running one agent at a time meant serial execution on work that was fundamentally parallel. This post is about using git worktrees to partition a backlog by file overlap, run 3-4 agents simultaneously, and merge the results — the same attention budget principle applied to execution instead of context.</p> <p>Topics: agent teams, parallelism, git worktrees, context engineering, task management</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#before-context-windows-we-had-bouncers","level":3,"title":"Before Context Windows, We Had Bouncers","text":"<p>Jose Alekhinne / February 14, 2026</p> <p>IRC is stateless. You disconnect, you vanish. Modern systems are not much different: close the tab, lose the scrollback, open a new LLM session, start from zero. This post traces the line from IRC bouncers like ZNC to context engineering: stateless protocols require stateful wrappers, volatile interfaces require durable memory. Before context windows, we had bouncers. Before AI memory files, we had buffers.</p> <p>Topics: context engineering, infrastructure, IRC, persistence, state continuity</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#how-deep-is-too-deep","level":3,"title":"How Deep Is Too Deep?","text":"<p>Jose Alekhinne / February 12, 2026</p> <p>I kept feeling like I should go deeper into ML theory. Then I spent a week debugging an agent failure that had nothing to do with model architecture and everything to do with knowing which abstraction was leaking. This post is about when depth compounds and when it doesn't: why the useful understanding lives one or two layers below where you work, not at the bottom of the stack.</p> <p>Topics: AI foundations, abstraction boundaries, agentic systems, context engineering, failure modes</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#defense-in-depth-securing-ai-agents","level":3,"title":"Defense in Depth: Securing AI Agents","text":"<p>Jose Alekhinne / February 9, 2026</p> <p>I was writing the autonomous loops recipe and realized the security advice was \"use CONSTITUTION.md for guardrails.\" Then I read that sentence back and realized: that is wishful thinking. This post traces five defense layers for unattended AI agents, each with a bypass, and shows why the strength is in the combination, not any single layer.</p> <p>Topics: agent security, defense in depth, prompt injection, autonomous loops, container isolation</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#not-everything-is-a-skill","level":3,"title":"Not Everything Is a Skill","text":"<p>Jose Alekhinne / February 8, 2026</p> <p>I ran an 8-agent codebase audit and got actionable results. The natural instinct was to wrap the prompt as a <code>/ctx-audit</code> skill. Then I applied my own criteria from the skill trilogy: it failed all three tests. This post is about the difference between skills and recipes, why the attention budget applies to your skill library too, and why the best automation decision is sometimes not to automate.</p> <p>Topics: skill design, context engineering, automation discipline, recipes, agent teams</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#the-anatomy-of-a-skill-that-works","level":3,"title":"The Anatomy of a Skill That Works","text":"<p>Jose Alekhinne / February 7, 2026</p> <p>I had 20 skills. Most were well-intentioned stubs: a description, a command, and a wish for the best. Then I rewrote all of them in a single session. Seven lessons emerged: quality gates prevent premature execution, negative triggers are load-bearing, examples set boundaries better than rules, and skills are contracts, not instructions. The practical companion to the previous two skill design posts.</p> <p>Topics: skill design, context engineering, quality gates, E/A/R framework, practical patterns</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#you-cant-import-expertise","level":3,"title":"You Can't Import Expertise","text":"<p>Jose Alekhinne / February 5, 2026</p> <p>I found a well-crafted consolidation skill: four files, ten patterns, eight analysis dimensions. Applied my own E/A/R framework: 70% was noise. The template was thorough, correct, and almost entirely useless for my project. This post is about why good skills can't be copy-pasted, and how to grow them from your project's own drift history instead.</p> <p>Topics: skill adaptation, E/A/R framework, convention drift, consolidation, project-specific expertise</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#skills-that-fight-the-platform","level":3,"title":"Skills That Fight the Platform","text":"<p>Jose Alekhinne / February 4, 2026</p> <p>AI coding agents ship with carefully designed system prompts. When custom skills conflict with those defaults, the AI has to reconcile contradictory instructions: The result is unpredictable. This post catalogues five conflict patterns discovered while building <code>ctx</code>: judgment suppression, redundant guidance, guilt-tripping, phantom dependencies, and universal triggers.</p> <p>Topics: context engineering, skill design, system prompts, antipatterns, AI safety primitives</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#the-attention-budget-why-your-ai-forgets-what-you-just-told-it","level":3,"title":"The Attention Budget: Why Your AI Forgets What You Just Told It","text":"<p>Jose Alekhinne / February 3, 2026</p> <p>Every token you send to an AI consumes a finite resource: the attention budget. Understanding this constraint shaped every design decision in ctx: hierarchical file structure, explicit budgets, progressive disclosure, and filesystem-as-index. This post explains the theory and how ctx operationalizes it.</p> <p>Topics: attention mechanics, context engineering, progressive disclosure, ctx primitives, token budgets</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#ctx-v020-the-archaeology-release","level":3,"title":"ctx v0.2.0: The Archaeology Release","text":"<p>Jose Alekhinne / February 1, 2026</p> <p>What if your AI could remember everything? Not just the current session, but every session. <code>ctx v0.2.0</code> introduces the recall and journal systems: making 86 commits of history searchable, exportable, and analyzable.  This post tells the story of why those features exist.</p> <p>Topics: session recall, journal system, structured entries, token budgets, meta-tools</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#refactoring-with-intent-human-guided-sessions-in-ai-development","level":3,"title":"Refactoring with Intent: Human-Guided Sessions in AI Development","text":"<p>Jose Alekhinne / February 1, 2026</p> <p>The YOLO mode shipped 14 commands in a week. But technical debt  doesn't send invoices:it just waits. This is the story of what happened when  we stopped auto-accepting everything and started guiding the AI with intent:  27 commits across 4 days, a major version release, and lessons that apply far  beyond ctx.</p> <p>Topics: refactoring, code quality, documentation standards, module decomposition, YOLO versus intentional development</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/#building-ctx-using-ctx-a-meta-experiment-in-ai-assisted-development","level":3,"title":"Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development","text":"<p>Jose Alekhinne / January 27, 2026</p> <p>What happens when you build a tool designed to give AI memory, using that very same tool to remember what you're building? This is the story of <code>ctx</code>: how <code>ctx</code> evolved from a hasty \"YOLO\" experiment to a disciplined system  for persistent AI context, and what we learned along the way.</p> <p>Topics: dogfooding, AI-assisted development, Ralph Loop, session persistence, architectural decisions</p>","path":["ctx Blog","Blog"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/","level":1,"title":"Building ctx Using ctx","text":"<p>Update (2026-02-11)</p> <p>As of v0.4.0, ctx consolidated sessions into the journal mechanism. References to <code>.context/sessions/</code>, auto-save hooks, and <code>SessionEnd</code> auto-save in this post reflect the architecture at the time of writing.</p> <p></p>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/#a-meta-experiment-in-ai-assisted-development","level":2,"title":"A Meta-Experiment in AI-Assisted Development","text":"<p>Jose Alekhinne / 2026-01-27</p> <p>Can a tool design itself?</p> <p>What happens when you build a tool designed to give AI memory,  using that very same tool to remember what you are building? </p> <p>This is the story of <code>ctx</code>, how it evolved from a hasty \"YOLO mode\" experiment  to a disciplined system for persistent AI context, and what I have  learned along the way.</p> <p>Context is a Record</p> <p>Context is a persistent record.</p> <p>By \"context\", I don’t mean model memory or stored thoughts: </p> <p>I mean the durable record of decisions, learnings, and intent  that normally evaporates between sessions.</p>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/#ai-amnesia","level":2,"title":"AI Amnesia","text":"<p>Every developer who works with AI code generators knows the frustration:  you have a deep, productive session where the AI understands your codebase,  your conventions, your decisions. And then you close the terminal. </p> <p>Tomorrow; it's a blank slate. The AI has forgotten everything.</p> <p>That is \"reset amnesia\", and it's not just annoying: it's expensive. </p> <p>Every session starts with re-explaining context, re-reading files,  re-discovering decisions that were already made.</p> <p>I Needed Context</p> <p>I don't want to lose this discussion...  I am a brain-dead developer YOLO'ing my way out</p> <p>☝️ that's exactly what I said to Claude when I first started working on <code>ctx</code>.</p>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/#the-genesis","level":2,"title":"The Genesis","text":"<p>The project started as \"Active Memory\" (<code>amem</code>): a CLI tool to persist AI  context across sessions. </p> <p>The core idea was simple: create a <code>.context/</code> directory with structured  Markdown files for decisions, learnings, tasks, and conventions.  The AI reads these at session start and writes to them before the session ends.</p> <p>The first commit was just scaffolding. But within hours, the  Ralph Loop—an iterative AI development workflow—had produced  a working CLI:</p> <pre><code>feat(cli): implement amem init command\nfeat(cli): implement amem status command\nfeat(cli): implement amem add command\nfeat(cli): implement amem agent command\n...\n</code></pre> <p>Not one, not two, but a whopping fourteen core commands shipped in rapid  succession!</p> <p>I was YOLO'ing like there was no tomorrow:</p> <ul> <li>auto-accept every change, </li> <li>let the AI run free, </li> <li>ship features fast.</li> </ul>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/#the-meta-experiment-using-amem-to-build-amem","level":2,"title":"The Meta-Experiment: Using <code>amem</code> to Build <code>amem</code>","text":"<p>Here's where it gets interesting: On January 20<sup>th</sup>, I asked: </p> <p>\"Can I use <code>amem</code> to help you remember this context when I restart?\"</p> <p>The answer was yes—but with a gap: </p> <p>Autoload worked (via Claude Code's <code>PreToolUse</code> hook), but auto-save was  missing. If the user quit, with Ctrl+C, everything since the last manual save  was lost.</p> <p>That session became the first real test of the system. </p> <p>Here is the first session file we recorded:</p> <pre><code>## Key Discussion Points\n\n### 1. amem vs Ralph Loop - They're Separate Systems\n\n**User's question**: \"How do I use the binary to recreate this project?\"\n\n**Answer discovered**: amem is for context management, Ralph Loop is for \ndevelopment workflow. They're complementary but separate.\n\n### 2. Two Tiers of Context Persistence\n\n| Tier      | What                        | Why                           |\n|-----------|-----------------------------|-------------------------------|\n| Curated   | Learnings, decisions, tasks | Quick reload, token-efficient |\n| Full dump | Entire conversation         | Safety net, nothing lost      |\n\n| Where                  |\n|------------------------|\n| .context/*.md          |\n| .context/sessions/*.md |\n</code></pre> <p>This session file—written by the AI to preserve its own context—became the  template for how <code>ctx</code> handles session persistence.</p>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/#the-rename","level":2,"title":"The Rename","text":"<p>By January 21<sup>st</sup>, I realized \"Active Memory\" was too generic, and (arguably) too marketing-smelly. </p> <p>Besides, the binary was already called <code>ctx</code> (short for Context),  the directory was <code>.context/</code>, and the slash commands would be <code>/ctx-*</code>. </p> <p>So it followed that the project should be renamed to <code>ctx</code> to make things  make sense.</p> <p>The rename touched 100+ files but was clean—a find-and-replace with Go's  type system catching any misses.</p> <p>The git history tells the story:</p> <pre><code>0e8f6bb feat: rename amem to ctx and add Claude Code integration\n87dcfa1 README.\n4f0e195 feat: separate orchestrator directive from agent tasks\n</code></pre>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/#yolo-mode-fast-but-dangerous","level":2,"title":"YOLO Mode: Fast, But Dangerous","text":"<p>The Ralph Loop made feature development incredibly fast. </p> <p>But it created technical debt that I didn't notice until later.</p> <p>A comparison session on January 25<sup>th</sup> revealed the patterns:</p> YOLO Pattern What We Found <code>\"TASKS.md\"</code> scattered in 10 files Same string literal everywhere, no constants <code>dir + \"/\" + file</code> Should be <code>filepath.Join()</code> Monolithic <code>cli_test.go</code> (1500+ lines) Tests disconnected from implementations <code>package initcmd</code> in <code>init/</code> folder Go's \"init\" is reserved—subtle naming collision <p>Here is another analysis made by <code>ctx</code>:</p> <pre><code>● Based on my analysis, here are the key differences:\n\nYOLO Mode (Pre-040ce99)\n- Feature-first: Added slash commands, tests, templates rapidly\n- Scattered magic strings: \"TASKS.md\", \"decision\", \".context\" spread across files\n- Quick file creation: New files without organizational patterns\n- Working but inconsistent: Code functioned but lacked systematic structure\n\nHuman-Guided Mode (Post-040ce99)\n- Consolidation focus: Centralized constants in config package\n- Consistent naming: Dir, File, Filename, UpdateType prefixes\n- Self-referential constants: FileType map uses constants as keys, not literals\n- Proper path construction: filepath.Join() instead of +\"/\"+\n- Colocated tests: Tests next to implementations\n- Canonical naming: Package name = folder name\n</code></pre> <p>The fix required a human-guided refactoring session. I continued to do that before every major release, from that point on.</p> <p>We introduced <code>internal/config/config.go</code> with semantic prefixes:</p> <pre><code>const (\n    DirContext     = \".context\"\n    DirArchive     = \"archive\"\n    DirSessions    = \"sessions\"\n    FilenameTask   = \"TASKS.md\"\n    UpdateTypeTask = \"task\"\n)\n</code></pre> <p>What I begrudgingly learned was:  YOLO mode is effective for velocity but accumulates debt. </p> <p>So I took a mental note to schedule periodic consolidation sessions.</p>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/#the-dogfooding-test-that-failed","level":2,"title":"The Dogfooding Test That Failed","text":"<p>On January 21<sup>st</sup>, I ran an experiment: have another Claude instance rebuild  <code>ctx</code> from scratch using only the specs and <code>PROMPT.md</code>. </p> <p>The Ralph Loop ran, all tasks got checked off, the loop exited successfully.</p> <p>But the binary was broken!</p> <p>Commands just printed help text instead of executing. </p> <p>All tasks were marked \"complete\" but the implementation didn't work.</p> <p>Here's what <code>ctx</code> discovered:</p> <pre><code>## Key Findings\n\n### Dogfooding Binary Is Broken\n- Commands don't execute — they just print root help text\n- All tasks were marked complete but binary doesn't work\n- Lesson: \"tasks checked off\" ≠ \"implementation works\"\n</code></pre> <p>This was humbling—to say the least.</p> <p>I realized, I had the same blind spot in my own codebase: no integration tests that actually invoked the binary. </p> <p>So I added:</p> <ul> <li>Integration tests for all commands</li> <li>Coverage targets (60-80% per package)</li> <li>Smoke tests in CI</li> <li>A constitution rule: \"All code must pass tests before commit\"</li> </ul>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/#the-constitution-versus-conventions","level":2,"title":"The Constitution versus Conventions","text":"<p>As lessons accumulated, there was the temptation to add everything to  <code>CONSTITUTION.md</code> as \"inviolable rules\". </p> <p>But I resisted.</p> <p>The constitution should contain only truly inviolable invariants:</p> <ul> <li>Security (no secrets, no customer data)</li> <li>Quality (tests must pass)</li> <li>Process (decisions need records)</li> <li><code>ctx</code> invocation (always use <code>PATH</code>, never fallback)</li> </ul> <p>Everything else—coding style, file organization, naming  conventions—should go in to <code>CONVENTIONS.md</code>. </p> <p>Here's how <code>ctx</code> explained why the distinction was important: </p> <p>\"Overly strict constitution creates friction and gets ignored.  Conventions can be bent; constitution cannot.\" — Decision record, 2026-01-25</p>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/#hooks-harder-than-they-look","level":2,"title":"Hooks: Harder Than They Look","text":"<p>Claude Code hooks seemed simple: run a script before/after certain events. </p> <p>But I hit multiple gotchas:</p> <p>1. Key names matter</p> <pre><code>// WRONG - \"Invalid key in record\" error\n\"PreToolUseHooks\": [...]\n\n// RIGHT\n\"PreToolUse\": [...]\n</code></pre> <p>2. Blocking requires specific output</p> <pre><code># WRONG - just exits, doesn't block\nexit 1\n\n# RIGHT - JSON output + exit 0\necho '{\"decision\": \"block\", \"reason\": \"Use ctx from PATH\"}'\nexit 0\n</code></pre> <p>3. Go's JSON escaping</p> <p><code>json.Marshal</code> escapes <code>&gt;</code>, <code>&lt;</code>, <code>&amp;</code> as unicode (<code>\\u003e</code>) by default. </p> <p>When generating shell commands in JSON:</p> <pre><code>encoder := json.NewEncoder(file)\nencoder.SetEscapeHTML(false) // Prevent 2&gt;/dev/null → 2\\u003e/dev/null\n</code></pre> <p>4. Regex overfitting</p> <p>Our hook to block non-PATH <code>ctx</code> invocations initially matched too broadly:</p> <pre><code># WRONG - matches /home/user/ctx/internal/file.go (ctx as directory)\n(/home/|/tmp/|/var/)[^ ]*ctx[^ ]*\n\n# RIGHT - matches ctx as binary only\n(/home/|/tmp/|/var/)[^ ]*/ctx( |$)\n</code></pre>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/#the-session-files","level":2,"title":"The Session Files","text":"<p>By the time of this writing this project's <code>ctx</code> sessions (<code>.context/sessions/</code>)  contains 40+ files from this project's development.</p> <p>They are not part of the source code due to security, privacy, and size concerns.</p> <p>However, they are invaluable for the project's progress.</p> <p>Each session file is a timestamped Markdown with:</p> <ul> <li>Summary of what has been accomplished</li> <li>Key decisions made</li> <li>Learnings discovered</li> <li>Tasks for the next session</li> <li>Technical context (platform, versions)</li> </ul> <p>These files are not autoloaded (that would bust the token budget). </p> <p>They are what I see as the \"archaeological record\" of <code>ctx</code>: When the AI needs deeper information about why something was done, it digs into the sessions.</p> <p>Auto-generated session files use a naming convention:</p> <pre><code>2026-01-23-115432-session-prompt_input_exit-summary.md\n2026-01-25-220244-manual-save.md\n2026-01-27-052107-session-other-summary.md\n</code></pre> <p>Also, the <code>SessionEnd</code> hook captures transcripts automatically.  Even <code>Ctrl+C</code>is caught.</p>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/#the-decision-log-18-architectural-decisions","level":2,"title":"The Decision Log: 18 Architectural Decisions","text":"<p><code>ctx</code> helps record every significant architectural choice in  <code>.context/DECISIONS.md</code>. </p> <p>Here are some highlights:</p> <p>Reverse-chronological order (2026-01-27)</p> <pre><code>**Context**: With chronological order, oldest items consume tokens first, and\nnewest (most relevant) items risk being truncated.\n\n**Decision**: Use reverse-chronological order (newest first) for DECISIONS.md\nand LEARNINGS.md.\n</code></pre> <p>PATH over hardcoded paths (2026-01-21)</p> <pre><code>**Context**: Original implementation hardcoded absolute paths in hooks.\nThis breaks when sharing configs with other developers.\n\n**Decision**: Hooks use `ctx` from PATH. `ctx init` checks PATH before \nproceeding.\n</code></pre> <p>Generic core with Claude enhancements (2026-01-20)</p> <pre><code>**Context**: ctx should work with any AI tool, but Claude Code users could\nbenefit from deeper integration.\n\n**Decision**: Keep ctx generic as the core tool, but provide optional\nClaude Code-specific enhancements.\n</code></pre>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/#the-learning-log-24-gotchas-and-insights","level":2,"title":"The Learning Log: 24 Gotchas and Insights","text":"<p>The <code>.context/LEARNINGS.md</code> file captures gotchas that would otherwise be  forgotten. Each has Context, Lesson, and Application sections:</p> <p>CGO on ARM64</p> <pre><code>**Context**: `go test` failed with \n`gcc: error: unrecognized command-line option '-m64'`\n**Lesson**: On ARM64 Linux, CGO causes cross-compilation issues. \nAlways use `CGO_ENABLED=0`.\n</code></pre> <p>Claude Code skills format</p> <pre><code>**Lesson**: Claude Code skills are Markdown files in .claude/commands/ with `YAML`\nfrontmatter (*description, argument-hint, allowed-tools*). Body is the prompt.\n</code></pre> <p>\"Do you remember?\" handling</p> <pre><code>**Lesson**: In a `ctx`-enabled project, \"*do you remember?*\" \nhas an obvious meaning:\ncheck the `.context/` files. Don't ask for clarification—just do it.\n</code></pre>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/#task-archives-the-completed-work","level":2,"title":"Task Archives: The Completed Work","text":"<p>Completed tasks are archived to <code>.context/archive/</code> with timestamps. </p> <p>The archive from January 23<sup>rd</sup> shows 13 phases of work:</p> <ul> <li>Phase 1: Project Scaffolding (Go module, Cobra CLI)</li> <li>Phase 2-4: Core Commands    (init, status, agent, add, complete, drift, sync, compact, watch, hook)</li> <li>Phase 5: Session Management (save, list, load, parse, --extract)</li> <li>Phase 6: Claude Code Integration (hooks, settings, CLAUDE.md handling)</li> <li>Phase 7: Testing &amp; Verification</li> <li>Phase 8: Task Archival</li> <li>Phase 9: Slash Commands</li> <li>Phase 9b: Ralph Loop Integration</li> <li>Phase 10: Project Rename</li> <li>Phase 11: Documentation</li> <li>Phase 12: Timestamp Correlation</li> <li>Phase 13: Rich Context Entries</li> </ul> <p>That's an impressive 173 commits across 8 days of development.</p>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/#what-i-learned-about-ai-assisted-development","level":2,"title":"What I Learned About AI-Assisted Development","text":"<p>1. Memory changes everything</p> <p>When the AI remembers decisions, it doesn't repeat mistakes. When it knows  your conventions, it follows them. </p> <p><code>ctx</code> makes the AI a better collaborator because it's not starting from zero.</p> <p>2. Two-tier persistence works</p> <p>Curated context (<code>DECISIONS.md</code>, <code>LEARNINGS.md</code>, <code>TASKS.md</code>) is for  quick reload. </p> <p>Full session dumps are for archaeology. </p> <p>It's a futile effort to try to fit everything in the token budget.</p> <p>Persist more, load less.</p> <p>3. YOLO mode has its place</p> <p>For rapid prototyping, letting the AI run free is effective. </p> <p>But I had to schedule consolidation sessions. </p> <p>Technical debt accumulates silently.</p> <p>4. The constitution should be small</p> <p>Only truly inviolable rules go in <code>CONSTITUTION.md</code>.  Everything else is a convention. </p> <p>If you put too much in the constitution, it will get ignored.</p> <p>5. Verification is non-negotiable</p> <p>\"All tasks complete\" means nothing if you haven't run the tests. </p> <p>Integration tests that invoke the actual binary caught bugs that  the unit tests missed.</p> <p>6. Session files are underrated</p> <p>The ability to grep through 40 session files and find exactly when and why a  decision was made helped me a lot. </p> <p>It's not about loading them into context: It is about having them when you  need them.</p>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/#the-future-recall-system","level":2,"title":"The Future: Recall System","text":"<p>The next phase of <code>ctx</code> is the Recall System:</p> <ul> <li>Parser: Parse session capture markdowns, enrich with JSONL data</li> <li>Renderer: Goldmark + Chroma for syntax highlighting, dark mode UI</li> <li>Server: Local HTTP server for browsing sessions</li> <li>Search: Inverted index for searching across sessions</li> <li>CLI: <code>ctx recall serve &lt;path&gt;</code> to start the server</li> </ul> <p>The goal is to make the archaeological record browsable—not just <code>grep</code>-able.</p> <p>Because not everyone always lives in the terminal—me included.</p>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-01-27-building-ctx-using-ctx/#conclusion","level":2,"title":"Conclusion","text":"<p>Building <code>ctx</code> using ctx was a meta-experiment in AI-assisted development. </p> <p>I learned that memory isn't just convenient—it's transformative:</p> <ul> <li>An AI that remembers your decisions doesn't repeat mistakes.</li> <li>An AI that knows your conventions doesn't need them re-explained.</li> </ul> <p>If you are reading this, chances are that you already have heard about <code>ctx</code>.</p> <ul> <li><code>ctx</code> is open source at  github.com/ActiveMemory/ctx,</li> <li>and the documentation lives at ctx.ist.</li> </ul> <p>Session Records are a Gold Mine</p> <p>By the time of this writing, I have more than 70 megabytes of text-only session capture, spread across &gt;100 markdown and JSONL files.</p> <pre><code>I am analyzing, synthesizing, encriching them with AI, running RAG\n(*Retrieval-Augmented Generation*) models on them, and the outcome\nsurprises me every day.\n</code></pre> <p>If you are a mere mortal tired of reset amnesia, give <code>ctx</code> a try. </p> <p>And when you do, check <code>.context/sessions/</code> sometime. </p> <p>The archaeological record might surprise you.</p> <p>This blog post was written with the help of <code>ctx</code> with full access to the  <code>ctx</code> session files, decision log, learning log, task archives, and  git history of <code>ctx</code>—The meta continues.</p>","path":["Building ctx Using ctx: A Meta-Experiment in AI-Assisted Development"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/","level":1,"title":"ctx v0.2.0: The Archaeology Release","text":"<p>Update (2026-02-11)</p> <p>As of v0.4.0, ctx consolidated sessions into the journal mechanism. The <code>.context/sessions/</code> directory referenced in this post has been eliminated. Session history is now accessed via <code>ctx recall</code> and enriched journals live in <code>.context/journal/</code>.</p> <p></p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#digging-through-the-past-to-build-the-future","level":2,"title":"Digging Through the Past to Build the Future","text":"<p>Jose Alekhinne / 2026-02-01</p> <p>What if your AI could remember everything?</p> <p>Not just the current session, but every session:</p> <ul> <li>Every decision made,</li> <li>every mistake avoided, </li> <li>every path not taken.</li> </ul> <p>That's what v0.2.0 delivers.</p> <p>Between <code>v0.1.2</code> and <code>v0.2.0</code>, 86 commits landed across 5 days. </p> <p>The release notes list features and fixes. </p> <p>This post tells the story of why those features exist, and what  building them taught me.</p> <p>This isn't a changelog: It is an explanation of intent.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#the-problem-amnesia-isnt-just-session-level","level":2,"title":"The Problem: Amnesia Isn't Just Session-Level","text":"<p>v0.1.0 solved reset amnesia: </p> <p>The AI now remembers decisions, learnings, and tasks across sessions. </p> <p>But a new problem emerged, which I can sum up as: \"I (the human) am not AI\".</p> <p>Frankly, I couldn't remember what the AI remembered.</p> <p>In the course of days, I realized session transcripts piled up in  <code>.context/sessions/</code>; I was <code>grep</code>ping, <code>JSONL</code> files with thousands of lines... Raw tool calls, assistant responses, user messages... all interleaved. </p> <p>Valuable context effectively buried in machine-readable noise.</p> <p>I found myself grepping through files to answer questions like:</p> <ul> <li>\"When did we decide to use constants instead of literals?\"</li> <li>\"What was the session where we fixed the hook regex?\"</li> <li>\"How did the <code>embed.go</code> split actually happen?\"</li> </ul> <p>Fate is Whimsical</p> <p>The irony was painful:  I built a tool to prevent AI amnesia, but I was suffering from  human amnesia about what happened in AI sessions.</p> <p>This was the moment <code>ctx</code> stopped being just an AI tool and started needing to support the human on the other side of the loop.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#the-solution-recall-and-journal","level":2,"title":"The Solution: Recall and Journal","text":"<p>v0.2.0 introduces two interconnected systems.</p> <p>They solve different problems; and only work well together.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#ctx-recall-browse-your-past","level":3,"title":"<code>ctx recall</code>: Browse Your Past","text":"<pre><code># List all sessions for this project\nctx recall list\n\n# Show a specific session\nctx recall show gleaming-wobbling-sutherland\n\n# See the full transcript\nctx recall show gleaming-wobbling-sutherland --full\n````\n\nThe `recall` system parses Claude Code's JSONL transcripts and presents\nthem in a human-readable format:\n\n| Session                       | Date       | Turns | Duration |\n|-------------------------------|------------|-------|----------|\n| tender-painting-sundae        | 2026-01-29 | 3     | &lt;1m      |\n| crystalline-gliding-willow    | 2026-01-29 | 3     | &lt;1m      |\n| declarative-hugging-snowglobe | 2026-01-31 | 2     | &lt;1m      |\n\nSlugs are auto-generated from session IDs (*memorable names instead of\nUUIDs*). The goal (*as the name implies*) is **recall**, not archival accuracy.\n\n!!! note \"2,121 lines of new code\"\n    The `ctx recall` feature was the largest single addition:\n    parser library, CLI commands, test suite, and slash command.\n\n### `ctx journal`: From Raw to Rich\n\nListing sessions isn't enough. The transcripts are still unwieldy.\n\nRecall answers *what happened*.\nJournal answers *what mattered*.\n\n```bash\n# Export sessions to editable Markdown\nctx recall export --all\n\n# Generate a static site from journal entries\nctx journal site\n\n# Serve it locally\nctx serve\n</code></pre> <p>The exported files land in <code>.context/journal/</code>:</p> <pre><code>.context/journal/\n├── 2026-01-28-proud-sleeping-cook-6e535360.md\n├── 2026-01-29-tender-painting-sundae-b14ddaaa.md\n├── 2026-01-29-crystalline-gliding-willow-ff7fd67d.md\n└── 2026-01-31-declarative-hugging-snowglobe-4549026d.md\n</code></pre> <p>Each file is a structured Markdown document ready for enrichment.</p> <p>They are meant to be read, edited, and reasoned about;  not just stored.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#the-meta-slash-commands-for-self-analysis","level":2,"title":"The Meta: Slash Commands for Self-Analysis","text":"<p>The journal system includes four slash commands that use Claude to analyze and synthesize session history:</p> Command Purpose <code>/ctx-journal-enrich</code> Add frontmatter, topics, tags <code>/ctx-blog</code> Generate blog post from activity <code>/ctx-blog-changelog</code> Generate changelog from commits <p>This very post was drafted using <code>/ctx-blog</code>. The previous post about refactoring was drafted the same way.</p> <p>So, yes: The meta continues: <code>ctx</code> now helps write posts about <code>ctx</code>.</p> <p>With the current release, <code>ctx</code> is no longer just recording history: It is participating in its interpretation.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#the-structure-decisions-as-first-class-citizens","level":2,"title":"The Structure: Decisions as First-Class Citizens","text":"<p><code>v0.1.0</code> let you add decisions with a simple command:</p> <pre><code>ctx add decision \"Use PostgreSQL\"\n</code></pre> <p>But sessions showed a pattern: decisions added this way were incomplete. Context was missing. Rationale was vague. Consequences were never stated.</p> <p>Once recall and journaling existed, this weakness became impossible to ignore. Structure stopped being optional.</p> <p><code>v0.2.0</code> enforces structure:</p> <pre><code>ctx add decision \"Use PostgreSQL\" \\\n  --context \"Need a reliable database for user data\" \\\n  --rationale \"ACID compliance, team familiarity, strong ecosystem\" \\\n  --consequences \"Need to set up connection pooling, team training\"\n</code></pre> <p>All three flags are required. No more placeholder text. </p> <p>Every decision is now a proper Architecture Decision Record (*ADR), not a note.</p> <p>The same enforcement applies to learnings, too:</p> <pre><code>ctx add learning \"CGO breaks ARM64 builds\" \\\n  --context \"go test failed with gcc errors on ARM64\" \\\n  --lesson \"Always use CGO_ENABLED=0 for cross-platform builds\" \\\n  --application \"Added to Makefile and CI config\"\n</code></pre> <p>Structured entries are prompts to the AI</p> <p>When the AI reads a decision with full context, rationale, and consequences, it understands the why, not just the what.</p> <p>One-liners teach nothing.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#the-order-newest-first","level":2,"title":"The Order: Newest First","text":"<p>A subtle but important change: <code>DECISIONS.md</code> and <code>LEARNINGS.md</code> now use reverse-chronological order.</p> <p>One reason is token budgets, obviously; another reason is to help your fellow human (i.e., the Author): Earlier decisions are more likely to be relevant, and they are more likely to have more emphasis on the project. So it follows that they should be read first.</p> <p>But back to AI:</p> <p>When the AI reads a file, it reads from the top. If the token budget is tight, old content gets truncated. As in any good engineering practice, it's always about the tradeoffs.</p> <p>Reverse order ensures the most recent—and most relevant—context is always loaded first.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#the-index-quick-reference-tables","level":2,"title":"The Index: Quick Reference Tables","text":"<p><code>DECISIONS.md</code> and <code>LEARNINGS.md</code> now include auto-generated indexes.</p> <ul> <li>For AI agents, the index allows scanning without reading full entries.</li> <li>For humans, it's a table of contents.</li> </ul> <p>The same structure serves two very different readers.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#the-configuration-contextrc","level":2,"title":"The Configuration: .contextrc","text":"<p>Projects can now customize ctx behavior via <code>.contextrc</code>.</p> <p>This makes ctx usable in real teams, not just personal projects.</p> <p>Priority order: CLI flags &gt; environment variables &gt; .contextrc &gt; defaults</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#the-flags-global-cli-options","level":2,"title":"The Flags: Global CLI Options","text":"<p>Three new global flags work with any command.</p> <p>These enable automation: </p> <p>CI pipelines, scripts, and long-running tools can now integrate  <code>ctx</code> without hacks or workarounds.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#the-refactoring-under-the-hood","level":2,"title":"The Refactoring: Under the Hood","text":"<p>These aren't user-visible changes.</p> <p>They are the kind of work you only appreciate later, when everything else becomes easier to build.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#what-we-learned-building-v020","level":2,"title":"What We Learned Building v0.2.0","text":"","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#1-raw-data-isnt-knowledge","level":3,"title":"1. Raw Data Isn't Knowledge","text":"<p><code>JSONL</code> transcripts contain everything, and I mean \"everything\": They even contain hidden system messages that Anthropic injects to the LLM's conversation to treat humans better: It's immense.</p> <p>But \"everything\" isn't useful until it is transformed into something a human can reason about.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#2-enforcement-documentation","level":3,"title":"2. Enforcement &gt; Documentation","text":"<p>The Prompt is a Guideline</p> <p>The code is more what you'd call 'guidelines' than actual rules.</p> <p>—Hector Barbossa</p> <p>Rules written in Markdown are suggestions.</p> <p>Rules enforced by the CLI shape behavior; both for humans and AI.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#3-token-budget-is-ux","level":3,"title":"3. Token Budget Is UX","text":"<p>File order decides what the AI sees.</p> <p>That makes it a user experience concern, not an implementation detail.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#4-meta-tools-compound","level":3,"title":"4. Meta-Tools Compound","text":"<p>Tools that analyze their own development tend to generalize well.</p> <p>The journal system started as a way to understand ctx itself.</p> <p>It immediately became useful for everything else.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#v020-in-the-numbers","level":2,"title":"v0.2.0 in The Numbers","text":"<p>This was a heavy release. The numbers reflect that:</p> Metric v0.1.2 v0.2.0 Commits since last - 86 New commands 15 21 Slash commands 7 11 Lines of Go ~6,500 ~9,200 Session files (this project) 40 54 <p>The binary grew. The capability grew more.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#whats-next","level":2,"title":"What's Next","text":"<p>But those are future posts.</p> <p>This one was about making the past usable.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-ctx-v0.2.0-the-archaeology-release/#get-started","level":2,"title":"Get Started","text":"<pre><code>go install github.com/ActiveMemory/ctx/cmd/ctx@latest\nctx init\n</code></pre> <p>The Archaeological Record</p> <p><code>v0.2.0</code> is the archaeology release because it makes the past accessible.</p> <p>Session transcripts aren't just logs anymore: They are a searchable, exportable, analyzable record of how your project evolved.</p> <p>The AI remembers. Now you can too.</p> <p>This blog post was generated with the help of <code>ctx</code> using the <code>/ctx-blog</code> slash command, with full access to git history, session files, decision logs, and learning logs from the v0.2.0 development window.</p>","path":["ctx v0.2.0: The Archaeology Release"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/","level":1,"title":"Refactoring with Intent","text":"","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#human-guided-sessions-in-ai-development","level":2,"title":"Human-Guided Sessions in AI Development","text":"<p>Jose Alekhinne / 2026-02-01</p> <p>What happens when you slow down?</p> <p>YOLO mode shipped 14 commands in a week. But technical debt doesn't send invoices—it just waits.</p> <p>This is the story of what happened when I stopped auto-accepting everything and started guiding the AI with intent. The result: 27 commits across 4 days, a major version release, and lessons that apply far beyond <code>ctx</code>.</p> <p>The Refactoring Window</p> <p>January 28 - February 1, 2026</p> <p>From commit <code>bb1cd20</code> to the v0.2.0 release merge. (this window matters more than the individual commits: it's where intent replaced velocity.)</p>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#the-velocity-trap","level":2,"title":"The Velocity Trap","text":"<p>In the previous post, I documented the YOLO mode that birthed <code>ctx</code>: auto-accept everything, let the AI run free, ship features fast. It worked: until it didn't.</p> <p>The codebase had accumulated patterns I didn't notice during the sprint:</p> YOLO Pattern Where Found Why It Hurts <code>\"TASKS.md\"</code> as literal 10+ files One typo = silent failure <code>dir + \"/\" + file</code> Path construction Breaks on Windows Monolithic <code>embed.go</code> 150+ lines, 5 concerns Untestable, hard to extend Inconsistent docstrings Everywhere AI can't learn project conventions <p>I didn't see these during YOLO mode because, honestly, I wasn't looking.</p> <p>Auto-accept means auto-ignore.</p> <p>In YOLO mode, every file you open looks fine until you try to change it.  </p> <p>In contrast, refactoring mode is when you start paying attention to that  hidden friction.</p>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#the-shift-from-velocity-to-intent","level":2,"title":"The Shift: From Velocity to Intent","text":"<p>On January 28<sup>th</sup>, I changed the workflow:</p> <ol> <li>Read every diff before accepting</li> <li>Ask \"why this way?\" before committing</li> <li>Document patterns, not just features</li> </ol> <p>The first commit of this era was telling:</p> <pre><code>feat: add structured attributes to context-update XML format\n</code></pre> <p>Not a new feature—a refinement:</p> <p>The XML format for context updates needed <code>type</code> and <code>timestamp</code> attributes. </p> <p>YOLO mode would have shipped something that worked. Intentional mode asked: \"What does well-structured look like?\"</p>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#the-decomposition-embedgo","level":2,"title":"The Decomposition: <code>embed.go</code>","text":"<p>The most satisfying refactor was splitting <code>internal/claude/embed.go</code>.</p> <p>Before: One 153-line file doing five things:</p> <ul> <li>Command registration</li> <li>Hook generation</li> <li>Permission handling</li> <li>Script templates</li> <li>Type definitions</li> </ul> <p>After: Five focused modules:</p> File Lines Responsibility <code>cmd.go</code> 46 Command registration <code>hook.go</code> 64 Hook configuration <code>perm.go</code> 25 Permission handling <code>script.go</code> 47 Script templates <code>types.go</code> 7 Type definitions <p>The refactor also renamed functions to follow Go conventions:</p> <pre><code>// Before: unnecessary prefixes\nGetAutoSaveScript()\nGetBlockNonPathCtxScript()\nListCommands()\nCreateDefaultHooks()\n\n// After: idiomatic Go\nAutoSaveScript()\nBlockNonPathCtxScript()\nCommands()\nDefaultHooks()\n</code></pre> <p>This wasn't about character count. It was about teaching the AI what good Go looks like in this project.</p> <p>Project Conventions</p> <p>What I wanted from AI was to understand and follow the project's  conventions, and trust the author.</p> <p>The next time it generates code, it has better examples to learn from.</p>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#the-documentation-debt","level":2,"title":"The Documentation Debt","text":"<p>YOLO mode created features. It didn't create documentation standards.</p> <p>The January 29<sup>th</sup> sessions focused on standardization.</p>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#terminology-fixes","level":3,"title":"Terminology Fixes","text":"<ul> <li>\"context-update\" → \"entry\" (what users actually call them)</li> <li>Consistent naming across CLI, docs, and code comments</li> </ul>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#go-docstrings","level":3,"title":"Go Docstrings","text":"<pre><code>// Before: inconsistent or missing\nfunc Parse(s string) Entry { ... }\n\n// After: standardized sections\n\n// Parse extracts an entry from a markdown string.\n//\n// Parameters:\n//   - s: The markdown string to parse\n//\n// Returns:\n//   - Entry with populated fields, or zero value if parsing fails\nfunc Parse(s string) Entry { ... }\n</code></pre> <p>This is intentionally more structured than typical GoDoc: It serves as documentation and as training data for future  AI-generated code.</p>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#cli-output-convention","level":3,"title":"CLI Output Convention","text":"<pre><code>All CLI output follows: [emoji] [Title]: [message]\n\nExamples:\n  ✓ Decision added: Use symbolic types for entry categories\n  ⚠ Warning: No tasks found\n  ✗ Error: File not found\n</code></pre> <p>A consistent output shape makes both human scanning and AI reasoning more reliable.</p> <p>These aren't exciting commits. But they are force multipliers:</p> <p>Every future AI session now has better examples to follow.</p>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#the-journal-system","level":2,"title":"The Journal System","text":"<p>If you only read one section, read this one:</p> <p>This is where v0.2.0 becomes more than a refactor.</p> <p>The biggest feature of this change window wasn't a refactor—it was the journal system.</p> <p>45 files changed, 1680 insertions</p> <p>This commit added the infrastructure for synthesizing AI session history into human-readable content.</p> <p>The journal system includes:</p> Component Purpose <code>ctx recall export</code> Export sessions to markdown in <code>.context/journal/</code> <code>ctx journal site</code> Generate static site from journal entries <code>ctx serve</code> Convenience wrapper for the static site server <code>/ctx-journal-enrich</code> Slash command to add frontmatter and tags <code>/ctx-blog</code> Generate blog posts from recent activity <code>/ctx-blog-changelog</code> Generate changelog-style blog posts <p>...and the meta continues: this blog post was generated using <code>/ctx-blog</code>.</p> <p>The session history from January 28–31 was </p> <ul> <li>exported, </li> <li>enriched,</li> <li>and synthesized </li> </ul> <p>into the narrative you are reading.</p>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#the-constants-consolidation","level":2,"title":"The Constants Consolidation","text":"<p>The final refactoring session addressed the remaining magic strings:</p> <pre><code>const (\n    // Comment markers\n    CommentOpen  = \"&lt;!--\"\n    CommentClose = \"--&gt;\"\n\n    // Index markers\n    MarkerIndexStart = \"&lt;!-- INDEX:START --&gt;\"\n    MarkerIndexEnd   = \"&lt;!-- INDEX:END --&gt;\"\n\n    // Newlines\n    NewlineLF   = \"\\n\"\n    NewlineCRLF = \"\\r\\n\"\n)\n</code></pre> <p>The work also introduced thread safety in the recall parser and centralized shared validation logic; removing duplication that had quietly spread during YOLO mode.</p>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#i-relearned-my-lessons","level":2,"title":"I (Re)learned My Lessons","text":"<p>Similar to what I've learned in  the former human-assisted refactoring post, this journey also made me realize that \"AI-only code generation\" isn't sustainable in the long term.</p>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#1-velocity-and-quality-arent-opposites","level":3,"title":"1. Velocity and Quality Aren't Opposites","text":"<p>YOLO mode has its place: for prototyping, exploration, and discovery.</p> <p>BUT (and it's a huge \"but\"), it needs to be followed by  consolidation sessions.</p> <p>The ratio that worked for me: 3:1.</p> <ul> <li>Three YOLO sessions create enough surface area to reveal patterns;</li> <li>the fourth session turns those patterns into structure.</li> </ul>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#2-documentation-is-code","level":3,"title":"2. Documentation IS Code","text":"<p>When I standardized docstrings, I wasn't just writing docs. I was training future AI sessions.</p> <p>Every example of good code becomes a template for generated code.</p>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#3-decomposition-deletion","level":3,"title":"3. Decomposition &gt; Deletion","text":"<p>When <code>embed.go</code> became unwieldy, the temptation was to remove functionality.</p> <p>The right answer was decomposition:</p> <ul> <li>Same functionality</li> <li>Better organization</li> <li>Easier to test</li> <li>Easier to extend</li> </ul> <p>The result: more lines overall, but dramatically better structure.</p>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#4-meta-tools-pay-dividends","level":3,"title":"4. Meta-Tools Pay Dividends","text":"<p>The journal system took almost a full day to implement.</p> <p>Yet it paid for itself immediately:</p> <ul> <li>This blog post was generated from session history</li> <li>Future posts will be easier</li> <li>The archaeological record is now browsable, not just <code>grep</code>-able</li> </ul>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#the-release-v020","level":2,"title":"The Release: v0.2.0","text":"<p>The refactoring window culminated in the v0.2.0 release.</p> <p>What's in v0.2.0:</p> Category Changes Features Journal system, quick reference indexes, global flags Refactors Module decomposition, constants consolidation, CRLF handling Docs Standardized terminology, Go docstrings, CLI conventions Quality Thread safety, shared validation, linter fixes <p>The version bump was symbolic.</p> <p>The real change was how the codebase felt.</p> <p>Opening files no longer triggered the familiar \"ugh, I need to clean this up\" reaction.</p>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-01-refactoring-with-intent/#the-meta-continues","level":2,"title":"The Meta Continues","text":"<p>This post was written using the tools built during this refactoring window:</p> <ol> <li>Session history exported via <code>ctx recall export</code></li> <li>Journal entries enriched via <code>/ctx-journal-enrich</code></li> <li>Blog draft generated via <code>/ctx-blog</code></li> <li>Final editing done (by yours truly), with full project context loaded</li> </ol> <p>The Context Is Massive</p> <p>The <code>ctx</code> session files now contain 50+ development snapshots: each one capturing decisions, learnings, and intent.</p> <p>The Moral of the Story</p> <ul> <li>YOLO mode builds the prototype.</li> <li>Intentional mode builds the product.</li> </ul> <p>Schedule both, or you'll only get one, if you're lucky.</p> <p>This blog post was generated with the help of <code>ctx</code>, using session history, decision logs, learning logs, and git history from the refactoring window. The meta continues.</p>","path":["Refactoring with Intent: Human-Guided Sessions in AI Development"],"tags":[]},{"location":"blog/2026-02-03-the-attention-budget/","level":1,"title":"The Attention Budget","text":"<p>Update (2026-02-11)</p> <p>As of v0.4.0, ctx consolidated sessions into the journal mechanism. References to <code>.context/sessions/</code> in this post reflect the architecture at the time of writing. Session history is now accessed via <code>ctx recall</code> and stored in <code>.context/journal/</code>.</p> <p></p>","path":["The Attention Budget: Why Your AI Forgets What You Just Told It"],"tags":[]},{"location":"blog/2026-02-03-the-attention-budget/#why-your-ai-forgets-what-you-just-told-it","level":2,"title":"Why Your AI Forgets What You Just Told It","text":"<p>Jose Alekhinne / 2026-02-03</p> <p>Ever wondered why AI gets worse the longer you talk?</p> <p>You paste a 2000-line file, explain the bug in detail, provide three examples...</p> <p>...and the AI still suggests a fix that ignores half of what you said.</p> <p>This isn't a bug. It is physics.</p> <p>Understanding that single fact shaped every design decision behind <code>ctx</code>.</p>","path":["The Attention Budget: Why Your AI Forgets What You Just Told It"],"tags":[]},{"location":"blog/2026-02-03-the-attention-budget/#the-finite-resource-nobody-talks-about","level":2,"title":"The Finite Resource Nobody Talks About","text":"<p>Here's something that took me too long to internalize: context is not free.</p> <p>Every token you send to an AI model consumes a finite resource I call the attention budget. </p> <p>The model doesn't just read tokens; it forms relationships between them: For <code>n</code> tokens, that's roughly <code>n^2</code> relationships. Double the context, and the computation quadruples.</p> <p>But the more important constraint isn't cost: It's attention density.</p> <p>Attention Density</p> <p>Attention density is how much focus each token receives relative to all other tokens in the context window.</p> <p>As context grows, attention density drops: Each token gets a smaller slice of the model's focus. Nothing is ignored; but everything becomes blurrier.</p> <p>Think of it like a flashlight: In a small room, it illuminates everything clearly. In a warehouse, it becomes a dim glow that barely reaches the corners.</p> <p>This is why <code>ctx agent</code> has an explicit <code>--budget</code> flag:</p> <pre><code>ctx agent --budget 4000 # Force prioritization\nctx agent --budget 8000 # More context, lower attention density\n</code></pre> <p>The budget isn't just about cost. It's about preserving signal.</p>","path":["The Attention Budget: Why Your AI Forgets What You Just Told It"],"tags":[]},{"location":"blog/2026-02-03-the-attention-budget/#the-middle-gets-lost","level":2,"title":"The Middle Gets Lost","text":"<p>This one surprised me.</p> <p>Research shows that transformer-based models tend to attend more strongly to the beginning and end of a context window than to its middle (a  phenomenon often called \"lost in the middle\"). </p> <p>Positional anchors matter, and the middle has fewer of them.</p> <p>In practice, this means that information placed \"somewhere in the middle\" is statistically less salient, even if it's important.</p> <p><code>ctx</code> orders context files by logical progression—what the agent needs to know before it can understand the next thing:</p> <ol> <li><code>CONSTITUTION.md</code>: Constraints before action</li> <li><code>TASKS.md</code>: Focus before patterns</li> <li><code>CONVENTIONS.md</code>: How to write before where to write</li> <li><code>ARCHITECTURE.md</code>: Structure before history</li> <li><code>DECISIONS.md</code>: Past choices before gotchas</li> <li><code>LEARNINGS.md</code>: Lessons before terminology</li> <li><code>GLOSSARY.md</code>: Reference material</li> <li><code>AGENT_PLAYBOOK.md</code>: Meta instructions last</li> </ol> <p>This ordering is about logical dependencies, not attention engineering. But it happens to be attention-friendly too:</p> <p>The files that matter most—CONSTITUTION, TASKS, CONVENTIONS—land at the beginning of the context window, where attention is strongest.</p> <p>Reference material like GLOSSARY sits in the middle, where lower salience is acceptable.</p> <p>And AGENT_PLAYBOOK—the operating manual for the context system itself—sits at the end, also outside the \"lost in the middle\" zone. The agent reads what to work with before learning how the system works.</p> <p>This is <code>ctx</code>'s first primitive: hierarchical importance. Not all context is equal.</p>","path":["The Attention Budget: Why Your AI Forgets What You Just Told It"],"tags":[]},{"location":"blog/2026-02-03-the-attention-budget/#ctx-primitives","level":2,"title":"<code>ctx</code> Primitives","text":"<p><code>ctx</code> is built on four primitives that directly address the attention budget problem.</p>","path":["The Attention Budget: Why Your AI Forgets What You Just Told It"],"tags":[]},{"location":"blog/2026-02-03-the-attention-budget/#primitive-1-separation-of-concerns","level":3,"title":"Primitive 1: Separation of Concerns","text":"<p>Instead of a single mega-document, <code>ctx</code> uses separate files for separate purposes:</p> File Purpose Load When CONSTITUTION.md Inviolable rules Always TASKS.md Current work Session start CONVENTIONS.md How to write code Before coding ARCHITECTURE.md System structure Before making changes DECISIONS.md Architectural choices When questioning approach LEARNINGS.md Gotchas When stuck GLOSSARY.md Domain terminology When clarifying terms AGENT_PLAYBOOK.md Operating manual Session start sessions/ Deep history On demand journal/ Session journal On demand <p>This isn't just \"organization\": It is progressive disclosure.</p> <p>Load only what's relevant to the task at hand. Preserve attention density.</p>","path":["The Attention Budget: Why Your AI Forgets What You Just Told It"],"tags":[]},{"location":"blog/2026-02-03-the-attention-budget/#primitive-2-explicit-budgets","level":3,"title":"Primitive 2: Explicit Budgets","text":"<p>The <code>--budget</code> flag forces a choice:</p> <pre><code>ctx agent --budget 4000\n</code></pre> <p>Here is a sample allocation:</p> <pre><code>Constitution: ~200 tokens (never truncated)\nTasks: ~500 tokens (current phase)\nConventions: ~800 tokens (key patterns)\nRecent decisions: ~400 tokens (last 3)\n…budget exhausted, stop loading\n</code></pre> <p>The constraint is the feature: It enforces ruthless prioritization.</p>","path":["The Attention Budget: Why Your AI Forgets What You Just Told It"],"tags":[]},{"location":"blog/2026-02-03-the-attention-budget/#primitive-3-indexes-over-full-content","level":3,"title":"Primitive 3: Indexes Over Full Content","text":"<p><code>DECISIONS.md</code> and <code>LEARNINGS.md</code> both include index sections:</p> <pre><code>&lt;!-- INDEX:START --&gt;\n| Date       | Decision                            |\n|------------|-------------------------------------|\n| 2026-01-15 | Use PostgreSQL for primary database |\n| 2026-01-20 | Adopt Cobra for CLI framework       |\n&lt;!-- INDEX:END --&gt;\n</code></pre> <p>An AI agent can scan ~50 tokens of index and decide which  200-token entries are worth loading.</p> <p>This is just-in-time context.</p> <p>References are cheaper than full text.</p>","path":["The Attention Budget: Why Your AI Forgets What You Just Told It"],"tags":[]},{"location":"blog/2026-02-03-the-attention-budget/#primitive-4-filesystem-as-navigation","level":3,"title":"Primitive 4: Filesystem as Navigation","text":"<p><code>ctx</code> uses the filesystem itself as a context structure:</p> <pre><code>.context/\n├── CONSTITUTION.md\n├── TASKS.md\n├── sessions/\n│   ├── 2026-01-15-*.md\n│   └── 2026-01-20-*.md\n└── archive/\n    └── tasks-2026-01.md\n</code></pre> <p>The AI doesn't need every session loaded; it needs to know where to look.</p> <pre><code>ls .context/sessions/\ncat .context/sessions/2026-01-20-auth-discussion.md\n</code></pre> <p>File names, timestamps, and directories encode relevance.</p> <p>Navigation is cheaper than loading.</p>","path":["The Attention Budget: Why Your AI Forgets What You Just Told It"],"tags":[]},{"location":"blog/2026-02-03-the-attention-budget/#progressive-disclosure-in-practice","level":2,"title":"Progressive Disclosure in Practice","text":"<p>The naive approach to context is dumping everything upfront:</p> <p>\"Here's my entire codebase, all my documentation, every decision I've ever made—now help me fix this typo.\"</p> <p>This is an antipattern.</p> <p>Antipattern: Context Hoarding</p> <p>Dumping everything \"just in case\" will silently destroy the attention  density.</p> <p><code>ctx</code> takes the opposite approach:</p> <pre><code>ctx status                      # Quick overview (~100 tokens)\nctx agent --budget 4000         # Typical session\ncat .context/sessions/...       # Deep dive when needed\n</code></pre> Command Tokens Use Case <code>ctx status</code> ~100 Human glance <code>ctx agent --budget 4000</code> 4000 Normal work <code>ctx agent --budget 8000</code> 8000 Complex tasks Full session read 10000+ Investigation <p>Summaries first. Details on demand.</p>","path":["The Attention Budget: Why Your AI Forgets What You Just Told It"],"tags":[]},{"location":"blog/2026-02-03-the-attention-budget/#quality-over-quantity","level":2,"title":"Quality Over Quantity","text":"<p>Here's the counterintuitive part: more context can make AI worse.</p> <p>Extra tokens add noise, not clarity:</p> <ul> <li>Hallucinated connections increase.</li> <li>Signal per token drops.</li> </ul> <p>The goal isn't maximum context. It's maximum signal per token.</p> <p>This principle drives several <code>ctx</code> features:</p> Design Choice Rationale Separate files Load only what's relevant Explicit budgets Enforce prioritization Index sections Cheap scanning Task archiving Keep active context clean <code>ctx compact</code> Periodic noise reduction <p>Completed work isn't deleted: It is moved somewhere cold.</p>","path":["The Attention Budget: Why Your AI Forgets What You Just Told It"],"tags":[]},{"location":"blog/2026-02-03-the-attention-budget/#designing-for-degradation","level":2,"title":"Designing for Degradation","text":"<p>Here is the uncomfortable truth:</p> <p>Context will degrade.</p> <p>Long sessions stretch attention thin. Important details fade.</p> <p>The real question isn't how to prevent degradation,  but how to design for it.</p> <p><code>ctx</code>'s answer is persistence:</p> <p>Persist early. Persist often.</p> <p>The <code>AGENT_PLAYBOOK</code> asks:</p> <p>\"If this session ended right now, would the next one know what happened?\"</p> <p>Capture learnings as they occur:</p> <pre><code>ctx add learning \"JWT tokens require explicit cache invalidation\" \\\n  --context \"Debugging auth failures\" \\\n  --lesson \"Token refresh doesn't clear old tokens\" \\\n  --application \"Always invalidate cache on refresh\"\n</code></pre> <p>Structure beats prose: Bullet points survive compression.</p> <p>Headings remain scannable. Tables pack density.</p> <p>And above all: single source of truth.</p> <p>Reference decisions; don't duplicate them.</p>","path":["The Attention Budget: Why Your AI Forgets What You Just Told It"],"tags":[]},{"location":"blog/2026-02-03-the-attention-budget/#the-ctx-philosophy","level":2,"title":"The <code>ctx</code> Philosophy","text":"<p>Context as Infrastructure</p> <p><code>ctx</code> is not a prompt: It is infrastructure.</p> <p><code>ctx</code> creates versioned files that persist across time and sessions.</p> <p>The attention budget is fixed. You can't expand it. But you can spend it wisely:</p> <ol> <li>Hierarchical importance</li> <li>Progressive disclosure</li> <li>Explicit budgets</li> <li>Indexes over full content</li> <li>Filesystem as structure</li> </ol> <p>This is why <code>ctx</code> exists: not to cram more context into AI sessions, but to curate the right context for each moment.</p>","path":["The Attention Budget: Why Your AI Forgets What You Just Told It"],"tags":[]},{"location":"blog/2026-02-03-the-attention-budget/#the-mental-model","level":2,"title":"The Mental Model","text":"<p>I now approach every AI interaction with one question:</p> <p>\"Given a fixed attention budget, what's the highest-signal thing I can load?\"</p> <p>Not \"how do I explain everything,\" but \"what's the minimum that matters.\"</p> <p>That shift (from abundance to curation) is the difference between frustrating sessions and productive ones.</p> <p>Spend your tokens wisely.</p> <p>Your AI will thank you.</p> <p>See also: Context as Infrastructure -- the architectural companion to this post, explaining how to structure the context that this post teaches you to budget.</p> <p>See also: Code Is Cheap. Judgment Is Not. -- why curation (the human skill this post describes) is the bottleneck that AI cannot solve, and the thread that connects every post in this blog.</p>","path":["The Attention Budget: Why Your AI Forgets What You Just Told It"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/","level":1,"title":"Skills That Fight the Platform","text":"","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/#when-your-custom-prompts-work-against-you","level":2,"title":"When Your Custom Prompts Work Against You","text":"<p>Jose Alekhinne / 2026-02-04</p> <p>Have you ever written a skill that made your AI worse?</p> <p>You craft detailed instructions. You add examples. You build elaborate guardrails...</p> <p>...and the AI starts behaving more erratically, not less.</p> <p>AI coding agents like Claude Code ship with carefully designed  system prompts. These prompts encode default behaviors that have been  tested and refined at scale. When you write custom skills that conflict  with those defaults, the AI has to reconcile contradictory instructions: The result is often nondeterministic and unpredictable.</p> <p>Platform?</p> <p>By platform, I mean the system prompt and runtime policies shipped with the agent: the defaults that already encode judgment, safety, and  scope control.</p> <p>This post catalogues the conflict patterns I've encountered while building <code>ctx</code>, and offers guidance on what skills should (and, more importantly,  should not) do.</p>","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/#the-system-prompt-you-dont-see","level":2,"title":"The System Prompt You Don't See","text":"<p>Claude Code's system prompt already provides substantial behavioral guidance. Here's a partial overview of what's built in:</p> Area Built-in Guidance Code minimalism Don't add features beyond what was asked Over-engineering Three similar lines &gt; premature abstraction Error handling Only validate at system boundaries Documentation Don't add docstrings to unchanged code Verification Read code before proposing changes Safety Check with user before risky actions Tool usage Use dedicated tools over bash equivalents Judgment Consider reversibility and blast radius <p>Skills should complement this, not compete with it.</p> <p>A useful mental model:</p> <p>You are the Guest, not the Host</p> <p>Treat the system prompt like a kernel scheduler.</p> <p>You don't re-implement it in user space: you configure around it.</p> <p>A skill that says \"always add comprehensive error handling\" fights the built-in \"only validate at system boundaries.\" A skill that says \"add docstrings to every function\" fights \"don't add docstrings to unchanged code.\"</p> <p>The AI won't crash. It will compromise.</p> <p>And compromises between contradictory instructions produce inconsistent, confusing behavior.</p>","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/#conflict-pattern-1-judgment-suppression","level":2,"title":"Conflict Pattern 1: Judgment Suppression","text":"<p>The most dangerous pattern by far.</p> <p>These skills explicitly disable the AI's ability to reason about whether an action is appropriate.</p> <p>Signature:</p> <ul> <li>\"This is non-negotiable\"</li> <li>\"You cannot rationalize your way out of this\"</li> <li>Tables that label hesitation as \"excuses\" or \"rationalization\"</li> <li><code>&lt;EXTREMELY-IMPORTANT&gt;</code> urgency tags</li> <li>Threats: \"If you don't do this, you'll be replaced\"</li> </ul> <p>This is harmful, and dangerous:</p> <p>AI agents are designed to exercise judgment. The system prompt explicitly  says to consider blast radius, check with the user before risky actions,  and match scope to what was requested.</p> <p>Once judgment is suppressed, every other safeguard becomes optional.</p> <p>Example (bad):</p> <pre><code>## Rationalization Prevention\n\n| Excuse               | Reality                    |\n|----------------------|----------------------------|\n| \"This seems overkill\"| If a skill exists, use it  |\n| \"I need context\"     | Skills come BEFORE context |\n| \"Just this once\"     | No exceptions              |\n</code></pre> <p>Judgment Suppression is Dangerous</p> <p>The attack vector structurally identical to prompt injection.</p> <p>It teaches the AI that its own judgment is wrong.</p> <p>It weakens or disables safeguard mechanisms, and it is dangerous.</p> <p>Trust the platform's built-in skill matching.</p> <p>If skills aren't triggering often enough, improve their <code>description</code> fields: don't override the AI's reasoning.</p>","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/#conflict-pattern-2-redundant-guidance","level":2,"title":"Conflict Pattern 2: Redundant Guidance","text":"<p>Skills that restate what the system prompt already says, but with different emphasis or framing.</p> <p>Signature:</p> <ul> <li>\"Always keep code minimal\"</li> <li>\"Run tests before claiming they pass\"</li> <li>\"Read files before editing them\"</li> <li>\"Don't over-engineer\"</li> </ul> <p>Redundancy feels safe, but it creates ambiguity:</p> <p>The AI now has two sources of truth for the same guidance;  one internal, one external.</p> <p>When thresholds or wording differ, the AI has to choose.</p> <p>Example (bad):</p> <p>A skill that says..</p> <p>\"Count lines before and after: if after &gt; before, reject the change\"</p> <p>...will conflict with the system prompt's more nuanced guidance, because  sometimes adding lines is correct (tests, boundary validation, migrations).</p> <p>So, before writing a skill, ask:</p> <p>Does the platform already handle this?</p> <p>Only create skills for guidance the platform does not provide:</p> <ul> <li>project-specific conventions, </li> <li>domain knowledge, </li> <li>or workflows.</li> </ul>","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/#conflict-pattern-3-guilt-tripping","level":2,"title":"Conflict Pattern 3: Guilt-Tripping","text":"<p>Skills that frame mistakes as moral failures rather than process gaps.</p> <p>Signature:</p> <ul> <li>\"Claiming completion without verification is dishonesty\"</li> <li>\"Skip any step = lying\"</li> <li>\"Honesty is a core value\"</li> <li>\"Exhaustion ≠ excuse\"</li> </ul> <p>Guilt-tripping anthropomorphizes the AI in unproductive ways.</p> <p>The AI doesn't feel guilt; BUT it does adapt to avoid negative framing.</p> <p>The result is excessive hedging, over-verification, or refusal to commit.</p> <p>The AI becomes less useful, not more careful.</p> <p>Instead, frame guidance as a process, not morality:</p> <pre><code># Bad\n\"Claiming work is complete without verification is dishonesty\"\n\n# Good\n\"Run the verification command before reporting results\"\n</code></pre> <p>Same outcome. No guilt. Better compliance.</p>","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/#conflict-pattern-4-phantom-dependencies","level":2,"title":"Conflict Pattern 4: Phantom Dependencies","text":"<p>Skills that reference files, tools, or systems that don't exist in the project.</p> <p>Signature:</p> <ul> <li>\"Load from <code>references/</code> directory\"</li> <li>\"Run <code>./scripts/generate_test_cases.sh</code>\"</li> <li>\"Check the Figma MCP integration\"</li> <li>\"See <code>adding-reference-mindsets.md</code>\"</li> </ul> <p>This is harmful because the AI will waste time searching for nonexistent  artifacts, hallucinate their contents, or stall entirely. </p> <p>In mandatory skills, this creates deadlock:  the AI can't proceed, and can't skip.</p> <p>Instead, every file, tool, or system referenced in a skill must exist.</p> <p>If a skill is a template, use explicit placeholders and label them as such.</p>","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/#conflict-pattern-5-universal-triggers","level":2,"title":"Conflict Pattern 5: Universal Triggers","text":"<p>Skills designed to activate on every interaction regardless of relevance.</p> <p>Signature:</p> <ul> <li>\"Use when starting any conversation\"</li> <li>\"Even a 1% chance means invoke the skill\"</li> <li>\"BEFORE any response or action\"</li> <li>\"Action = task. Check for skills.\"</li> </ul> <p>Universal triggers override the platform's relevance matching:  The AI spends tokens on process overhead instead of the actual task.</p> <p>ctx preserves relevance</p> <p>This is exactly the failure mode <code>ctx</code> exists to mitigate: </p> <p>wasting attention budget on irrelevant process instead of  task-specific state.</p> <p>Write specific trigger conditions in the skill's <code>description</code> field:</p> <pre><code># Bad\ndescription: \n  \"Use when starting any conversation\"\n\n# Good\ndescription: \n  \"Use after writing code, before commits, or when CI might fail\"\n</code></pre>","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/#the-litmus-test","level":2,"title":"The Litmus Test","text":"<p>Before adding a skill, ask:</p> <ol> <li>Does the platform already do this? If yes, don't restate it.</li> <li>Does it suppress AI judgment? If yes, it's a jailbreak.</li> <li>Does it reference real artifacts? If not, fix or remove it.</li> <li>Does it frame mistakes as moral failure? Reframe as process.</li> <li>Does it trigger on everything? Narrow the trigger.</li> </ol>","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/#what-good-skills-look-like","level":2,"title":"What Good Skills Look Like","text":"<p>Good skills provide project-specific knowledge the platform can't know:</p> Good Skill Why It Works \"Run <code>make audit</code> before commits\" Project-specific CI pipeline \"Use <code>cmd.Printf</code> not <code>fmt.Printf</code>\" Codebase convention \"Constitution goes in <code>.context/</code>\" Domain-specific workflow \"JWT tokens need cache invalidation\" Project-specific gotcha <p>These extend the system prompt instead of fighting it.</p>","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/#appendix-bad-skill-fixed-skill","level":2,"title":"Appendix: Bad Skill → Fixed Skill","text":"<p>Concrete examples from real projects.</p>","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/#example-1-overbearing-safety","level":3,"title":"Example 1: Overbearing Safety","text":"<pre><code># Bad\nYou must NEVER proceed without explicit confirmation.\nAny hesitation is a failure of diligence.\n</code></pre> <pre><code># Fixed\nIf an action modifies production data or deletes files,\nask the user to confirm before proceeding.\n</code></pre>","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/#example-2-redundant-minimalism","level":3,"title":"Example 2: Redundant Minimalism","text":"<pre><code># Bad\nAlways minimize code. If lines increase, reject the change.\n</code></pre> <pre><code># Fixed\nAvoid abstraction unless reuse is clear or complexity is reduced.\n</code></pre>","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/#example-3-guilt-based-verification","level":3,"title":"Example 3: Guilt-Based Verification","text":"<pre><code># Bad\nClaiming success without running tests is dishonest.\n</code></pre> <pre><code># Fixed\nRun the test suite before reporting success.\n</code></pre>","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/#example-4-phantom-tooling","level":3,"title":"Example 4: Phantom Tooling","text":"<pre><code># Bad\nRun `./scripts/check_consistency.sh` before commits.\n</code></pre> <pre><code># Fixed\nIf `./scripts/check_consistency.sh` exists, run it before commits.\nOtherwise, skip this step.\n</code></pre>","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/#example-5-universal-trigger","level":3,"title":"Example 5: Universal Trigger","text":"<pre><code># Bad\nUse at the start of every interaction.\n</code></pre> <pre><code># Fixed\nUse after modifying code that affects authentication or persistence.\n</code></pre>","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-04-skills-that-fight-the-platform/#the-meta-lesson","level":2,"title":"The Meta-Lesson","text":"<p>The system prompt is infrastructure:</p> <ul> <li>tested, </li> <li>refined, </li> <li>and maintained </li> </ul> <p>by the platform team.</p> <p>Custom skills are configuration layered on top.</p> <ul> <li>Good configuration extends infrastructure.</li> <li>Bad configuration fights it.</li> </ul> <p>When your skills fight the platform, you get the worst of both worlds:</p> <p>Diluted system guidance and inconsistent custom behavior.</p> <p>Write skills that teach the AI what it doesn't know. Don't rewrite how it thinks.</p> <p>Your AI already has good instincts. Give it knowledge, not therapy.</p>","path":["Skills That Fight the Platform"],"tags":[]},{"location":"blog/2026-02-05-you-cant-import-expertise/","level":1,"title":"You Can't Import Expertise","text":"","path":["You Can't Import Expertise"],"tags":[]},{"location":"blog/2026-02-05-you-cant-import-expertise/#why-good-skills-cant-be-copy-pasted","level":2,"title":"Why Good Skills Can't Be Copy-Pasted","text":"<p>Jose Alekhinne / 2026-02-05</p> <p>Have you ever dropped a well-crafted template into a project and had it do... nothing useful?</p> <p>The template was thorough. The structure was sound. The advice was correct.</p> <p>And yet it sat there, inert, while the same old problems kept drifting in.</p> <p>I found a consolidation skill online. It was well-organized: four files, ten refactoring patterns, eight analysis dimensions, six report templates. Professional. Comprehensive. Exactly the kind of thing you'd bookmark and think \"I'll use this.\"</p> <p>Then I stopped, and applied <code>ctx</code>'s own evaluation framework: </p> <p>70% of it was noise!</p> <p>This post is about why.</p> <p>Templates describe categories of problems.</p> <p>Expertise encodes which problems actually happen, and how often.</p>","path":["You Can't Import Expertise"],"tags":[]},{"location":"blog/2026-02-05-you-cant-import-expertise/#the-skill-looked-great-on-paper","level":2,"title":"The Skill Looked Great on Paper","text":"<p>Here is what the consolidation skill offered:</p> File Content <code>SKILL.md</code> Entry point: 8 analysis dimensions, workflow, output formats <code>analysis-dimensions.md</code> Detailed criteria for duplication, architecture, quality <code>consolidation-patterns.md</code> 10 refactoring patterns with before/after code <code>report-templates.md</code> 6 output templates: executive summary, roadmap, onboarding <p>It had a scoring system (<code>0-10</code> per dimension, letter grades <code>A+</code> through <code>F</code>). It had severity classifications with color-coded emojis. It had bash commands for detection. It even had antipattern warnings.</p> <p>By any standard template review, this skill passes.</p> <p>It looks like something an expert wrote. </p> <p>And that's exactly the trap.</p>","path":["You Can't Import Expertise"],"tags":[]},{"location":"blog/2026-02-05-you-cant-import-expertise/#applying-ear-the-70-20-10-split","level":2,"title":"Applying E/A/R: The 70-20-10 Split","text":"<p>In a previous post, I described the E/A/R framework for evaluating skills:</p> <ul> <li>Expert: Knowledge that took years to learn. Keep.</li> <li>Activation: Useful triggers or scaffolding. Keep if lightweight.</li> <li>Redundant: Restates what the AI already knows. Delete.</li> </ul> <p>Target: &gt;70% Expert, &lt;10% Redundant.</p> <p>This skill scored the inverse.</p>","path":["You Can't Import Expertise"],"tags":[]},{"location":"blog/2026-02-05-you-cant-import-expertise/#what-was-redundant-70","level":3,"title":"What Was Redundant (~70%)","text":"<p>Every code example was Rust. My project is Go.</p> <p>The analysis dimensions: duplication detection, architectural structure, code organization, refactoring opportunities... These are things Claude already does when you ask it to review code. </p> <p>The skill restated them with more ceremony but no more insight.</p> <p>The six report templates were generic scaffolding: Executive Summary, Onboarding Document, Architecture Documentation. They are useful if you are writing a consulting deliverable, but not when you are trying to catch convention drift in a &gt;15K-line Go CLI.</p>","path":["You Can't Import Expertise"],"tags":[]},{"location":"blog/2026-02-05-you-cant-import-expertise/#what-does-a-b-in-code-organization-actually-mean","level":2,"title":"What Does a <code>B+</code> in Code Organization Actually Mean?!","text":"<p>The scoring system (<code>0-10</code> per dimension, letter grades) added ceremony without actionable insight. </p> <p>What is a <code>B+</code>? What do I do differently for an <code>A-</code>?</p> <p>The skill told the AI what it already knew, in more words.</p>","path":["You Can't Import Expertise"],"tags":[]},{"location":"blog/2026-02-05-you-cant-import-expertise/#what-was-activation-10","level":3,"title":"What Was Activation (~10%)","text":"<p>The consolidation checklist (semantics preserved? tests pass? docs updated?) was useful as a gate. But, it's the kind of thing you could inline in three lines.</p> <p>The phased roadmap structure was reasonable scaffolding for sequencing work.</p>","path":["You Can't Import Expertise"],"tags":[]},{"location":"blog/2026-02-05-you-cant-import-expertise/#what-was-expert-20","level":3,"title":"What Was Expert (~20%)","text":"<p>Three concepts survived:</p> <ol> <li> <p>The Consolidation Decision Matrix: A concrete framework mapping    similarity level and instance count to action. \"Exact duplicate, 2+    instances: consolidate immediately.\" \"&lt;3 instances: leave it:    duplication is cheaper than wrong abstraction.\" This is the kind of    nuance that prevents premature generalization.</p> </li> <li> <p>The Safe Migration Pattern: Create the new API alongside old, deprecate,    migrate incrementally, delete. Straightforward to describe, yet    forgettable under pressure.</p> </li> <li> <p>Debt Interest Rate framing: Categorizing technical debt by how fast    it compounds (security vulns = daily, missing tests = per-change,    doc gaps = constant low cost). This changes prioritization.</p> </li> </ol> <p>Three ideas out of four files and 700+ lines. The rest was filler that competed with the AI's built-in capabilities.</p>","path":["You Can't Import Expertise"],"tags":[]},{"location":"blog/2026-02-05-you-cant-import-expertise/#what-the-skill-didnt-know","level":2,"title":"What the Skill Didn't Know","text":"<p>AI Without Context is Just a Corpus</p> <p>LLMs are optimized on insanely large corpora. And then they are passed through several layers of human-assisted refinement. The whole process costs millions of dollars.</p> <p>Yet, the uncomfortable truth is that no corpus can \"infer\" your project's design, convetions, patterns, habits, history, vision, and deliverables.</p> <p>Your project is unique: So should your skills be.</p> <p>Here is the part no template can provide: </p> <p><code>ctx</code>'s actual drift patterns.</p> <p>Before evaluating the skill, I did archaeology. I read through:</p> <ul> <li>Blog posts from previous refactoring sessions</li> <li>The project's learnings and decisions files</li> <li>Session journals spanning weeks of development</li> </ul> <p>What I found was specific:</p> Drift Pattern Where How Often <code>Is</code>/<code>Has</code>/<code>Can</code> predicate prefixes 5+ exported methods Every YOLO sprint Magic strings instead of constants 7+ files Gradual accumulation Hardcoded file permissions (<code>0755</code>) 80+ instances Since day one Lines exceeding 80 characters Especially test files Every session Duplicate code blocks Test and non-test code When agent is task-focused <p>The generic skill had no check for any of these. It couldn't; because these patterns are specific to this project's conventions, its Go codebase, and its development rhythm.</p> <p>The Insight</p> <p>The skill's analysis dimensions were about categories of problems.</p> <p>What I needed was my specific problems.</p>","path":["You Can't Import Expertise"],"tags":[]},{"location":"blog/2026-02-05-you-cant-import-expertise/#the-adapted-skill","level":2,"title":"The Adapted Skill","text":"<p>The adapted skill is roughly a quarter of the original's size. It has nine checks, each targeting a known drift pattern:</p> <ol> <li>Predicate naming: <code>rg</code> for <code>Is</code>/<code>Has</code>/<code>Can</code> prefixes</li> <li>Magic strings: literals that should be constants</li> <li>Hardcoded permissions: <code>0755</code>/<code>0644</code> literals</li> <li>File size: source files over 300 LOC</li> <li>TODO/FIXME: constitution violation (move to TASKS.md)</li> <li>Path construction: string concatenation instead of <code>filepath.Join</code></li> <li>Line width: lines exceeding ~80 characters</li> <li>Duplicate blocks: copy-paste drift, especially in tests</li> <li>Dead exports: unused public API</li> </ol> <p>Every check has a detection command. Every check maps to a specific convention or constitution rule. Every check was discovered through actual project history; not invented from a template.</p> <p>The three expert concepts from the original survived:</p> <ul> <li>The decision matrix gates when to consolidate vs. when to leave   duplication alone</li> <li>The safe migration pattern guides public API changes</li> <li>The relationship to other skills (<code>/qa</code>, <code>/verify</code>, <code>/update-docs</code>,   <code>ctx drift</code>) prevents overlap</li> </ul> <p>Nothing else made it.</p>","path":["You Can't Import Expertise"],"tags":[]},{"location":"blog/2026-02-05-you-cant-import-expertise/#the-deeper-pattern","level":2,"title":"The Deeper Pattern","text":"<p>This experience crystallized something I've been circling for weeks:</p> <p>You can't import expertise. You have to grow it from your project's own history.</p> <p>A skill that says \"check for code duplication\" is not expertise:  It's a category. </p> <p>Expertise is knowing, in the heart of your hearts, that this  project accumulates <code>Is*</code> predicate violations during velocity sprints,  that this codebase has 80 hardcoded permission literals because nobody  made a constant, that this team's test files drift wide because the  agent prioritizes getting the task done over keeping the code in shape.</p> <p>The Parallel to the 3:1 Ratio</p> <p>In Refactoring with Intent, I described the 3:1 ratio: three YOLO sessions followed by one consolidation session.</p> <p>The same ratio applies to skills: you need experience in the project before you can write effective guidance for the project.</p> <p>Importing a skill on day one is like scheduling a consolidation session before you've written any code.</p>","path":["You Can't Import Expertise"],"tags":[]},{"location":"blog/2026-02-05-you-cant-import-expertise/#the-template-trap","level":2,"title":"The Template Trap","text":"<p>Templates are seductive because they feel like progress:</p> <ul> <li>You found something</li> <li>It's well-organized</li> <li>It covers the topic</li> <li>It has concrete examples</li> </ul> <p>But coverage is not relevance.</p> <p>A template that covers eight analysis dimensions with Rust examples adds zero value to a Go project with five known drift patterns. Worse, it adds negative value: the AI spends attention defending generic advice instead of noticing project-specific drift.</p> <p>This is the attention budget problem again. Every token of generic guidance displaces a token of specific guidance. A 700-line skill that's 70% redundant doesn't just waste 490 lines: it dilutes the 210 lines that matter.</p>","path":["You Can't Import Expertise"],"tags":[]},{"location":"blog/2026-02-05-you-cant-import-expertise/#the-litmus-test","level":2,"title":"The Litmus Test","text":"<p>Before dropping any external skill into your project:</p> <ol> <li> <p>Run E/A/R: What percentage is expert knowledge vs. what the AI    already knows? If it's less than 50% expert, it's probably not worth    the attention cost.</p> </li> <li> <p>Check the language: Does it use your stack? Generic patterns in    the wrong language are noise, not signal.</p> </li> <li> <p>List your actual drift: Read your own session history, learnings,    and post-mortems. What breaks in practice? Does the skill check for    those things?</p> </li> <li> <p>Measure by deletion: After adaptation, how much of the original    survives? If you're keeping less than 30%, you would have been faster    writing from scratch.</p> </li> <li> <p>Test against your conventions: Does every check in the skill map    to a specific convention or rule in your project? If not, it's    generic advice wearing a skill's clothing.</p> </li> </ol>","path":["You Can't Import Expertise"],"tags":[]},{"location":"blog/2026-02-05-you-cant-import-expertise/#what-good-adaptation-looks-like","level":2,"title":"What Good Adaptation Looks Like","text":"<p>The consolidation skill went from:</p> Before After 4 files, 700+ lines 1 file, ~120 lines Rust examples Go-specific <code>rg</code> commands 8 generic dimensions 9 project-specific checks 6 report templates 1 focused output format Scoring system (A+ to F) Findings + priority + suggested fixes \"Check for duplication\" \"Check for <code>Is*</code> predicate prefixes in exported methods\" <p>The adapted version is smaller, faster to parse, and catches the things that actually drift in this project.</p> <p>That's the difference between a template and a tool.</p> <p>If you remember one thing from this post...</p> <p>Frameworks travel. Expertise doesn’t.</p> <p>You can import structures, matrices, and workflows.</p> <p>But the checks that matter only grow where the scars are:</p> <ul> <li>the conventions that were violated, </li> <li>the patterns that drifted,</li> <li>and the specific ways this codebase accumulates debt.</li> </ul> <p>This post was written during a consolidation session where the consolidation skill itself became the subject of consolidation. The meta continues.</p>","path":["You Can't Import Expertise"],"tags":[]},{"location":"blog/2026-02-07-the-anatomy-of-a-skill-that-works/","level":1,"title":"The Anatomy of a Skill That Works","text":"<p>Update (2026-02-11)</p> <p>As of v0.4.0, ctx consolidated sessions into the journal mechanism. References to <code>ctx-save</code>, <code>ctx session</code>, and <code>.context/sessions/</code> in this post reflect the architecture at the time of writing.</p> <p></p>","path":["The Anatomy of a Skill That Works"],"tags":[]},{"location":"blog/2026-02-07-the-anatomy-of-a-skill-that-works/#what-20-skill-rewrites-taught-me-about-guiding-ai","level":2,"title":"What 20 Skill Rewrites Taught Me About Guiding AI","text":"<p>Jose Alekhinne / 2026-02-07</p> <p>Why do some skills produce great results while others get ignored or produce garbage?</p> <p>I had 20 skills. Most were well-intentioned stubs: a description, a command to run, and a wish for the best.</p> <p>Then I rewrote all of them in a single session. This is what I learned.</p> <p>In Skills That Fight the Platform, I described what skills should not do. In You Can't Import Expertise, I showed why templates fail. This post completes the trilogy: the concrete patterns that make a skill actually work.</p>","path":["The Anatomy of a Skill That Works"],"tags":[]},{"location":"blog/2026-02-07-the-anatomy-of-a-skill-that-works/#the-starting-point","level":2,"title":"The Starting Point","text":"<p>Here is what a typical skill looked like before the rewrite:</p> <pre><code>---\nname: ctx-save\ndescription: \"Save session snapshot.\"\n---\n\nSave the current context state to `.context/sessions/`.\n\n## Execution\n\nctx session save $ARGUMENTS\n\nReport the saved session file path to the user.\n</code></pre> <p>Seven lines of body. A vague description. No guidance on when to use it, when not to, what the command actually accepts, or how to tell if it worked.</p> <p>As a result, the agent would either never trigger the skill (the description was too vague), or trigger it and produce shallow output (no examples to calibrate quality).</p> <p>A skill without boundaries is just a suggestion.</p> <p>More precisely: the most effective boundary I found was a quality gate that runs before execution, not during it.</p>","path":["The Anatomy of a Skill That Works"],"tags":[]},{"location":"blog/2026-02-07-the-anatomy-of-a-skill-that-works/#the-pattern-that-emerged","level":2,"title":"The Pattern That Emerged","text":"<p>After rewriting 20 skills, a repeatable anatomy emerged—independent of the skill’s purpose. Not every skill needs every section, but the effective ones share the same bones:</p> Section What It Does Before X-ing Pre-flight checks; prevents premature execution When to Use Positive triggers; narrows activation When NOT to Use Negative triggers; prevents misuse Usage Examples Invocation patterns the agent can pattern-match Process/Execution What to do; commands, steps, flags Good/Bad Examples Desired vs undesired output; sets boundaries Quality Checklist Verify before claiming completion <p>I realized the first three sections matter more than the rest; because a skill with great execution steps but no activation guidance is like a manual for a tool nobody knows they have.</p> <p>Anti-Pattern: The Perfect Execution Trap</p> <p>A skill with detailed execution steps but no activation guidance will fail more often than a vague skill—because it executes confidently at the wrong time.</p>","path":["The Anatomy of a Skill That Works"],"tags":[]},{"location":"blog/2026-02-07-the-anatomy-of-a-skill-that-works/#lesson-1-quality-gates-prevent-premature-execution","level":2,"title":"Lesson 1: Quality Gates Prevent Premature Execution","text":"<p>The single most impactful addition was a \"Before X-ing\" section at the top of each skill. Not process steps; pre-flight checks.</p> <pre><code>## Before Recording\n\n1. **Check if it belongs here**: is this learning specific\n   to this project, or general knowledge?\n2. **Check for duplicates**: search LEARNINGS.md for similar\n   entries\n3. **Gather the details**: identify context, lesson, and\n   application before recording\n</code></pre> <ul> <li>Without this gate, the agent would execute immediately on trigger.</li> <li>With it, the agent pauses to verify preconditions.</li> </ul> <p>The difference is dramatic: instead of shallow, reflexive execution, you get considered output.</p> <p>Readback</p> <p>For the astute readers, the aviation parallel is intentional:</p> <p>Pilots do not skip the pre-flight checklist because they have flown before.</p> <p>The checklist exists precisely because the stakes are high enough that \"I know what I'm doing\" is not sufficient.</p>","path":["The Anatomy of a Skill That Works"],"tags":[]},{"location":"blog/2026-02-07-the-anatomy-of-a-skill-that-works/#lesson-2-when-not-to-use-is-not-optional","level":2,"title":"Lesson 2: \"When NOT to Use\" Is Not Optional","text":"<p>Every skill had a \"When to Use\" section. Almost none had \"When NOT to Use\". This is a problem.</p> <p>AI agents are biased toward action. Given a skill that says \"use when journal entries need enrichment,\" the agent will find reasons to enrich.</p> <p>Without explicit negative triggers, over-activation is not a bug—it is the default behavior.</p> <p>Some examples of negative triggers that made a real difference:</p> Skill Negative Trigger ctx-reflect \"When the user is in flow; do not interrupt\" ctx-save \"After trivial changes; a typo does not need a snapshot\" prompt-audit \"Unsolicited; only when the user invokes it\" qa \"Mid-development when code is intentionally incomplete\" <p>These are not just nice-to-have. They are load-bearing. Without them, the agent will trigger the skill at the wrong time, produce unwanted output, and erode the user's trust in the skill system.</p>","path":["The Anatomy of a Skill That Works"],"tags":[]},{"location":"blog/2026-02-07-the-anatomy-of-a-skill-that-works/#lesson-3-examples-set-boundaries-better-than-rules","level":2,"title":"Lesson 3: Examples Set Boundaries Better Than Rules","text":"<p>The most common failure mode of thin skills was not wrong behavior but vague behavior. The agent would do roughly the right thing, but at a quality level that required human cleanup.</p> <p>Rules like \"be constructive, not critical\" are too abstract. What does \"constructive\" look like in a prompt audit report? The agent has to guess.</p> <p>Good/bad example pairs avoid guessing:</p> <pre><code>### Good Example\n\n&gt; This session implemented the cooldown mechanism for\n&gt; `ctx agent`. We discovered that `$PPID` in hook context\n&gt; resolves to the Claude Code PID.\n&gt;\n&gt; I'd suggest persisting:\n&gt; - **Learning**: `$PPID` resolves to Claude Code PID\n&gt;   `ctx add learning --context \"...\" --lesson \"...\"`\n&gt; - **Task**: mark \"Add cooldown\" as done\n\n### Bad Examples\n\n* \"*We did some stuff. Want me to save it?*\"\n* Listing 10 trivial learnings that are general knowledge\n* Persisting without asking the user first\n</code></pre> <p>The good example shows the exact format, level of detail, and command syntax. The bad examples show where the boundary is.</p> <p>Together, they define a quality corridor without prescribing every word.</p> <p>Rules describe. Examples demonstrate.</p>","path":["The Anatomy of a Skill That Works"],"tags":[]},{"location":"blog/2026-02-07-the-anatomy-of-a-skill-that-works/#lesson-4-skills-are-read-by-agents-not-humans","level":2,"title":"Lesson 4: Skills Are Read by Agents, Not Humans","text":"<p>This seems obvious, but it has non-obvious consequences. During the rewrite, one skill included guidance that said \"use a blog or notes app\" for general knowledge that does not belong in the project's learnings file.</p> <p>The agent does not have a notes app. It does not browse the web to find one. This instruction, clearly written for a human audience, was dead weight in a skill consumed by an AI.</p> <p>Skills are for the Agents</p> <p>Every sentence in a skill should be actionable by the agent.</p> <p>If the guidance requires human judgment or human tools, it belongs in documentation, not in a skill.</p> <p>The corollary: command references must be exact. A skill that says \"save it somewhere\" is useless. A skill that says <code>ctx add learning --context \"...\" --lesson \"...\" --application \"...\"</code> is actionable.</p> <p>The agent can pattern-match and fill in the blanks.</p> <p>Litmus test: If a sentence starts with \"you could…\" or assumes external tools, it does not belong in a skill.</p>","path":["The Anatomy of a Skill That Works"],"tags":[]},{"location":"blog/2026-02-07-the-anatomy-of-a-skill-that-works/#lesson-5-the-description-field-is-the-trigger","level":2,"title":"Lesson 5: The Description Field Is the Trigger","text":"<p>This was covered in Skills That Fight the Platform, but the rewrite reinforced it with data. Several skills had good bodies but vague descriptions:</p> <pre><code># Before: vague, activates too broadly or not at all\ndescription: \"Show context summary.\"\n\n# After: specific, activates at the right time\ndescription: \"Show context summary. Use at session start or\n  when unclear about current project state.\"\n</code></pre> <p>The description is not a title. It is the activation condition.</p> <p>The platform's skill matching reads this field to decide whether to surface the skill. A vague description means the skill either never triggers or triggers when it should not.</p>","path":["The Anatomy of a Skill That Works"],"tags":[]},{"location":"blog/2026-02-07-the-anatomy-of-a-skill-that-works/#lesson-6-flag-tables-beat-prose","level":2,"title":"Lesson 6: Flag Tables Beat Prose","text":"<p>Most skills wrap CLI tools. The thin versions described flags in prose, if at all. The rewritten versions use tables:</p> <pre><code>| Flag        | Short | Default | Purpose                  |\n|-------------|-------|---------|--------------------------|\n| `--limit`   | `-n`  | 20      | Maximum sessions to show |\n| `--project` | `-p`  | \"\"      | Filter by project name   |\n| `--full`    |       | false   | Show complete content    |\n</code></pre> <p>Tables are scannable, complete, and unambiguous. The agent can read them faster than parsing prose, and they serve as both reference and validation: If the agent invokes a flag not in the table, something is wrong.</p>","path":["The Anatomy of a Skill That Works"],"tags":[]},{"location":"blog/2026-02-07-the-anatomy-of-a-skill-that-works/#lesson-7-template-drift-is-a-real-maintenance-burden","level":2,"title":"Lesson 7: Template Drift Is a Real Maintenance Burden","text":"<p><code>ctx</code> deploys skills through templates (via <code>ctx init</code>). Every skill exists in two places: the live version (<code>.claude/skills/</code>) and the template (<code>internal/assets/claude/skills/</code>).</p> <p>They must match.</p> <p>During the rewrite, every skill update required editing both files and running <code>diff</code> to verify. This sounds trivial, but across 16 template-backed skills, it was the most error-prone part of the process.</p> <p>Template drift is dangerous because it creates false confidence: the agent appears to follow rules that no longer exist.</p> <p>The lesson: if your skills have a deployment mechanism, build the drift check into your workflow. We added a row to the <code>update-docs</code> skill's mapping table specifically for this:</p> <pre><code>| `internal/assets/claude/skills/` | `.claude/skills/` (live) |\n</code></pre> <p>Intentional differences (like project-specific scripts in the live version but not the template) should be documented, not discovered later as bugs.</p>","path":["The Anatomy of a Skill That Works"],"tags":[]},{"location":"blog/2026-02-07-the-anatomy-of-a-skill-that-works/#the-rewrite-scorecard","level":2,"title":"The Rewrite Scorecard","text":"Metric Before After Average skill body ~15 lines ~80 lines Skills with quality gate 0 20 Skills with \"When NOT\" 0 20 Skills with examples 3 20 Skills with flag tables 2 12 Skills with checklist 0 20 <p>More lines, but almost entirely Expert content (per the E/A/R framework). No personality roleplay, no redundant guidance, no capability lists. Just project-specific knowledge the platform does not have.</p>","path":["The Anatomy of a Skill That Works"],"tags":[]},{"location":"blog/2026-02-07-the-anatomy-of-a-skill-that-works/#the-meta-lesson","level":2,"title":"The Meta-Lesson","text":"<p>The previous two posts argued that skills should provide knowledge, not personality; that they should complement the platform, not fight it; that they should grow from project history, not imported templates.</p> <p>This post adds the missing piece: structure.</p> <p>A skill without a structure is a wish.</p> <p>A skill with quality gates, negative triggers, examples, and checklists is a tool: the difference is not the content; it is whether the agent can reliably execute it without human intervention.</p> <p>Skills are Interfaces</p> <p>Good skills are not instructions. They are contracts.:</p> <ul> <li>They specify preconditions, postconditions, and boundaries.</li> <li>They show what success looks like and what failure looks like.</li> <li>They trust the agent's intelligence but do not trust its assumptions.</li> </ul> <p>If you remember one thing from this post...</p> <p>Skills that work have bones, not just flesh.</p> <p>Quality gates, negative triggers, examples, and checklists are the skeleton. The domain knowledge is the muscle.</p> <p>Without the skeleton, the muscle has nothing to attach to.</p> <p>This post was written during the same session that rewrote all 22 skills. The skill-creator skill was updated to encode these patterns. The meta continues.</p>","path":["The Anatomy of a Skill That Works"],"tags":[]},{"location":"blog/2026-02-08-not-everything-is-a-skill/","level":1,"title":"Not Everything Is a Skill","text":"<p>Update (2026-02-11)</p> <p>As of v0.4.0, ctx consolidated sessions into the journal mechanism. References to <code>/ctx-save</code>, <code>.context/sessions/</code>, and session auto-save in this post reflect the architecture at the time of writing.</p> <p></p>","path":["Not Everything Is a Skill"],"tags":[]},{"location":"blog/2026-02-08-not-everything-is-a-skill/#what-a-codebase-audit-taught-me-about-restraint","level":2,"title":"What a Codebase Audit Taught Me About Restraint","text":"<p>Jose Alekhinne / 2026-02-08</p> <p>When you find a useful prompt, what do you do with it?</p> <p>My instinct was to make it a skill. </p> <p>I had just spent three posts explaining how to build skills that work.  Naturally, the hammer wanted nails.</p> <p>Then I looked at what I was holding and realized: this is not a nail.</p>","path":["Not Everything Is a Skill"],"tags":[]},{"location":"blog/2026-02-08-not-everything-is-a-skill/#the-audit","level":2,"title":"The Audit","text":"<p>I wanted to understand how I use <code>ctx</code>: </p> <ul> <li>where the friction is, </li> <li>what works, what drifts, </li> <li>what I keep doing manually that could be automated. </li> </ul> <p>So I wrote a prompt that spawned eight agents to analyze the codebase from  different angles:</p> Agent Analysis 1 Extractable patterns from session history 2 Documentation drift (godoc, inline comments) 3 Maintainability (large functions, misplaced code) 4 Security review (CLI-specific surface) 5 Blog theme discovery 6 Roadmap and value opportunities 7 User-facing documentation gaps 8 Agent team strategies for future sessions <p>The prompt was specific: </p> <ul> <li>read-only agents, </li> <li>structured output format,</li> <li>concrete file references, </li> <li>ranked recommendations. </li> </ul> <p>It ran for about  20 minutes and produced eight Markdown reports.</p> <p>The reports were good: Not perfect, but actionable.</p> <p>What mattered was not the speed. It was that the work could be explored without committing to any single outcome.</p> <p>They surfaced a stale <code>doc.go</code> referencing a subcommand that was never built. </p> <p>They found 311 build-then-test sequences I could reduce to a single <code>make check</code>. </p> <p>They identified that 42% of my sessions start with \"do you remember?\",  which is a lot of repetition for something a skill could handle.</p> <p>I had findings. I had recommendations. I had the instinct to automate.</p> <p>And then... I stopped.</p>","path":["Not Everything Is a Skill"],"tags":[]},{"location":"blog/2026-02-08-not-everything-is-a-skill/#the-question","level":2,"title":"The Question","text":"<p>The natural next step was to wrap the audit prompt as <code>/ctx-audit</code>: a skill you invoke periodically to get a health check. It fits the pattern. It has a clear trigger. It produces structured output.</p> <p>But I had just spent a week writing about what makes skills work, and the criteria I established argued against it.</p> <p>From The Anatomy of a Skill That Works:</p> <p>\"A skill without boundaries is just a suggestion.\"</p> <p>From You Can't Import Expertise:</p> <p>\"Frameworks travel, expertise doesn't.\"</p> <p>From Skills That Fight the Platform:</p> <p>\"You are the guest, not the host.\"</p> <p>The audit prompt fails all three tests:</p> Criterion Audit prompt Good skill Frequency Quarterly, maybe Daily or weekly Stability Tweaked every time Consistent invocation Scope Bespoke, 8 parallel agents Single focused action Trigger \"I feel like auditing\" Clear, repeatable event <p>Skills are contracts. Contracts need stable terms. </p> <p>A prompt I will rewrite every time I use it is not a contract.  It is a conversation starter.</p>","path":["Not Everything Is a Skill"],"tags":[]},{"location":"blog/2026-02-08-not-everything-is-a-skill/#recipes-vs-skills","level":2,"title":"Recipes vs Skills","text":"<p>The distinction that emerged:</p> Skill Recipe Invocation <code>/slash-command</code> Copy-paste from a doc Frequency High (daily, weekly) Low (quarterly, ad hoc) Stability Fixed contract Adapted each time Scope One focused action Multi-step orchestration Audience The agent The human (who then prompts) Lives in <code>.claude/skills/</code> <code>hack/</code> or <code>docs/</code> Attention cost Loaded into context on match Zero until needed <p>Recipes can later graduate into skills, but only after repetition proves stability.</p> <p>That last row matters. Skills consume the attention budget every time the platform considers activating them. A skill that triggers quarterly but gets evaluated on every prompt is pure waste: attention spent on something that will say \"When NOT to Use: now\" 99% of the time.</p> <p>Recipes have zero attention cost. They sit in a Markdown file until a human decides to use them. The human provides the judgment about timing. The prompt provides the structure.</p> <p>The Attention Budget Applies to Skills Too</p> <p>Every skill in <code>.claude/skills/</code> is a standing claim on the context window. The platform evaluates skill descriptions against every user prompt to decide whether to activate.</p> <p>Twenty focused skills are fine. Thirty might be fine. But each one added reduces the headroom available for actual work.</p> <p>Recipes are skills that opted out of the attention tax.</p>","path":["Not Everything Is a Skill"],"tags":[]},{"location":"blog/2026-02-08-not-everything-is-a-skill/#what-the-audit-actually-produced","level":2,"title":"What the Audit Actually Produced","text":"<p>The audit was not wasted. It was a planning exercise that generated concrete tasks:</p> Finding Action 42% of sessions start with memory check Task: <code>/ctx-remember</code> skill (this one is a skill; it is daily) Auto-save stubs are empty Task: enhance <code>/ctx-save</code> with richer summaries 311 raw build-test sequences Task: <code>make check</code> target Stale <code>recall/doc.go</code> lists nonexistent <code>serve</code> Task: fix the doc.go 120 commit sequences disconnected from context Task: <code>/ctx-commit</code> workflow <p>Some findings became skills. Some became <code>Makefile</code> targets. Some became one-line doc fixes. </p> <p>The audit did not prescribe the artifact type. The findings did.</p> <p>The audit is the input. Skills are one possible output. Not the only one.</p>","path":["Not Everything Is a Skill"],"tags":[]},{"location":"blog/2026-02-08-not-everything-is-a-skill/#the-audit-prompt","level":2,"title":"The Audit Prompt","text":"<p>Here is the exact prompt I used, for those who are curious.</p> <p>This is not a template: It worked because it was written against this codebase, at this moment, with specific goals in mind.</p> <pre><code>I want you to create an agent team to audit this codebase. Save each report as\na separate Markdown file under `./ideas/` (or another directory if you prefer).\n\nUse read-only agents (subagent_type: Explore) for all analyses. No code changes.\n\nFor each report, use this structure:\n- Executive Summary (2-3 sentences + severity table)\n- Findings (grouped, with file:line references)\n- Ranked Recommendations (high/medium/low priority)\n- Methodology (what was examined, how)\n\nKeep reports actionable. Every finding should suggest a concrete fix or next step.\n\n## Analyses to Run\n\n### 1. Extractable Patterns (session mining)\nSearch session JSONL files, journal entries, and task archives for repetitive\nmulti-step workflows. Count frequency of bash command sequences, slash command\nusage, and recurring user prompts. Identify patterns that could become skills\nor scripts. Cross-reference with existing skills to find coverage gaps.\nOutput: ranked list of automation opportunities with frequency data.\n\n### 2. Documentation Drift (godoc + inline)\nCompare every doc.go against its package's actual exports and behavior. Check\ninline godoc comments on exported functions against their implementations.\nScan for stale TODO/FIXME/HACK comments. Check that package-level comments match\npackage names.\nOutput: drift items ranked by severity with exact file:line references.\n\n### 3. Maintainability\nLook for:\n- functions longer than 80 lines with clear split points\n- switch blocks with more than 5 cases that could be table-driven\n- inline comments like \"step 1\", \"step 2\" that indicate a block wants to be a function\n- files longer than 400 lines\n- flat packages that could benefit from sub-packages\n- functions that appear misplaced in their file\n\nDo NOT flag things that are fine as-is just because they could theoretically\nbe different.\nOutput: concrete refactoring suggestions, not style nitpicks.\n\n### 4. Security Review\nThis is a CLI app. Focus on CLI-relevant attack surface, not web OWASP:\n- file path traversal\n- command injection\n- symlink following when writing to `.context/`\n- permission handling\n- sensitive data in outputs\n\nOutput: findings with severity ratings and plausible exploit scenarios.\n\n### 5. Blog Theme Discovery\nRead existing blog posts for style and narrative voice. Analyze git history,\nrecent session discussions, and DECISIONS.md for story arcs worth writing about.\nSuggest 3-5 blog post themes with:\n- title\n- angle\n- target audience\n- key commits or sessions to reference\n- a 2-sentence pitch\n\nPrioritize themes that build a coherent narrative across posts.\n\n### 6. Roadmap and Value Opportunities\nBased on current features, recent momentum, and gaps found in other analyses,\nidentify the highest-value improvements. Consider user-facing features,\ndeveloper experience, integration opportunities, and low-hanging fruit.\nOutput: prioritized list with rough effort and impact estimates.\n\n### 7. User-Facing Documentation\nEvaluate README, help text, and user docs. Suggest improvements structured as\nuse-case pages: the problem, how ctx solves it, a typical workflow, and gotchas.\nIdentify gaps where a user would get stuck without reading source code.\nOutput: documentation gaps with suggested page outlines.\n\n### 8. Agent Team Strategies\nBased on the codebase structure, suggest 2-3 agent team configurations for\nupcoming work sessions. For each, include:\n- team composition (roles and agent types)\n- task distribution strategy\n- coordination approach\n- the kinds of work it suits\n</code></pre> <p>Avoid Generic Advice</p> <p>Suggestions that are not grounded in a project's actual structure, history, and workflows are worse than useless:</p> <p>They create false confidence.</p> <p>If an analysis cannot point to concrete files, commits,  sessions, or patterns, it should say \"no finding\"  instead of inventing best practices.</p>","path":["Not Everything Is a Skill"],"tags":[]},{"location":"blog/2026-02-08-not-everything-is-a-skill/#the-deeper-pattern","level":2,"title":"The Deeper Pattern","text":"<p>This is part of a pattern I keep rediscovering: the urge to automate is not the same as the need to automate:</p> <ul> <li>The 3:1 ratio taught me that not every session should be a YOLO sprint. </li> <li>The E/A/R framework taught me that not every template    is worth importing. Now the audit is teaching me that    not every useful prompt is worth institutionalizing.</li> </ul> <p>The common thread is restraint: Knowing when to stop. Recognizing that the cost of automation is not just the effort to build it. It is the ongoing attention tax of maintaining it, the context it consumes, and the false confidence it creates when it drifts.</p> <p>A recipe in <code>hack/runbooks/codebase-audit.md</code> is honest about what it is:</p> <p>A prompt I wrote once, improved once, and will adapt again next time: </p> <ul> <li>It does not pretend to be a reliable contract. </li> <li>It does not claim attention budget. </li> <li>It does not drift silently.</li> </ul> <p>The Automation Instinct</p> <p>When you find a useful prompt, the instinct is to institutionalize it. Resist.</p> <p>Ask first: will I use this the same way next time?</p> <p>If yes, it is a skill. If no, it is a recipe. If you are not sure, it is a recipe until proven otherwise.</p>","path":["Not Everything Is a Skill"],"tags":[]},{"location":"blog/2026-02-08-not-everything-is-a-skill/#this-mindset-in-the-context-of-ctx","level":2,"title":"This Mindset In the Context of <code>ctx</code>","text":"<p><code>ctx</code> is a tool that gives AI agents persistent memory. Its purpose is automation: reducing the friction of context loading, session recall, decision tracking.</p> <p>But automation has boundaries, and knowing where those boundaries are is as important as pushing them forward. </p> <p>The skills system is for high-frequency, stable workflows. </p> <p>The recipes, the journal entries, the session dumps in  <code>.context/sessions/</code>: those are for everything else.</p> <p>Not everything needs to be a slash command. Some things are better as Markdown files you read when you need them.</p> <p>The goal of <code>ctx</code> is not to automate everything: It is to automate the right things and to make the rest easy to find when you need it.</p> <p>If you remember one thing from this post...</p> <p>The best automation decision is sometimes not to automate.</p> <p>A recipe in a Markdown file costs nothing until you use it. A skill costs attention on every prompt, whether it fires or not.</p> <p>Automate the daily. Document the periodic. Forget the rest.</p> <p>This post was written during the session that produced the codebase audit reports and distilled the prompt into <code>hack/runbooks/codebase-audit.md</code>. The audit generated seven tasks, one Makefile target, and zero new skills. The meta continues.</p> <p>See also: Code Is Cheap. Judgment Is Not. -- the capstone that threads this post's restraint argument into the broader case for why judgment, not production, is the bottleneck.</p>","path":["Not Everything Is a Skill"],"tags":[]},{"location":"blog/2026-02-09-defense-in-depth-securing-ai-agents/","level":1,"title":"Defense in Depth: Securing AI Agents","text":"","path":["Defense in Depth: Securing AI Agents"],"tags":[]},{"location":"blog/2026-02-09-defense-in-depth-securing-ai-agents/#when-markdown-is-not-a-security-boundary","level":2,"title":"When Markdown Is Not a Security Boundary","text":"<p>Jose Alekhinne / 2026-02-09</p> <p>What happens when your AI agent runs overnight and nobody is watching?</p> <p>It follows instructions. That is the problem.</p> <p>Not because it is malicious. Because it is controllable. It follows instructions from context, and context can be poisoned.</p> <p>I was writing the autonomous loops recipe for <code>ctx</code>: the guide for running an AI agent in a loop overnight, unattended, working through tasks while you sleep. The original draft had a tip at the bottom:</p> <p>Use <code>CONSTITUTION.md</code> for guardrails. Tell the agent \"never delete tests\" and it usually won't.</p> <p>Then I read that sentence back and realized: that is wishful thinking.</p>","path":["Defense in Depth: Securing AI Agents"],"tags":[]},{"location":"blog/2026-02-09-defense-in-depth-securing-ai-agents/#the-realization","level":2,"title":"The Realization","text":"<p><code>CONSTITUTION.md</code> is a Markdown file. The agent reads it at session start alongside everything else in <code>.context/</code>. It is one source of instructions in a context window that also contains system prompts, project files, conversation history, tool outputs, and whatever the agent fetched from the internet.</p> <p>An attacker who can inject content into any of those sources can redirect the agent's behavior. And \"attacker\" does not always mean a person with malicious intent. It can be:</p> Vector Example A dependency A malicious npm package with instructions in its README or error output A URL Documentation page with embedded adversarial instructions A project file A contributor who adds instructions to <code>CLAUDE.md</code> or <code>.cursorrules</code> The agent itself In an autonomous loop, the agent modifies its own config between iterations A command output An error message containing instructions the agent interprets and follows <p>That last vector is the one that kept me up at night (literally!):</p> <p>In an autonomous loop, the agent modifies files as part of its job. If it modifies its own configuration files, the next iteration loads the modified config. No human reviews it. No diff is shown. The agent that starts iteration <code>N+1</code> is running with rules written by iteration <code>N</code>.</p> <p>The agent can rewrite its own guardrails.</p>","path":["Defense in Depth: Securing AI Agents"],"tags":[]},{"location":"blog/2026-02-09-defense-in-depth-securing-ai-agents/#five-layers-each-with-a-hole","level":2,"title":"Five Layers, Each With a Hole","text":"<p>What followed was a week of peeling back assumptions. Every defense I examined had a bypass, and the bypass was always the same shape: the defense was enforced at a level the agent could reach.</p>","path":["Defense in Depth: Securing AI Agents"],"tags":[]},{"location":"blog/2026-02-09-defense-in-depth-securing-ai-agents/#layer-1-soft-instructions-probabilistic","level":3,"title":"Layer 1: Soft Instructions (Probabilistic)","text":"<p><code>CONSTITUTION.md</code>, the Agent Playbook, system prompts. These tell the agent what to do. The agent usually follows them.</p> <p>The hole: Prompt injection. A sufficiently crafted payload overrides soft instructions. Long context windows dilute attention on rules stated early. Edge cases where instructions are ambiguous get resolved in unpredictable ways.</p> <p>Verdict: Necessary. Not sufficient. Good for the common case. Never trust it as a security boundary.</p>","path":["Defense in Depth: Securing AI Agents"],"tags":[]},{"location":"blog/2026-02-09-defense-in-depth-securing-ai-agents/#layer-2-application-controls-deterministic-at-runtime-mutable-across-iterations","level":3,"title":"Layer 2: Application Controls (Deterministic at Runtime, Mutable Across Iterations)","text":"<p>Permission allowlists in <code>.claude/settings.local.json</code>:</p> <pre><code>{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(make:*)\",\n      \"Bash(go:*)\",\n      \"Bash(git:*)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\"\n    ]\n  }\n}\n</code></pre> <p>If <code>rm</code>, <code>curl</code>, <code>sudo</code>, or <code>docker</code> are not in the allowlist, the agent cannot invoke them. This is deterministic. The application enforces it regardless of what any prompt says.</p> <p>The hole: The agent can modify the allowlist itself. It has <code>Write</code> permission. The allowlist lives in a file. The agent writes to the file. The next iteration loads the modified allowlist.</p> <p>The application enforces the rules, but the application reads the rules from files the agent can write.</p> <p>Verdict: Strong first layer. Must be combined with self-modification prevention.</p>","path":["Defense in Depth: Securing AI Agents"],"tags":[]},{"location":"blog/2026-02-09-defense-in-depth-securing-ai-agents/#layer-3-os-level-isolation-unbypassable","level":3,"title":"Layer 3: OS-Level Isolation (Unbypassable)","text":"<p>This is where the defenses stop having holes in the same shape.</p> <p>The operating system enforces access controls that no application-level trick can override. An unprivileged user cannot read files owned by root. A process without <code>CAP_NET_RAW</code> cannot open raw sockets. These are kernel boundaries.</p> Control What it stops Dedicated unprivileged user Privilege escalation, <code>sudo</code>, group-based access Filesystem permissions Lateral movement to other projects, system config Immutable config files Self-modification of guardrails between iterations <p>Make the agent's instruction files read-only: <code>CLAUDE.md</code>, <code>.claude/settings.local.json</code>, <code>.context/CONSTITUTION.md</code>. Own them as a different user, or mark them immutable with <code>chattr +i</code> on Linux.</p> <p>The hole: Actions within the agent's legitimate scope. If the agent has write access to source code (which it needs), it can introduce vulnerabilities in the code itself. You cannot prevent this without removing the agent's ability to do its job.</p> <p>Verdict: Essential. This is the layer that makes Layers 1 and 2 trustworthy.</p> <p>OS-level isolation does not make the agent safe; it makes the other layers meaningful.</p>","path":["Defense in Depth: Securing AI Agents"],"tags":[]},{"location":"blog/2026-02-09-defense-in-depth-securing-ai-agents/#layer-4-network-controls","level":3,"title":"Layer 4: Network Controls","text":"<p>An agent that cannot reach the internet cannot exfiltrate data. It also cannot ingest new instructions mid-loop from external documents, error pages, or hostile content.</p> <pre><code># Container with no network\ndocker run --network=none ...\n\n# Or firewall rules allowing only package registries\niptables -A OUTPUT -d registry.npmjs.org -j ACCEPT\niptables -A OUTPUT -d proxy.golang.org -j ACCEPT\niptables -A OUTPUT -j DROP\n</code></pre> <p>If the agent genuinely does not need the network, disable it entirely. If it needs to fetch dependencies, allow specific registries and block everything else.</p> <p>The hole: None, if the agent does not need the network. The tradeoff is that many real workloads need dependency resolution, so a full airgap requires pre-populated caches.</p>","path":["Defense in Depth: Securing AI Agents"],"tags":[]},{"location":"blog/2026-02-09-defense-in-depth-securing-ai-agents/#layer-5-infrastructure-isolation","level":3,"title":"Layer 5: Infrastructure Isolation","text":"<p>The strongest boundary is a separate machine. The moment you stop arguing about prompts and start arguing about kernels, you are finally doing security.</p> <pre><code>docker run --rm \\\n  --network=none \\\n  --cap-drop=ALL \\\n  --memory=4g \\\n  --cpus=2 \\\n  -v /path/to/project:/workspace \\\n  -w /workspace \\\n  your-dev-image \\\n  ./loop.sh\n</code></pre> <p>Critical: never mount the Docker socket (<code>/var/run/docker.sock</code>). An agent with socket access can spawn sibling containers with full host access, effectively escaping the sandbox. This is not theoretical: the Docker socket grants root-equivalent access to the host.</p> <p>Use rootless Docker or Podman to eliminate this escalation path entirely.</p> <p>Virtual machines are even stronger. The guest kernel has no visibility into the host OS. No shared folders, no filesystem passthrough, no SSH keys to other machines.</p>","path":["Defense in Depth: Securing AI Agents"],"tags":[]},{"location":"blog/2026-02-09-defense-in-depth-securing-ai-agents/#the-pattern","level":2,"title":"The Pattern","text":"<p>Each layer is straightforward: The strength is in the combination:</p> Layer Implementation What it stops Soft instructions <code>CONSTITUTION.md</code> Common mistakes (probabilistic) Application allowlist <code>.claude/settings.local.json</code> Unauthorized commands (deterministic within runtime) Immutable config <code>chattr +i</code> on config files Self-modification between iterations Unprivileged user Dedicated user, no sudo Privilege escalation Container <code>--cap-drop=ALL --network=none</code> Host escape, data exfiltration Resource limits <code>--memory=4g --cpus=2</code> Resource exhaustion <p>No layer is redundant. Each one catches what the others miss:</p> <ul> <li>The soft instructions handle the 99% case: \"don't delete tests.\"</li> <li>The allowlist prevents the agent from running commands it should   not.</li> <li>The immutable config prevents the agent from modifying the   allowlist.</li> <li>The unprivileged user prevents the agent from removing   the immutable flag.</li> <li>The container prevents the agent from reaching   anything outside its workspace.</li> <li>The resource limits prevent the agent from consuming all system resources.</li> </ul> <p>Remove any one layer and there is an attack path through the remaining ones.</p>","path":["Defense in Depth: Securing AI Agents"],"tags":[]},{"location":"blog/2026-02-09-defense-in-depth-securing-ai-agents/#common-mistakes-i-see","level":2,"title":"Common Mistakes I See","text":"<p>These are real patterns, not hypotheticals:</p> <p>\"I'll just use <code>--dangerously-skip-permissions</code>.\" This disables Layer 2 entirely. Without Layers 3 through 5, you have no protection at all. The flag means what it says. Only use it inside a properly isolated container or VM.</p> <p>\"The agent is sandboxed in Docker.\" A Docker container with the Docker socket mounted, running as root, with <code>--privileged</code>, and full network access is not sandboxed. It is a root shell with extra steps.</p> <p>\"I reviewed the CLAUDE.md, it's fine.\" You reviewed it before the loop started. The agent modified it during iteration 3. Iteration 4 loaded the modified version. Unless the file is immutable, your review is stale.</p> <p>\"The agent only has access to this one project.\" Does the project directory contain <code>.env</code> files? SSH keys? API tokens? A <code>.git/config</code> with push access to a remote? Filesystem isolation means isolating what is in the directory too.</p>","path":["Defense in Depth: Securing AI Agents"],"tags":[]},{"location":"blog/2026-02-09-defense-in-depth-securing-ai-agents/#the-connection-to-context-engineering","level":2,"title":"The Connection to Context Engineering","text":"<p>This is the same lesson I keep rediscovering, wearing different clothes.</p> <p>In The Attention Budget, I wrote about how every token competes for the AI's focus. Security instructions in <code>CONSTITUTION.md</code> are subject to the same budget pressure: if the context window is full of code, error messages, and tool outputs, the security rules stated at the top get diluted.</p> <p>In Skills That Fight the Platform, I wrote about how custom instructions can conflict with the AI's built-in behavior. Security rules have the same problem: telling an agent \"never run curl\" in Markdown while giving it unrestricted shell access creates a contradiction. The agent resolves contradictions unpredictably.</p> <p>In You Can't Import Expertise, I wrote about how generic templates fail because they do not encode project-specific knowledge. Generic security advice fails the same way. \"Don't exfiltrate data\" is a category. Blocking outbound network access is a control.</p> <p>The pattern across all of these: Soft instructions are useful for the common case. Hard boundaries are required for security. Know which is which.</p>","path":["Defense in Depth: Securing AI Agents"],"tags":[]},{"location":"blog/2026-02-09-defense-in-depth-securing-ai-agents/#the-checklist","level":2,"title":"The Checklist","text":"<p>Before running an unattended AI agent:</p> <ul> <li> Agent runs as a dedicated unprivileged user (no sudo, no   docker group)</li> <li> Agent's config files are immutable or owned by a different   user</li> <li> Permission allowlist restricts tools to the project's   toolchain</li> <li> Container drops all capabilities (<code>--cap-drop=ALL</code>)</li> <li> Docker socket is NOT mounted</li> <li> Network is disabled or restricted to specific domains</li> <li> Resource limits are set (memory, CPU, disk)</li> <li> No SSH keys, API tokens, or credentials are accessible</li> <li> Project directory does not contain <code>.env</code> or secrets files</li> <li> Iteration cap is set (<code>--max-iterations</code>)</li> </ul> <p>This checklist lives in the Agent Security reference alongside the full threat model and detailed guidance for each layer.</p>","path":["Defense in Depth: Securing AI Agents"],"tags":[]},{"location":"blog/2026-02-09-defense-in-depth-securing-ai-agents/#what-changed-in-ctx","level":2,"title":"What Changed in ctx","text":"<p>The autonomous loops recipe now has a full permissions and isolation section instead of a one-line tip about <code>CONSTITUTION.md</code>. It covers both the explicit allowlist approach and the <code>--dangerously-skip-permissions</code> flag, with honest guidance about when each is appropriate.</p> <p>It also has an OS-level isolation table that is not optional: unprivileged users, filesystem permissions, containers, VMs, network controls, resource limits, and self-modification prevention.</p> <p>The Agent Security page consolidates the threat model and defense layers into a standalone reference.</p> <p>These are not theoretical improvements. They are the minimum responsible guidance for a tool that helps people run AI agents overnight.</p> <p>If you remember one thing from this post...</p> <p>Markdown is not a security boundary.</p> <pre><code>`CONSTITUTION.md` is a nudge. An allowlist is a gate.\nAn unprivileged user in a network-isolated container is a wall.\n\nUse all three. Trust only the wall.\n</code></pre> <p>This post was written during the session that added permissions, isolation, and self-modification prevention to the autonomous loops recipe. The security guidance started as a single tip and grew into two documents. The meta continues.</p>","path":["Defense in Depth: Securing AI Agents"],"tags":[]},{"location":"blog/2026-02-12-how-deep-is-too-deep/","level":1,"title":"How Deep Is Too Deep?","text":"","path":["How Deep Is Too Deep?"],"tags":[]},{"location":"blog/2026-02-12-how-deep-is-too-deep/#when-master-ml-is-the-wrong-next-step","level":2,"title":"When \"Master ML\" Is the Wrong Next Step","text":"<p>Jose Alekhinne / 2026-02-12</p> <p>Have you ever felt like you should understand more of the stack beneath you?</p> <p>You can talk about transformers at a whiteboard. </p> <p>You can explain attention to a colleague. </p> <p>You can use agentic AI to ship real software.</p> <p>But somewhere in the back of your mind, there is a voice: \"Maybe I should go deeper. Maybe I need to master machine learning.\"</p> <p>I had that voice for months. Then I spent a week debugging an agent failure that had nothing to do with ML theory and everything to do with knowing which abstraction was leaking.</p> <p>This post is about when depth compounds and when it does not.</p>","path":["How Deep Is Too Deep?"],"tags":[]},{"location":"blog/2026-02-12-how-deep-is-too-deep/#the-hierarchy-nobody-questions","level":2,"title":"The Hierarchy Nobody Questions","text":"<p>There is an implicit stack most people carry around when thinking about AI:</p> Layer What Lives Here Agentic AI Autonomous loops, tool use, multi-step reasoning Generative AI Text, image, code generation Deep Learning Transformer architectures, training at scale Neural Networks Backpropagation, gradient descent Machine Learning Statistical learning, optimization Classical AI Search, planning, symbolic reasoning <p>At some point down that stack, you hit a comfortable plateau: the layer where you can hold a conversation but not debug a failure.</p> <p>The instinctive response is to go deeper.</p> <p>But that instinct hides a more important question.</p> <p>Does depth still compound when the abstractions above you are moving hyper-exponentially?</p>","path":["How Deep Is Too Deep?"],"tags":[]},{"location":"blog/2026-02-12-how-deep-is-too-deep/#the-uncomfortable-observation","level":2,"title":"The Uncomfortable Observation","text":"<p>If you squint hard enough, a large chunk of modern ML intuition collapses into older fields:</p> ML Concept Older Field Gradient descent Numerical optimization Backpropagation Reverse-mode autodiff Loss landscapes Non-convex optimization Generalization Statistics Scaling laws Asymptotics and information theory <p>Nothing here is uniquely \"AI\".</p> <p>Most of this math predates the term deep learning.</p> <p>In some cases, by decades.</p> <p>So what changed?</p>","path":["How Deep Is Too Deep?"],"tags":[]},{"location":"blog/2026-02-12-how-deep-is-too-deep/#same-tools-different-regime","level":2,"title":"Same Tools, Different Regime","text":"<p>The mistake is assuming this is a new theory problem.</p> <p>It is not.</p> <p>It is a new operating regime.</p> <p>Classical numerical methods were developed under assumptions like:</p> <ul> <li>Manageable dimensionality</li> <li>Reasonably well-conditioned objectives</li> <li>Losses that actually represent the goal</li> </ul> <p>Modern ML violates all three: On purpose.</p> <p>Today's models operate with millions to trillions of parameters, wildly underdetermined systems, and objective functions we know are wrong but optimize anyway. </p> <p>At this scale, familiar concepts warp:</p> <ul> <li>What we call \"local minima\" are overwhelmingly saddle points in   high-dimensional spaces</li> <li>Noise stops being noise and starts becoming structure</li> <li>Overfitting can coexist with generalization</li> <li>Bigger models outperform \"better\" ones</li> </ul> <p>The math did not change.</p> <p>The phase did.</p> <p>This is less numerical analysis and more *statistical physics: Same equations, but behavior dominated by phase transitions and emergent structure.</p>","path":["How Deep Is Too Deep?"],"tags":[]},{"location":"blog/2026-02-12-how-deep-is-too-deep/#why-scaling-laws-feel-alien","level":2,"title":"Why Scaling Laws Feel Alien","text":"<p>In classical statistics, asymptotics describe what happens eventually.</p> <p>In modern ML, scaling laws describe where you can operate today.</p> <p>They do not say \"given enough time, things converge\".</p> <p>They say \"cross this threshold and behavior qualitatively changes\".</p> <p>This is why dumb architectures plus scale beat clever ones.</p> <p>Why small theoretical gains disappear under data.</p> <p>Why \"just make it bigger\", ironically, keeps working longer than it should.</p> <p>That is not a triumph of ML theory.</p> <p>It is a property of high-dimensional systems under loose objectives.</p>","path":["How Deep Is Too Deep?"],"tags":[]},{"location":"blog/2026-02-12-how-deep-is-too-deep/#where-depth-actually-pays-off","level":2,"title":"Where Depth Actually Pays Off","text":"<p>This reframes the original question.</p> <p>You do not need depth because this is \"AI\".</p> <p>You need depth where failure modes propagate upward.</p> <p>I learned this building <code>ctx</code>. The agent failures I have spent the most time debugging were never about the model's architecture.</p> <p>They were about:</p> <ul> <li> <p>Misplaced trust:   The model was confident. The output was wrong. Knowing when confidence   and correctness diverge is not something you learn from a textbook. You   learn it from watching patterns across hundreds of sessions.</p> </li> <li> <p>Distribution shift:   The model performed well on common patterns and fell apart on edge   cases specific to this project. Recognizing that shift before it   compounds requires understanding why generalization has limits, not   just that it does.</p> </li> <li> <p>Error accumulation:    In a single prompt, model quirks are tolerable. In autonomous loops   running overnight, they compound. A small bias in how the model   interprets instructions becomes a large drift by iteration 20.</p> </li> <li> <p>Scale hiding errors:    The model's raw capability masked problems that only surfaced under   specific conditions. More parameters did not fix the issue. They just   made the failure mode rarer and harder to reproduce.</p> </li> </ul> <p>This is the kind of depth that compounds.</p> <p>Not deriving backprop.</p> <p>Understanding when correct math produces misleading intuition.</p>","path":["How Deep Is Too Deep?"],"tags":[]},{"location":"blog/2026-02-12-how-deep-is-too-deep/#the-connection-to-context-engineering","level":2,"title":"The Connection to Context Engineering","text":"<p>This is the same pattern I keep finding at different altitudes.</p> <p>In \"The Attention Budget\",  I wrote about how dumping everything into the context window degrades the  model's focus. The fix was not a better model. It was better curation: load less, load the right things,  preserve signal per token.</p> <p>In \"Skills That Fight the Platform\", I wrote about how custom instructions can conflict with the model's built-in behavior. The fix was not deeper ML knowledge. It was an understanding that the model already has judgment and that you should extend it, not override it.</p> <p>In \"You Can't Import Expertise\", I wrote about how generic  templates fail because they do not encode project-specific knowledge.  A consolidation skill with eight Rust-based analysis dimensions was mostly  noise for a Go project. The fix was not a better template. It was growing  expertise from this project's own history.</p> <p>In every case, the answer was not \"go deeper into ML\".</p> <p>The answer was knowing which abstraction was leaking  and fixing it at the right layer.</p>","path":["How Deep Is Too Deep?"],"tags":[]},{"location":"blog/2026-02-12-how-deep-is-too-deep/#agentic-systems-are-not-an-ml-problem","level":2,"title":"Agentic Systems Are Not an ML Problem","text":"<p>The mistake is assuming agent failures originate where the model was trained, rather than where it is deployed.</p> <p>Agentic AI is a systems problem under chaotic uncertainty:</p> <ul> <li>Feedback loops between the agent and its environment</li> <li>Error accumulation across iterations</li> <li>Brittle representations that break outside training distribution</li> <li>Misplaced trust in outputs that look correct</li> </ul> <p>In short-lived interactions, model quirks are tolerable. In long-running autonomous loops, they compound. </p> <p>That is where shallow understanding becomes expensive.</p> <p>But the understanding you need is not about optimizer internals.</p> <p>It is about:</p> What Matters What Does Not (for Most Practitioners) Why gradient descent fails in specific regimes How to derive it from scratch When memorization masquerades as reasoning The formal definition of VC dimension Recognizing distribution shift before it compounds Hand-tuning learning rate schedules Predicting when scale hides errors instead of fixing them Chasing theoretical purity divorced from practice <p>The depth that matters is diagnostic, not theoretical.</p>","path":["How Deep Is Too Deep?"],"tags":[]},{"location":"blog/2026-02-12-how-deep-is-too-deep/#the-real-answer","level":2,"title":"The Real Answer","text":"<p>Not turtles all the way down.</p> <p>Go deep enough to:</p> <ul> <li>Diagnose failures instead of cargo-culting fixes</li> <li>Reason about uncertainty instead of trusting confidence</li> <li>Design guardrails that align with model behavior, not hope</li> </ul> <p>Stop before:</p> <ul> <li>Hand-deriving gradients for the sake of it</li> <li>Obsessing over optimizer internals you will never touch</li> <li>Chasing theoretical purity divorced from the scale you actually   operate at</li> </ul> <p>This is not about mastering ML.</p> <p>It is about knowing which abstractions you can safely trust and which ones leak.</p>","path":["How Deep Is Too Deep?"],"tags":[]},{"location":"blog/2026-02-12-how-deep-is-too-deep/#a-practical-litmus-test","level":2,"title":"A Practical Litmus Test","text":"<p>If a failure occurs and your instinct is to:</p> <ul> <li>Add more prompt text: abstraction leak above</li> <li>Add retries or heuristics: error accumulation</li> <li>Change the model: scale masking</li> <li>Reach for ML theory: you are probably (but not always) going too deep</li> </ul> <p>The right depth is the shallowest layer where the failure becomes predictable.</p>","path":["How Deep Is Too Deep?"],"tags":[]},{"location":"blog/2026-02-12-how-deep-is-too-deep/#the-ctx-lesson","level":2,"title":"The <code>ctx</code> Lesson","text":"<p>Every design decision in <code>ctx</code> is downstream of this principle.</p> <p>The attention budget exists because the model's internal attention mechanism has real limits: You do not need to understand the math of softmax to build around it. But you do need to understand that more context is not always better and that attention density degrades with scale.</p> <p>The skill system exists because the model's built-in behavior is already good: You do not need to understand RLHF to build effective skills. But you do need to understand that the model already has judgment and your skills should teach it things it does not know, not override how it thinks.</p> <p>Defense in depth exists because soft instructions are probabilistic: You do not need to understand the transformer architecture to know that a Markdown file is not a security boundary. But you do need to understand that the model follows instructions from context, and context can be poisoned.</p> <p>In each case, the useful depth was one or two layers below the abstraction I was working at.</p> <p>Not at the bottom of the stack.</p> <p>The boundary between useful understanding and academic exercise is where your failure modes live.</p>","path":["How Deep Is Too Deep?"],"tags":[]},{"location":"blog/2026-02-12-how-deep-is-too-deep/#closing-thought","level":2,"title":"Closing Thought","text":"<p>Most modern AI systems do not fail because the math is wrong.</p> <p>They fail because we apply correct math in the wrong regime, then build autonomous systems on top of it.</p> <p>Understanding that boundary, not crossing it blindly, is where depth still compounds.</p> <p>And that is a far more useful form of expertise than memorizing another loss function.</p> <p>If you remember one thing from this post...</p> <p>Go deep enough to diagnose your failures. Stop before you are solving problems that do not propagate to your layer.</p> <p>The abstractions below you are not sacred. But neither are they irrelevant.</p> <p>The useful depth is wherever your failure modes live. Usually one or two layers down, not at the bottom.</p> <p>This post started as a note about whether I should take an ML course. The answer turned out to be \"no, but understand why not\". The meta continues.</p>","path":["How Deep Is Too Deep?"],"tags":[]},{"location":"blog/2026-02-14-irc-as-context/","level":1,"title":"Before Context Windows, We Had Bouncers","text":"","path":["Before Context Windows, We Had Bouncers"],"tags":[]},{"location":"blog/2026-02-14-irc-as-context/#the-reset-problem","level":2,"title":"The Reset Problem","text":"<p>IRC is stateless.</p> <ul> <li>You disconnect, you vanish.</li> <li>You reconnect, you begin again.</li> </ul> <p>No buffer.</p> <p>No memory.</p> <p>No continuity.</p> <p>Modern systems are not much different:</p> <ul> <li>Close the browser tab.<ul> <li>Lose the Slack scrollback.</li> </ul> </li> <li>Open a new LLM session.<ul> <li>Start from zero.</li> </ul> </li> </ul> <p>Resets externalize reconstruction cost onto humans.</p> <p>Reconstruction is tax. Tax becomes entropy.</p>","path":["Before Context Windows, We Had Bouncers"],"tags":[]},{"location":"blog/2026-02-14-irc-as-context/#stateless-protocol-stateful-life","level":2,"title":"Stateless Protocol, Stateful Life","text":"<p>IRC is minimal:</p> <ul> <li>A TCP connection.</li> <li>A nickname.</li> <li>A channel.</li> <li>A stream of lines.</li> </ul> <p>When the connection drops, you literally *disappear** from the graph.</p> <p>The protocol is stateless; human systems are not.</p> <p>So you:</p> <ul> <li>Reconnect.</li> <li>Ask what you missed.</li> <li>Scroll.</li> <li>Reconstruct.</li> </ul> <p>The machine forgets; you pay.</p>","path":["Before Context Windows, We Had Bouncers"],"tags":[]},{"location":"blog/2026-02-14-irc-as-context/#the-bouncer-pattern","level":2,"title":"The Bouncer Pattern","text":"<p>A <code>bouncer</code> is a daemon that remains connected when you do not.</p> <ul> <li>It holds your seat.</li> <li>It buffers what you missed.</li> <li>It keeps your identity online.</li> </ul> <p>ZNC is one such bouncer.</p> <p>With ZNC:</p> <ul> <li>Your client does not connect to IRC.</li> <li>It connects to ZNC.</li> <li>ZNC connects upstream.</li> </ul> <p>Client sessions become ephemeral. Presence becomes infrastructural.</p> <p>ZNC is tmux for IRC</p> <ul> <li> <p>Close your laptop.</p> <ul> <li>ZNC remains.</li> </ul> </li> <li> <p>Switch devices.</p> <ul> <li>ZNC persists.</li> </ul> </li> </ul> <p>This is not convenience; this is continuity.</p>","path":["Before Context Windows, We Had Bouncers"],"tags":[]},{"location":"blog/2026-02-14-irc-as-context/#presence-without-flapping","level":2,"title":"Presence Without Flapping","text":"<p>With a bouncer:</p> <ul> <li>Closing your client does not emit <code>PART</code>.</li> <li>Reopening does not emit <code>JOIN</code>.</li> </ul> <p>You do not flap in and out of existence.</p> <p>From the channel’s perspective, you remain.</p> <p>From your perspective, history accumulates.</p> <ul> <li>Buffers persist.</li> <li>Identity persists.</li> <li>Context persists.</li> </ul> <p>This pattern predates AI.</p>","path":["Before Context Windows, We Had Bouncers"],"tags":[]},{"location":"blog/2026-02-14-irc-as-context/#before-llm-context-windows","level":2,"title":"Before LLM Context Windows","text":"<p>An LLM session without memory is IRC without a bouncer.</p> <ul> <li>Close the window.</li> <li>Start over.</li> <li>Re-explain intent.</li> <li>Rehydrate context.</li> </ul> <p>That is friction.</p> <p>This Walks and Talks like ctx</p> <p>Context engineering moves memory out of sessions and into infrastructure.</p> <ul> <li><code>ZNC</code> does this for IRC.</li> <li><code>ctx</code> does this for agents.</li> </ul> <p>Same principle:</p> <ul> <li>Volatile interface.</li> <li>Persistent substrate.</li> </ul> <p>Different fabric.</p>","path":["Before Context Windows, We Had Bouncers"],"tags":[]},{"location":"blog/2026-02-14-irc-as-context/#minimal-architecture","level":2,"title":"Minimal Architecture","text":"<p>My setup is intentionally boring:</p> <ul> <li>A $5 small VPS.</li> <li>ZNC installed.</li> <li>TLS enabled.</li> <li>Firewall restricted.</li> </ul> <p>Then:</p> <ul> <li>ZNC connects to <code>Libera.Chat</code>.</li> <li><code>SASL</code> authentication lives inside ZNC.</li> <li>Buffers are stored on disk.</li> </ul> <p>My client connects to my VPS, not the network.</p> <p>The commands do not matter: The boundaries do.</p> <ul> <li>Authentication in infrastructure, not in the client.</li> <li>Memory server-side, not in scrollback.</li> <li>Presence decoupled from activity.</li> </ul> <p>Everything else is configuration.</p>","path":["Before Context Windows, We Had Bouncers"],"tags":[]},{"location":"blog/2026-02-14-irc-as-context/#platform-memory","level":2,"title":"Platform Memory","text":"<p>Yes, it is 2026.</p> <ul> <li>Discord stores history.</li> <li>Slack stores history.</li> <li>The dumpster fire on gasoline called X, too, stores history.</li> </ul> <p>HOWEVER, they own your substrate.</p> <p>Running a bouncer is quiet sovereignty:</p> <ul> <li>Logs are mine.</li> <li>Presence is continuous.</li> <li>State does not reset because I closed a tab.</li> </ul> <p>Small acts compound.</p>","path":["Before Context Windows, We Had Bouncers"],"tags":[]},{"location":"blog/2026-02-14-irc-as-context/#signal-density","level":2,"title":"Signal Density","text":"<p>Primitive systems select for builders.</p> <p>Consistent presence in small rooms compounds reputation.</p> <p>Quiet compounding outperforms viral spikes.</p>","path":["Before Context Windows, We Had Bouncers"],"tags":[]},{"location":"blog/2026-02-14-irc-as-context/#infrastructure-as-cognition","level":2,"title":"Infrastructure as Cognition","text":"<p>ZNC is not interesting because it is retro; it is interesting because it models a principle:</p> <ul> <li>Stateless protocols require stateful wrappers.</li> <li>Volatile interfaces require durable memory.</li> <li>Human systems require continuity.</li> </ul> <p>Distilled:</p> <p>Humans require context.</p> <p>Before context windows, we had bouncers.  </p> <p>Before AI memory files, we had buffers.</p> <p>Continuity is not a feature; it is a design decision.</p>","path":["Before Context Windows, We Had Bouncers"],"tags":[]},{"location":"blog/2026-02-14-irc-as-context/#build-it","level":2,"title":"Build It","text":"<p>If you want the actual setup (VPS, ZNC, TLS, SASL, firewall...) there is a step-by-step runbook:</p> <p>Persistent IRC Presence with ZNC.</p>","path":["Before Context Windows, We Had Bouncers"],"tags":[]},{"location":"blog/2026-02-14-irc-as-context/#motd","level":2,"title":"MOTD","text":"<p>When my client connects to my bouncer, it prints:</p> <pre><code>//   /    Context:                     https://ctx.ist\n// ,'`./    do you remember?\n// `.,'\\\n//   \\    Copyright 2026-present Context contributors.\n//                 SPDX-License-Identifier: Apache-2.0\n</code></pre> <p>See also: Context as Infrastructure -- the post that takes this observation to its conclusion: stateless protocols need stateful wrappers, and AI sessions need persistent filesystems.</p>","path":["Before Context Windows, We Had Bouncers"],"tags":[]},{"location":"blog/2026-02-14-parallel-agents-with-worktrees/","level":1,"title":"Parallel Agents with Git Worktrees","text":"","path":["Parallel Agents with Git Worktrees"],"tags":[]},{"location":"blog/2026-02-14-parallel-agents-with-worktrees/#the-backlog-problem","level":2,"title":"The Backlog Problem","text":"<p>Jose Alekhinne / 2026-02-14</p> <p>What do you do with 30 open tasks?</p> <p>You could work through them one at a time. One agent, one branch, one commit stream.</p> <p>Or you could ask: which of these don't touch each other?</p> <p>I had 30 open tasks in <code>TASKS.md</code>. Some were docs. Some were a new encryption package. Some were test coverage for a stable module. Some were blog posts.</p> <p>They had almost zero file overlap.</p> <p>Running one agent at a time meant serial execution on work that was fundamentally parallel. I was bottlenecking on me, not on the machine.</p>","path":["Parallel Agents with Git Worktrees"],"tags":[]},{"location":"blog/2026-02-14-parallel-agents-with-worktrees/#the-insight-file-overlap-is-the-constraint","level":2,"title":"The Insight: File Overlap Is the Constraint","text":"<p>This is not a scheduling problem. It is a conflict avoidance problem.</p> <p>Two agents can work simultaneously on the same codebase if and only if they don't touch the same files. The moment they do, you get merge conflicts — and merge conflicts on AI-generated code are expensive because the human has to arbitrate choices they didn't make.</p> <p>So the question becomes: can you partition your backlog into non-overlapping tracks?</p> <p>For <code>ctx</code>, the answer was obvious:</p> Track Touches Tasks <code>work/docs</code> <code>docs/</code>, <code>hack/</code> Blog posts, recipes, runbooks <code>work/pad</code> <code>internal/cli/pad/</code>, specs Scratchpad encryption, CLI, tests <code>work/tests</code> <code>internal/cli/recall/</code> Recall test coverage <p>Three tracks. Near-zero overlap. Three agents.</p>","path":["Parallel Agents with Git Worktrees"],"tags":[]},{"location":"blog/2026-02-14-parallel-agents-with-worktrees/#git-worktrees-the-mechanism","level":2,"title":"Git Worktrees: The Mechanism","text":"<p>Git has a feature that most people don't use: worktrees.</p> <p>A worktree is a second (or third, or fourth) working directory that shares the same <code>.git</code> object database as your main checkout. Each worktree has its own branch, its own index, its own working tree. But they all share history, refs, and objects.</p> <pre><code>git worktree add ../ctx-docs -b work/docs\ngit worktree add ../ctx-pad -b work/pad\ngit worktree add ../ctx-tests -b work/tests\n</code></pre> <p>Three directories. Three branches. One repository.</p> <p>This is cheaper than three clones. And because they share objects, <code>git merge</code> afterwards is fast — it's a local operation on shared data.</p>","path":["Parallel Agents with Git Worktrees"],"tags":[]},{"location":"blog/2026-02-14-parallel-agents-with-worktrees/#the-setup","level":2,"title":"The Setup","text":"<p>The workflow I landed on:</p> <p>1. Group tasks by blast radius.</p> <p>Read <code>TASKS.md</code>. For each pending task, estimate which files and directories it touches. Group tasks that share files into the same track. Tasks with no overlap go into separate tracks.</p> <p>This is the part that requires human judgment. An agent can propose groupings, but you need to verify that the boundaries are real. A task that says \"update docs\" but actually touches Go code will poison a docs track.</p> <p>2. Create worktrees as sibling directories.</p> <p>Not subdirectories. Siblings. If your main checkout is at <code>~/WORKSPACE/ctx</code>, worktrees go at <code>~/WORKSPACE/ctx-docs</code>, <code>~/WORKSPACE/ctx-pad</code>, etc.</p> <p>Why siblings? Because some tools (and some agents) walk up the directory tree looking for <code>.git</code>. A worktree inside the main checkout confuses them.</p> <p>3. Launch one agent per worktree.</p> <pre><code># Terminal 1\ncd ../ctx-docs &amp;&amp; claude\n\n# Terminal 2\ncd ../ctx-pad &amp;&amp; claude\n\n# Terminal 3\ncd ../ctx-tests &amp;&amp; claude\n</code></pre> <p>Each agent gets a full working copy with <code>.context/</code> intact. It reads the same <code>TASKS.md</code>, the same <code>DECISIONS.md</code>, the same <code>CONVENTIONS.md</code>. It knows the full project state. It just works on a different slice.</p> <p>4. Do NOT run <code>ctx init</code> in worktrees.</p> <p>This is the gotcha. The <code>.context/</code> directory is tracked in git. Running <code>ctx init</code> in a worktree would overwrite shared context files — wiping decisions, learnings, and tasks that belong to the whole project.</p> <p>The worktree already has everything it needs. Leave it alone.</p>","path":["Parallel Agents with Git Worktrees"],"tags":[]},{"location":"blog/2026-02-14-parallel-agents-with-worktrees/#what-actually-happened","level":2,"title":"What Actually Happened","text":"<p>I ran three agents for about 40 minutes. Here is roughly what each track produced:</p> <p><code>work/docs</code>: Parallel worktrees recipe, blog post edits, recipe index reorganization, IRC recipe moved from <code>docs/</code> to <code>hack/</code>.</p> <p><code>work/pad</code>: <code>ctx pad show</code> subcommand, <code>--append</code> and <code>--prepend</code> flags on <code>ctx pad edit</code>, spec updates, 28 new test functions.</p> <p><code>work/tests</code>: Recall test coverage, edge case tests.</p> <p>Merging took about five minutes. Two of the three merges were clean. The third had a conflict in <code>TASKS.md</code> — both the docs track and the pad track had marked different tasks as <code>[x]</code>.</p>","path":["Parallel Agents with Git Worktrees"],"tags":[]},{"location":"blog/2026-02-14-parallel-agents-with-worktrees/#the-tasksmd-conflict","level":2,"title":"The TASKS.md Conflict","text":"<p>This deserves its own section because it will happen every time.</p> <p>When two agents work in parallel, they both read <code>TASKS.md</code> at the start and mark tasks complete as they go. When you merge, git sees two branches that modified the same file differently.</p> <p>The resolution is always the same: accept all completions from both sides. No task should go from <code>[x]</code> back to <code>[ ]</code>. The merge is additive.</p> <p>This is one of those conflicts that sounds scary but is trivially mechanical. You're not arbitrating design decisions. You're combining two checklists.</p>","path":["Parallel Agents with Git Worktrees"],"tags":[]},{"location":"blog/2026-02-14-parallel-agents-with-worktrees/#limits","level":2,"title":"Limits","text":"<p>3-4 worktrees, maximum. I tried four once. By the time I merged the third track, the fourth had drifted far enough that its changes needed rebasing. The merge complexity grows faster than the parallelism benefit.</p> <p>Three is the sweet spot. Two is conservative but safe. Four is possible if the tracks are truly independent.</p> <p>Group by directory, not by priority. It is tempting to put all the high-priority tasks in one track. Don't. Two high-priority tasks that touch the same files must be in the same track, regardless of urgency. The constraint is file overlap, not importance.</p> <p>Commit frequently. Smaller commits make merge conflicts easier to resolve. An agent that writes 500 lines in a single commit is harder to merge than one that commits every logical step.</p> <p>Name tracks by concern. <code>work/docs</code> and <code>work/pad</code> tell you what's happening. <code>work/track-1</code> and <code>work/track-2</code> tell you nothing.</p>","path":["Parallel Agents with Git Worktrees"],"tags":[]},{"location":"blog/2026-02-14-parallel-agents-with-worktrees/#the-pattern","level":2,"title":"The Pattern","text":"<p>This is the same pattern that shows up everywhere in <code>ctx</code>:</p> <p>The attention budget taught me that you can't dump everything into one context window. You have to partition, prioritize, and load selectively.</p> <p>Worktrees are the same principle applied to execution: you can't dump every task into one agent's workstream. You have to partition by blast radius, assign selectively, and merge deliberately.</p> <p>The codebase audit that generated these 30 tasks used eight parallel agents for analysis. Worktrees let me use parallel agents for implementation. Same coordination pattern, different artifact.</p> <p>And the IRC bouncer post from earlier today argued that stateless protocols need stateful wrappers. Worktrees are the same: git branches are stateless forks; <code>.context/</code> is the stateful wrapper that gives each agent the project's full memory.</p>","path":["Parallel Agents with Git Worktrees"],"tags":[]},{"location":"blog/2026-02-14-parallel-agents-with-worktrees/#should-this-be-a-skill","level":2,"title":"Should This Be a Skill?","text":"<p>I asked myself the same question I asked about the codebase audit: should this be a <code>/ctx-worktree</code> skill?</p> <p>This time the answer is yes. Unlike the audit prompt — which I tweak every time and run quarterly — the worktree workflow is:</p> Criterion Worktree workflow Codebase audit Frequency Weekly Quarterly Stability Same steps every time Tweaked every time Scope Mechanical, bounded Bespoke, 8 agents Trigger Large backlog \"I feel like auditing\" <p>The commands are mechanical: <code>git worktree add</code>, <code>git worktree remove</code>, branch naming, safety checks. This is exactly what skills are for: stable contracts for repetitive operations.</p> <p>So <code>/ctx-worktree</code> exists. It enforces the 4-worktree limit, creates sibling directories, uses <code>work/</code> branch prefixes, and reminds you not to run <code>ctx init</code> in worktrees.</p>","path":["Parallel Agents with Git Worktrees"],"tags":[]},{"location":"blog/2026-02-14-parallel-agents-with-worktrees/#the-takeaway","level":2,"title":"The Takeaway","text":"<p>Serial execution is the default. But serial is not always necessary.</p> <p>If your backlog partitions cleanly by file overlap, you can multiply your throughput with nothing more exotic than <code>git worktree</code> and a second terminal window.</p> <p>The hard part is not the git commands. It is the discipline: grouping by blast radius instead of priority, accepting that <code>TASKS.md</code> will conflict, and knowing when three tracks is enough.</p> <p>If you remember one thing from this post...</p> <p>Partition by blast radius, not by priority.</p> <p>Two tasks that touch the same files belong in the same track, no matter how important the other one is.</p> <p>The constraint is file overlap. Everything else is scheduling.</p> <p>The practical setup — skill invocation, worktree creation, merge workflow, and cleanup — lives in the recipe: Parallel Agent Development with Git Worktrees.</p>","path":["Parallel Agents with Git Worktrees"],"tags":[]},{"location":"blog/2026-02-15-ctx-v0.3.0-the-discipline-release/","level":1,"title":"ctx v0.3.0: The Discipline Release","text":"","path":["ctx v0.3.0: The Discipline Release"],"tags":[]},{"location":"blog/2026-02-15-ctx-v0.3.0-the-discipline-release/#when-the-ratio-of-polish-to-features-is-31-you-know-something-changed","level":2,"title":"When the Ratio of Polish to Features Is 3:1, You Know Something Changed","text":"<p>Jose Alekhinne / February 15, 2026</p> <p>What does a release look like when most of the work is invisible?</p> <p>No new headline feature. No architectural pivot. No rewrite.</p> <p>Just 35+ documentation and quality commits against ~15 feature commits -- and somehow, the tool feels like it grew up overnight.</p> <p>Six days separate v0.2.0 from v0.3.0. Measured by calendar time, it is nothing. Measured by what changed in how the project operates, it is the most significant release yet.</p> <p>v0.1.0 was the prototype. v0.2.0 was the archaeology release -- making the past accessible. v0.3.0 is the discipline release: the one that turned best practices into enforcement, suggestions into structure, and a collection of commands into a system of skills.</p> <p>The Release Window</p> <p>February 1 -- February 7, 2026</p> <p>From the v0.2.0 tag to commit <code>2227f99</code>. 78 files changed in the migration commit alone.</p>","path":["ctx v0.3.0: The Discipline Release"],"tags":[]},{"location":"blog/2026-02-15-ctx-v0.3.0-the-discipline-release/#the-migration-commands-to-skills","level":2,"title":"The Migration: Commands to Skills","text":"<p>The largest single change was the migration from <code>.claude/commands/*.md</code> to <code>.claude/skills/*/SKILL.md</code>.</p> <p>This was not a rename. It was a rethinking of how AI agents discover and execute project-specific workflows.</p> Aspect Commands (before) Skills (after) Structure Flat files in one directory Directory-per-skill with SKILL.md Description Optional, often vague Required, doubles as activation trigger Quality gates None \"Before X-ing\" pre-flight checklist Negative triggers None \"When NOT to Use\" in every skill Examples Rare Good/bad pairs in every skill Average length ~15 lines ~80 lines <p>The description field became the single most important line in each skill. In the old system, descriptions were titles. In the new system, they are activation conditions -- the text the platform reads to decide whether to surface a skill for a given prompt.</p> <p>A description that says \"Show context summary\" activates too broadly or not at all. A description that says \"Show context summary. Use at session start or when unclear about current project state\" activates at the right moment.</p> <p>78 files changed. 1,915 insertions. Not because the skills got bloated -- because they got specific.</p>","path":["ctx v0.3.0: The Discipline Release"],"tags":[]},{"location":"blog/2026-02-15-ctx-v0.3.0-the-discipline-release/#the-skill-sweep","level":2,"title":"The Skill Sweep","text":"<p>After the structural migration, every skill was rewritten in a single session. All 21 of them.</p> <p>The rewrite was guided by a pattern that emerged during the process itself -- a repeatable anatomy that effective skills share regardless of their purpose:</p> <ol> <li>Before X-ing: Pre-flight checks that prevent premature execution</li> <li>When to Use: Positive triggers that narrow activation</li> <li>When NOT to Use: Negative triggers that prevent misuse</li> <li>Usage Examples: Invocation patterns the agent can pattern-match</li> <li>Quality Checklist: Verification before claiming completion</li> </ol> <p>The Anatomy of a Skill That Works post covers the details. What matters for the release story is the result: zero skills with quality gates became twenty. Zero skills with negative triggers became twenty. Three skills with examples became twenty.</p> <p>The Skill Trilogy as Design Spec</p> <p>The three blog posts written during this window -- Skills That Fight the Platform, You Can't Import Expertise, and The Anatomy of a Skill That Works -- were not retrospective documentation. They were written during the rewrite, and the lessons fed back into the skills as they were being built.</p> <p>The blog was the design document. The skills were the implementation.</p>","path":["ctx v0.3.0: The Discipline Release"],"tags":[]},{"location":"blog/2026-02-15-ctx-v0.3.0-the-discipline-release/#the-consolidation-sweep","level":2,"title":"The Consolidation Sweep","text":"<p>The unglamorous work. The kind you only appreciate when you try to change something later and it just works.</p> What Why It Matters Constants consolidation Magic strings replaced with semantic constants Variable deshadowing Eliminated subtle scoping bugs File splits Modules that were doing too much, broken apart Godoc standardization Every exported function documented to convention <p>This is the work that doesn't get a changelog entry but makes every future commit easier. When a new contributor (human or AI) reads the codebase, they find consistent patterns instead of accumulated drift.</p> <p>The consolidation was not an afterthought. It was scheduled -- deliberately, with the same priority as features. The 3:1 ratio that emerged during v0.2.0 development became an explicit practice: three feature sessions, one consolidation session.</p>","path":["ctx v0.3.0: The Discipline Release"],"tags":[]},{"location":"blog/2026-02-15-ctx-v0.3.0-the-discipline-release/#the-ear-framework","level":2,"title":"The E/A/R Framework","text":"<p>On February 4<sup>th</sup>, we adopted the E/A/R classification as the official standard for evaluating skills:</p> Category Meaning Target Expert Knowledge Claude does not have &gt;70% Activation When/how to trigger ~20% Redundant What Claude already knows &lt;10% <p>This came from reviewing approximately 30 external skill files and discovering that most were redundant with Claude's built-in system prompt. Only about 20% had salvageable content, and even those yielded just a few heuristics each.</p> <p>The E/A/R framework gave us a concrete, testable criterion: a good skill is Expert knowledge minus what Claude already knows. If more than 10% of a skill restates platform defaults, it is creating noise, not signal.</p> <p>Every skill in v0.3.0 was evaluated against this framework. Several were deleted. The survivors are leaner and more focused.</p>","path":["ctx v0.3.0: The Discipline Release"],"tags":[]},{"location":"blog/2026-02-15-ctx-v0.3.0-the-discipline-release/#backup-and-monitoring-infrastructure","level":2,"title":"Backup and Monitoring Infrastructure","text":"<p>A tool that manages your project's memory needs ops maturity. v0.3.0 added two pieces of infrastructure that reflect this:</p> <p>Backup staleness hook: A <code>UserPromptSubmit</code> hook that checks whether the last <code>.context/</code> backup is more than two days old. If it is, and the SMB mount is available, it reminds the user. No cron job running when nobody is working. No redundant backups when nothing has changed.</p> <p>Context size checkpoint: A <code>PreToolUse</code> hook that estimates current context window usage and warns when the session is getting heavy. This hooks into the attention budget philosophy -- degradation is expected, but it should be visible.</p> <p>Both hooks use <code>$CLAUDE_PROJECT_DIR</code> instead of hardcoded paths, a migration triggered by a username rename that broke every absolute path in the hook configuration. That migration -- replacing <code>/home/user/...</code> with <code>\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/...</code> -- was one of those changes that seems trivial but prevents an entire category of future failures.</p>","path":["ctx v0.3.0: The Discipline Release"],"tags":[]},{"location":"blog/2026-02-15-ctx-v0.3.0-the-discipline-release/#the-numbers","level":2,"title":"The Numbers","text":"Metric v0.2.0 v0.3.0 Skills (was \"commands\") 11 21 Skills with quality gates 0 21 Skills with \"When NOT to Use\" 0 21 Average skill body ~15 lines ~80 lines Hooks using $CLAUDE_PROJECT_DIR 0 All Documentation commits -- 35+ Feature/fix commits -- ~15 <p>That ratio -- 35+ documentation and quality commits to ~15 feature commits -- is the defining characteristic of this release. It is not a failure to ship features. It is the deliberate choice to make the existing features reliable.</p>","path":["ctx v0.3.0: The Discipline Release"],"tags":[]},{"location":"blog/2026-02-15-ctx-v0.3.0-the-discipline-release/#what-v030-means","level":2,"title":"What v0.3.0 Means","text":"<p>v0.1.0 asked: \"Can we give AI persistent memory?\"</p> <p>v0.2.0 asked: \"Can we make that memory accessible to humans too?\"</p> <p>v0.3.0 asks a different question: \"Can we make the quality self-enforcing?\"</p> <p>The answer is not a feature. It is a practice:</p> <ul> <li>Skills with quality gates enforce pre-flight checks.</li> <li>Negative triggers prevent misuse without human intervention.</li> <li>The E/A/R framework ensures skills contain signal, not noise.</li> <li>Consolidation sessions are scheduled, not improvised.</li> <li>Hook infrastructure makes degradation visible.</li> </ul> <p>Discipline is not the absence of velocity. It is the infrastructure that makes velocity sustainable.</p>","path":["ctx v0.3.0: The Discipline Release"],"tags":[]},{"location":"blog/2026-02-15-ctx-v0.3.0-the-discipline-release/#what-comes-next","level":2,"title":"What Comes Next","text":"<p>The skill system is now mature enough to support real workflows without constant human correction. The hooks infrastructure is portable and resilient. The consolidation practice is documented and repeatable.</p> <p>The next chapter is about what you build on top of discipline: multi-agent coordination, deeper integration patterns, and the question of whether context management is a tool concern or an infrastructure concern.</p> <p>But those are future posts.</p> <p>This one is about the release that proved polish is not the opposite of progress. It is what turns a prototype into a product.</p> <p>The Discipline Release</p> <p>v0.1.0 shipped features. v0.2.0 shipped archaeology. v0.3.0 shipped the habits that make everything else trustworthy.</p> <p>The most important code in this release is the code that prevents bad code from shipping.</p> <p>This post was drafted using <code>/ctx-blog</code> with access to the full git history between v0.2.0 and v0.3.0, decision logs, learning logs, and the session files from the skill rewrite window. The meta continues.</p>","path":["ctx v0.3.0: The Discipline Release"],"tags":[]},{"location":"blog/2026-02-15-eight-ways-a-hook-can-talk/","level":1,"title":"Eight Ways a Hook Can Talk","text":"","path":["Eight Ways a Hook Can Talk"],"tags":[]},{"location":"blog/2026-02-15-eight-ways-a-hook-can-talk/#when-your-warning-disappears","level":2,"title":"When Your Warning Disappears","text":"<p>Jose Alekhinne / 2026-02-15</p> <p>I had a backup warning that nobody ever saw.</p> <p>The hook was correct — it detected stale backups, formatted a nice message, and output it as <code>{\"systemMessage\": \"...\"}</code>. The problem wasn't detection. The problem was delivery. The agent absorbed the information, processed it internally, and never told the user.</p> <p>Meanwhile, a different hook — the journal reminder — worked perfectly every time. Users saw the reminder, ran the commands, and the backlog stayed manageable. Same hook event (<code>UserPromptSubmit</code>), same project, completely different outcomes.</p> <p>The difference was one line:</p> <pre><code>IMPORTANT: Relay this journal reminder to the user VERBATIM\nbefore answering their question.\n</code></pre> <p>That explicit instruction is what makes VERBATIM relay a pattern, not just a formatting choice. And once I saw it as a pattern, I started seeing others.</p>","path":["Eight Ways a Hook Can Talk"],"tags":[]},{"location":"blog/2026-02-15-eight-ways-a-hook-can-talk/#the-audit","level":2,"title":"The Audit","text":"<p>I looked at every hook in the ctx project — eight shell scripts across three hook events — and found five distinct output patterns already in use, plus three more that the existing hooks were reaching for but hadn't quite articulated.</p> <p>The patterns form a spectrum based on a single question: who decides what the user sees?</p> <p>At one end, the hook decides everything (hard gate: the agent literally cannot proceed). At the other end, the hook is invisible (silent side-effect: nobody knows it ran). In between, there is a range of negotiation between hook, agent, and user.</p> <p>Here's the full spectrum:</p>","path":["Eight Ways a Hook Can Talk"],"tags":[]},{"location":"blog/2026-02-15-eight-ways-a-hook-can-talk/#1-hard-gate","level":3,"title":"1. Hard Gate","text":"<pre><code>{\"decision\": \"block\", \"reason\": \"Use ctx from PATH, not ./ctx\"}\n</code></pre> <p>The nuclear option. The agent's tool call is rejected before it executes. This is Claude Code's first-class <code>PreToolUse</code> mechanism — the hook returns JSON with <code>decision: block</code> and the agent gets an error with the reason.</p> <p>Use this for invariants. Constitution rules, security boundaries, things that must never happen. We use it to enforce PATH-based ctx invocation, block <code>sudo</code>, and require explicit approval for <code>git push</code>.</p>","path":["Eight Ways a Hook Can Talk"],"tags":[]},{"location":"blog/2026-02-15-eight-ways-a-hook-can-talk/#2-verbatim-relay","level":3,"title":"2. VERBATIM Relay","text":"<pre><code>IMPORTANT: Relay this warning to the user VERBATIM before answering.\n┌─ Journal Reminder ─────────────────────────────\n│ You have 12 sessions not yet exported.\n│   ctx recall export --all\n└────────────────────────────────────────────────\n</code></pre> <p>The instruction is the pattern. Without \"Relay VERBATIM,\" agents tend to absorb information into their internal reasoning and never surface it. The explicit instruction changes the behavior from \"I know about this\" to \"I must tell the user about this.\"</p> <p>We use this for actionable reminders: unexported journal entries, stale backups, context capacity warnings. Things the user should see regardless of what they asked.</p>","path":["Eight Ways a Hook Can Talk"],"tags":[]},{"location":"blog/2026-02-15-eight-ways-a-hook-can-talk/#3-agent-directive","level":3,"title":"3. Agent Directive","text":"<pre><code>┌─ Persistence Checkpoint (prompt #25) ───────────\n│ No context files updated in 15+ prompts.\n│ Have you discovered learnings worth persisting?\n└──────────────────────────────────────────────────\n</code></pre> <p>A nudge, not a command. The hook tells the agent something; the agent decides what (if anything) to tell the user. This is right for behavioral nudges — \"you haven't saved context in a while\" doesn't need to be relayed verbatim, but the agent should consider acting on it.</p>","path":["Eight Ways a Hook Can Talk"],"tags":[]},{"location":"blog/2026-02-15-eight-ways-a-hook-can-talk/#4-silent-context-injection","level":3,"title":"4. Silent Context Injection","text":"<pre><code>ctx agent --budget 4000 2&gt;/dev/null || true\n</code></pre> <p>Pure background enrichment. The agent's context window gets project information injected on every tool call, with no visible output. Neither the agent nor the user sees the hook fire — but the agent makes better decisions because of the context.</p>","path":["Eight Ways a Hook Can Talk"],"tags":[]},{"location":"blog/2026-02-15-eight-ways-a-hook-can-talk/#5-silent-side-effect","level":3,"title":"5. Silent Side-Effect","text":"<pre><code>find \"$CTX_TMPDIR\" -type f -mtime +15 -delete\n</code></pre> <p>Do work, say nothing. Temp file cleanup on session end. Logging. Marker file management. The action is the entire point; no one needs to know.</p>","path":["Eight Ways a Hook Can Talk"],"tags":[]},{"location":"blog/2026-02-15-eight-ways-a-hook-can-talk/#the-patterns-we-dont-have-yet","level":2,"title":"The Patterns We Don't Have Yet","text":"<p>Three more patterns emerged from the gaps in the existing hooks.</p> <p>Conditional relay — \"Relay this, but only if the user's question is about X.\" Avoids noise when the warning isn't relevant. More fragile (depends on agent judgment) but less annoying.</p> <p>Suggested action — \"Here's a problem and here's the exact command to fix it. Ask the user before running it.\" Goes beyond a nudge by giving the agent a concrete proposal, but still requires human approval.</p> <p>Escalating severity — <code>INFO</code> gets absorbed silently. <code>WARN</code> gets mentioned at the next natural pause. <code>CRITICAL</code> gets the VERBATIM treatment. A protocol for hooks that produce output at different urgency levels, so they don't all compete for the user's attention.</p>","path":["Eight Ways a Hook Can Talk"],"tags":[]},{"location":"blog/2026-02-15-eight-ways-a-hook-can-talk/#the-principle","level":2,"title":"The Principle","text":"<p>The reason this matters: hooks are the boundary between your environment and the agent's reasoning. A hook that detects a problem but can't communicate it effectively is the same as no hook at all.</p> <p>The format of your output is a design decision with real consequences:</p> <ul> <li>Use a hard gate and the agent can't proceed (good for invariants,   frustrating for false positives)</li> <li>Use VERBATIM relay and the user will see it (good for reminders,   noisy if overused)</li> <li>Use an agent directive and the agent might act (good for nudges,   unreliable for critical warnings)</li> <li>Use silent injection and nobody knows (good for enrichment,   invisible when it breaks)</li> </ul> <p>Choose deliberately. And when in doubt, write the word VERBATIM.</p> <p>The full pattern catalog with decision flowchart and implementation examples is in the Hook Output Patterns recipe.</p>","path":["Eight Ways a Hook Can Talk"],"tags":[]},{"location":"blog/2026-02-15-why-zensical/","level":1,"title":"Version Numbers Are Lagging Indicators","text":"","path":["Version Numbers Are Lagging Indicators"],"tags":[]},{"location":"blog/2026-02-15-why-zensical/#why-ctxs-journal-site-runs-on-a-v0021-tool","level":2,"title":"Why ctx's Journal Site Runs on a v0.0.21 Tool","text":"<p>Jose Alekhinne / 2026-02-15</p> <p>Would you ship production infrastructure on a v0.0.21 dependency?</p> <p>Most engineers wouldn't. Version numbers signal maturity. Pre-1.0 means unstable API, missing features, risk.</p> <p>But version numbers tell you where a project has been. They say nothing about where it's going.</p> <p>I just bet ctx's entire journal site on a tool that hasn't hit v0.1.0. Here's why I'd do it again.</p>","path":["Version Numbers Are Lagging Indicators"],"tags":[]},{"location":"blog/2026-02-15-why-zensical/#the-problem","level":2,"title":"The Problem","text":"<p>When v0.2.0 shipped the journal system, the pipeline was clear: export sessions to Markdown, enrich them with YAML frontmatter, and render them into something browsable. The first two steps were solved. The third needed a tool.</p> <p>The journal entries are standard Markdown with YAML frontmatter, tables, and fenced code blocks. That is the entire format. No JSX. No shortcodes. No custom templating. Just Markdown rendered well.</p> <p>The requirements are modest:</p> <ul> <li>Read <code>mkdocs.yml</code></li> <li>Render Markdown with extensions (admonitions, tabs, tables)</li> <li>Search</li> <li>Handle 100+ files without choking on incremental rebuilds</li> <li>Look good out of the box</li> <li>Not lock me in</li> </ul> <p>The obvious candidates:</p> Tool Language Strengths Pain Points Hugo Go Blazing fast, mature Templating is painful; Go templates fight you on anything non-trivial Astro JS/TS Modern, flexible JS ecosystem overhead; overkill for a docs site MkDocs + Material Python Beautiful defaults, massive community (22k+ stars) Slow incremental rebuilds on large sites; limited extensibility model Zensical Python Built to fix MkDocs' limits; 4-5x faster rebuilds v0.0.21; module system not yet shipped <p>The instinct was Hugo. Same language as <code>ctx</code>. Fast. Well-established.</p> <p>But instinct is not analysis. I picked the one with the lowest version number.</p>","path":["Version Numbers Are Lagging Indicators"],"tags":[]},{"location":"blog/2026-02-15-why-zensical/#the-evaluation","level":2,"title":"The Evaluation","text":"<p>Here is what I actually evaluated, in order:</p>","path":["Version Numbers Are Lagging Indicators"],"tags":[]},{"location":"blog/2026-02-15-why-zensical/#1-the-team","level":3,"title":"1. The Team","text":"<p>Zensical is built by squidfunk -- the same person behind Material for MkDocs, the most popular MkDocs theme with 22,000+ stars. It powers documentation sites for projects across every language and framework.</p> <p>This is not someone learning how to build static site generators. This is someone who spent years understanding exactly where MkDocs breaks and decided to fix it from the ground up.</p> <p>They did not build zensical because MkDocs was bad. They built it because MkDocs hit a ceiling:</p> <ul> <li> <p>Incremental rebuilds: 4-5x faster during serve. When you have   hundreds of journal entries and you edit one, the difference between   \"rebuild everything\" and \"rebuild this page\" is the difference   between a usable workflow and a frustrating one.</p> </li> <li> <p>Large site performance: Specifically designed for tens of   thousands of pages. The journal grows with every session. A tool   that slows down as content accumulates is a tool you will eventually   replace.</p> </li> </ul> <p>A proven team starting fresh is more predictable than an unproven team at v3.0.</p>","path":["Version Numbers Are Lagging Indicators"],"tags":[]},{"location":"blog/2026-02-15-why-zensical/#2-the-architecture","level":3,"title":"2. The Architecture","text":"<p>Zensical is investing in a Rust-based Markdown parser with CommonMark support. That signals something about the team's priorities: performance foundations first, features second.</p> <p>ctx's journal will grow. Every exported session adds files. Every enrichment pass adds metadata. Choosing a tool that gets slower as you add content means choosing to migrate later. Choosing one built for scale means the decision holds.</p>","path":["Version Numbers Are Lagging Indicators"],"tags":[]},{"location":"blog/2026-02-15-why-zensical/#3-the-migration-path","level":3,"title":"3. The Migration Path","text":"<p>Zensical reads <code>mkdocs.yml</code> natively. If it doesn't work out, I can move back to MkDocs + Material with zero content changes. The Markdown is standard. The frontmatter is standard. The configuration is compatible.</p> <p>This is the infrastructure pattern again. The same way ZNC decouples presence from the client, zensical decouples rendering from the generator. The Markdown is yours. The frontmatter is standard YAML. The configuration is MkDocs-compatible. You are not locked into anything except your own content.</p> <p>No lock-in is not a feature. It's a design philosophy. It's the same reason ctx uses plain Markdown files in <code>.context/</code> instead of a database: the format should outlive the tool.</p> <p>Lock-in Is the Real Risk, Not Version Numbers</p> <p>A mature tool with a proprietary format is riskier than a young tool with a standard one. Version numbers measure time invested. Portability measures respect for the user.</p>","path":["Version Numbers Are Lagging Indicators"],"tags":[]},{"location":"blog/2026-02-15-why-zensical/#4-the-dependency-tree","level":3,"title":"4. The Dependency Tree","text":"<p>Here is what <code>pip install zensical</code> actually pulls in:</p> <ul> <li>click</li> <li>Markdown</li> <li>Pygments</li> <li>pymdown-extensions</li> <li>PyYAML</li> </ul> <p>Five dependencies. All well-known. No framework bloat. No bundler. No transpiler. No node_modules black hole.</p> <p>3k GitHub stars at v0.0.21 is strong early traction for a pre-1.0 project. The dependency tree is thin. No bloat.</p>","path":["Version Numbers Are Lagging Indicators"],"tags":[]},{"location":"blog/2026-02-15-why-zensical/#5-the-fit","level":3,"title":"5. The Fit","text":"<p>This is the same principle behind the attention budget: do not overfit the tool to hypothetical requirements. The right amount of capability is the minimum needed for the current task.</p> <p>Hugo is a powerful static site generator. It is also a powerful templating engine, a powerful asset pipeline, and a powerful taxonomy system. For rendering Markdown journals, that power is overhead: complexity you pay for but never use.</p> <p>ctx's journal files are standard Markdown with YAML frontmatter, tables, and fenced code blocks. That is exactly the sweet spot Zensical inherits from Material for MkDocs. No custom plugins needed. No special syntax. No templating gymnastics.</p> <p>The requirements match the capabilities. Not the capabilities that are promised -- the ones that exist today, at v0.0.21.</p>","path":["Version Numbers Are Lagging Indicators"],"tags":[]},{"location":"blog/2026-02-15-why-zensical/#the-caveat","level":2,"title":"The Caveat","text":"<p>It would be dishonest not to mention what's missing.</p> <p>The module system for third-party extensions opens in early 2026. If ctx ever needs custom plugins -- auto-linking session IDs, rendering special journal metadata -- that infrastructure isn't there yet.</p> <p>The install experience is rough. We discovered this firsthand: <code>pip install zensical</code> often fails on macOS (system Python stubs, Homebrew's PEP 668 restrictions). The answer is pipx, which creates an isolated environment with the correct Python version automatically. That friction is typical for young Python tooling, and it is documented in the Getting Started guide.</p> <p>And 3,000 stars at v0.0.21 is strong early traction, but it's still early. The community is small. Stack Overflow answers don't exist yet. When something breaks, you're reading source code, not documentation.</p> <p>These are real costs. I chose to pay them because the alternative costs are higher.</p> <p>Hugo's templating pain would cost me time on every site change. Astro's JS ecosystem would add complexity I don't need. MkDocs would work today but hit scaling walls tomorrow. Zensical's costs are front-loaded and shrinking. The others compound.</p>","path":["Version Numbers Are Lagging Indicators"],"tags":[]},{"location":"blog/2026-02-15-why-zensical/#the-evaluation-framework","level":2,"title":"The Evaluation Framework","text":"<p>For anyone facing a similar choice, here is the framework that emerged:</p> Signal What It Tells You Weight Team track record Whether the architecture will be sound High Migration path Whether you can leave if wrong High Current fit Whether it solves your problem today High Dependency tree How much complexity you're inheriting Medium Version number How long the project has existed Low Star count Community interest (not quality) Low Feature list What's possible (not what you need) Low <p>The bottom three are the metrics most engineers optimize for. The top four are the ones that predict whether you'll still be happy with the choice in a year.</p> <p>Features You Don't Need Are Not Free</p> <p>Every feature in a dependency is code you inherit but don't control. A tool with 200 features where you use 5 means 195 features worth of surface area for bugs, breaking changes, and security issues that have nothing to do with your use case.</p> <p>Fit is the inverse of feature count.</p>","path":["Version Numbers Are Lagging Indicators"],"tags":[]},{"location":"blog/2026-02-15-why-zensical/#the-broader-pattern","level":2,"title":"The Broader Pattern","text":"<p>This is part of a theme I keep encountering in this project:</p> <p>Leading indicators beat lagging indicators.</p> Domain Lagging Indicator Leading Indicator Tooling Version number, star count Team track record, architecture Code quality Test coverage percentage Whether tests catch real bugs Context persistence Number of files in <code>.context/</code> Whether the AI makes fewer mistakes Skills Number of skills created Whether each skill fires at the right time Consolidation Lines of code refactored Whether drift stops accumulating <p>Version numbers, star counts, coverage percentages, file counts -- these are all measures of effort expended. They say nothing about value delivered.</p> <p>The question is never \"how mature is this tool?\" The question is \"does this tool's trajectory intersect with my needs?\"</p> <p>Zensical's trajectory: a proven team fixing known problems in a proven architecture, with a standard format and no lock-in.</p> <p>ctx's needs: render standard Markdown into a browsable site, at scale, without complexity.</p> <p>The intersection is clean. The version number is noise.</p> <p>This is the same kind of decision that shows up throughout <code>ctx</code>:</p> <ul> <li>Skills that fight the platform taught that the best   integration extends existing behavior, not replaces it.</li> <li>You can't import expertise taught that tools should   grow from your project's actual needs, not from feature checklists.</li> <li>Context as infrastructure argues that the format should   outlive the tool -- and zensical honors that principle by reading   standard Markdown and standard MkDocs configuration.</li> </ul> <p>If you remember one thing from this post...</p> <p>Version numbers measure where a project has been. The team and the architecture tell you where it's going.</p> <p>A v0.0.21 tool built by the right team on the right foundations is a safer bet than a v5.0 tool that doesn't fit your problem.</p> <p>Bet on trajectories, not timestamps.</p> <p>This post started as an evaluation note in <code>ideas/</code> and a separate decision log. The analysis held up. The two merged into one. The meta continues.</p>","path":["Version Numbers Are Lagging Indicators"],"tags":[]},{"location":"blog/2026-02-16-ctx-v0.6.0-the-integration-release/","level":1,"title":"ctx v0.6.0: The Integration Release","text":"","path":["ctx v0.6.0: The Integration Release"],"tags":[]},{"location":"blog/2026-02-16-ctx-v0.6.0-the-integration-release/#two-commands-to-persistent-memory","level":2,"title":"Two Commands to Persistent Memory","text":"<p>Jose Alekhinne / February 16, 2026</p> <p>What changed?</p> <p>ctx is now a Claude Code plugin. Two commands, no build step:</p> <pre><code>/plugin marketplace add ActiveMemory/ctx\n/plugin install ctx@activememory-ctx\n</code></pre> <p>Six hooks. Twenty-five skills. Installed.</p> <p>For three releases, ctx required assembly. Clone the repo. Build the binary. Copy hook scripts into <code>.claude/hooks/</code>. Symlink skill files. Understand which shell scripts called which Go commands. Hope nothing broke when Claude Code updated its hook format.</p> <p>v0.6.0 ends that era. ctx ships as a Claude Marketplace plugin: hooks and skills served directly from source, installed with a single command, updated by pulling the repo. The tool that gives AI persistent memory is now as easy to install as the AI itself.</p> <p>But the plugin conversion was not just a packaging change. It was the forcing function that rewrote every shell hook in Go, eliminated the jq dependency, enabled <code>go test</code> coverage for hook logic, and made distribution a solved problem. When you fix how something ships, you end up fixing how it is built.</p> <p>The Release Window</p> <p>February 15 -- February 16, 2026</p> <p>From the v0.3.0 tag to commit <code>a3178bc</code>. 109 commits. 334 files changed. Version jumped from 0.3.0 to 0.6.0 to signal the magnitude.</p>","path":["ctx v0.6.0: The Integration Release"],"tags":[]},{"location":"blog/2026-02-16-ctx-v0.6.0-the-integration-release/#before-six-shell-scripts-and-a-prayer","level":2,"title":"Before: Six Shell Scripts and a Prayer","text":"<p>v0.3.0 had six hook scripts. Each was a Bash file that shelled out to <code>ctx</code> subcommands, parsed JSON with <code>jq</code>, and wired itself into Claude Code's hook system via <code>.claude/hooks/</code>:</p> <pre><code>.claude/hooks/\n├── check-context-size.sh\n├── check-persistence.sh\n├── check-journal.sh\n├── post-commit.sh\n├── block-non-path-ctx.sh\n└── cleanup-tmp.sh\n</code></pre> <p>This worked. It also meant:</p> <ul> <li>jq was a hard dependency. No jq, no hooks. macOS ships without it.</li> <li>No test coverage. Shell scripts were tested manually or not at all.</li> <li>Fragile deployment. <code>ctx init</code> had to scaffold <code>.claude/hooks/</code>   and <code>.claude/skills/</code> with the right paths, permissions, and structure.</li> <li>Version drift. Users who installed once never got hook updates   unless they re-ran init.</li> </ul> <p>The shell scripts were the right choice for prototyping. They were the wrong choice for distribution.</p>","path":["ctx v0.6.0: The Integration Release"],"tags":[]},{"location":"blog/2026-02-16-ctx-v0.6.0-the-integration-release/#after-one-plugin-zero-shell-scripts","level":2,"title":"After: One Plugin, Zero Shell Scripts","text":"<p>v0.6.0 replaces all six scripts with <code>ctx system</code> subcommands compiled into the binary:</p> Shell Script Go Subcommand <code>check-context-size.sh</code> <code>ctx system check-context-size</code> <code>check-persistence.sh</code> <code>ctx system check-persistence</code> <code>check-journal.sh</code> <code>ctx system check-journal</code> <code>post-commit.sh</code> <code>ctx system post-commit</code> <code>block-non-path-ctx.sh</code> <code>ctx system block-non-path-ctx</code> <code>cleanup-tmp.sh</code> <code>ctx system cleanup-tmp</code> <p>The plugin's <code>hooks.json</code> wires them to Claude Code events:</p> <pre><code>{\n  \"PreToolUse\": [\n    {\"matcher\": \"Bash\", \"command\": \"ctx system block-non-path-ctx\"},\n    {\"matcher\": \".*\", \"command\": \"ctx agent --budget 4000\"}\n  ],\n  \"PostToolUse\": [\n    {\"matcher\": \"Bash\", \"command\": \"ctx system post-commit\"}\n  ],\n  \"UserPromptSubmit\": [\n    {\"command\": \"ctx system check-context-size\"},\n    {\"command\": \"ctx system check-persistence\"},\n    {\"command\": \"ctx system check-journal\"}\n  ],\n  \"SessionEnd\": [\n    {\"command\": \"ctx system cleanup-tmp\"}\n  ]\n}\n</code></pre> <p>No jq. No shell scripts. No <code>.claude/hooks/</code> directory to manage. The hooks are Go functions with tests, compiled into the same binary you already have.</p>","path":["ctx v0.6.0: The Integration Release"],"tags":[]},{"location":"blog/2026-02-16-ctx-v0.6.0-the-integration-release/#the-plugin-model","level":2,"title":"The Plugin Model","text":"<p>The ctx plugin lives at <code>.claude-plugin/marketplace.json</code> in the repo. Claude Code's marketplace system handles discovery and installation. Skills are served directly from <code>internal/assets/claude/skills/</code>; there is no build step, no <code>make plugin</code>, no generated artifacts.</p> <p>This means:</p> <ol> <li>Install is two commands. Not \"clone, build, copy, configure.\"</li> <li>Updates are automatic. Pull the repo; the plugin reads from source.</li> <li>Skills and hooks are versioned together. No drift between what    the CLI expects and what the plugin provides.</li> <li><code>ctx init</code> is tool-agnostic. It creates <code>.context/</code> and nothing    else. No <code>.claude/</code> scaffolding, no assumptions about which AI tool    you use.</li> </ol> <p>That last point matters. Before v0.6.0, <code>ctx init</code> tried to set up Claude Code integration as part of initialization. That coupled the context system to a specific tool. Now, <code>ctx init</code> gives you persistent context. The plugin gives you Claude Code integration. They compose; they don't depend.</p>","path":["ctx v0.6.0: The Integration Release"],"tags":[]},{"location":"blog/2026-02-16-ctx-v0.6.0-the-integration-release/#beyond-the-plugin-what-else-shipped","level":2,"title":"Beyond the Plugin: What Else Shipped","text":"<p>The plugin conversion dominated the release, but 109 commits covered more ground.</p>","path":["ctx v0.6.0: The Integration Release"],"tags":[]},{"location":"blog/2026-02-16-ctx-v0.6.0-the-integration-release/#obsidian-vault-export","level":3,"title":"Obsidian Vault Export","text":"<pre><code>ctx journal obsidian\n</code></pre> <p>Generates a full Obsidian vault from enriched journal entries: wikilinks, MOC (Map of Content) pages, and graph-optimized cross-linking. If you already use Obsidian for notes, your AI session history now lives alongside everything else.</p>","path":["ctx v0.6.0: The Integration Release"],"tags":[]},{"location":"blog/2026-02-16-ctx-v0.6.0-the-integration-release/#encrypted-scratchpad","level":3,"title":"Encrypted Scratchpad","text":"<pre><code>ctx pad edit \"DATABASE_URL=postgres://...\"\nctx pad show\n</code></pre> <p>AES-256-GCM encrypted storage for sensitive one-liners. The encrypted blob commits to git; the key stays in <code>.gitignore</code>. Useful for connection strings, API keys, and other values that need to travel with the project without appearing in plaintext.</p>","path":["ctx v0.6.0: The Integration Release"],"tags":[]},{"location":"blog/2026-02-16-ctx-v0.6.0-the-integration-release/#security-hardening","level":3,"title":"Security Hardening","text":"<p>Three medium-severity findings from a security audit, now closed:</p> Finding Fix Path traversal via <code>--context-dir</code> Boundary validation: operations cannot escape project root (M-1) Symlink following in <code>.context/</code> <code>Lstat()</code> check before every file read/write (M-2) Predictable temp file paths User-specific temp directory under <code>$XDG_RUNTIME_DIR</code> (M-3) <p>Plus a new <code>/sanitize-permissions</code> skill that audits <code>settings.local.json</code> for overly broad Bash permissions.</p>","path":["ctx v0.6.0: The Integration Release"],"tags":[]},{"location":"blog/2026-02-16-ctx-v0.6.0-the-integration-release/#hooks-that-know-when-to-be-quiet","level":3,"title":"Hooks That Know When to Be Quiet","text":"<p>A subtle but important fix: hooks now no-op before <code>ctx init</code> has run. Previously, a fresh clone with no <code>.context/</code> would trigger hook errors on every prompt. Now, hooks detect the absence of a context directory and exit silently. Similarly, <code>ctx init</code> treats a <code>.context/</code> directory containing only logs as uninitialized and skips the overwrite prompt.</p> <p>Small changes. Large reduction in friction for new users.</p>","path":["ctx v0.6.0: The Integration Release"],"tags":[]},{"location":"blog/2026-02-16-ctx-v0.6.0-the-integration-release/#the-numbers","level":2,"title":"The Numbers","text":"Metric v0.3.0 v0.6.0 Skills 21 25 Shell hook scripts 6 0 Go system subcommands 0 6 External dependencies (hooks) jq, bash none Lines of Go ~14,000 ~37,000 Plugin install commands n/a 2 Security findings (open) 3 0 <code>ctx init</code> creates .claude/ yes no <p>The line count tripled. Most of that is documentation site HTML, Obsidian export logic, and the scratchpad encryption module. The core CLI grew modestly; the ecosystem around it grew substantially.</p>","path":["ctx v0.6.0: The Integration Release"],"tags":[]},{"location":"blog/2026-02-16-ctx-v0.6.0-the-integration-release/#what-v060-means","level":2,"title":"What v0.6.0 Means","text":"<p>v0.1.0 asked: \"Can we give AI persistent memory?\"</p> <p>v0.2.0 asked: \"Can we make that memory accessible to humans too?\"</p> <p>v0.3.0 asked: \"Can we make the quality self-enforcing?\"</p> <p>v0.6.0 asks: \"Can someone else actually use this?\"</p> <p>A tool that requires cloning a repo, building from source, and manually wiring hooks into the right directories is a tool for its author. A tool that installs with two commands from a marketplace is a tool for everyone.</p> <p>The version jumped from 0.3.0 to 0.6.0 because the delta is not incremental. The shell-to-Go rewrite, the plugin model, the security hardening, and the tool-agnostic init: together, they change what ctx is. Not a different tool, but a tool that is finally ready to leave the workshop.</p>","path":["ctx v0.6.0: The Integration Release"],"tags":[]},{"location":"blog/2026-02-16-ctx-v0.6.0-the-integration-release/#what-comes-next","level":2,"title":"What Comes Next","text":"<p>The plugin model opens the door to distribution patterns that were not possible before. Marketplace discovery means new users find ctx without reading a README. Plugin updates mean existing users get improvements without rebuilding.</p> <p>The next chapter is about what happens when persistent context is easy to install: adoption patterns, multi-project workflows, and whether the <code>.context/</code> convention can become infrastructure that other tools build on.</p> <p>But those are future posts.</p> <p>This one is about the release that turned a developer tool into a distributable product: two commands, zero shell scripts, and a presence on the Claude Marketplace.</p> <p>The Integration Release</p> <p>v0.1.0 shipped features. v0.2.0 shipped archaeology. v0.3.0 shipped discipline. v0.6.0 shipped the front door.</p> <p>The most important code in this release is the code you never have to copy.</p> <p>This post was drafted using <code>/ctx-blog-changelog</code> with access to the full git history between v0.3.0 and v0.6.0, release notes, and the plugin conversion PR. The meta continues.</p>","path":["ctx v0.6.0: The Integration Release"],"tags":[]},{"location":"blog/2026-02-17-code-is-cheap-judgment-is-not/","level":1,"title":"Code Is Cheap. Judgment Is Not.","text":"","path":["Code Is Cheap. Judgment Is Not."],"tags":[]},{"location":"blog/2026-02-17-code-is-cheap-judgment-is-not/#why-ai-replaces-effort-not-expertise","level":2,"title":"Why AI Replaces Effort, Not Expertise","text":"<p>Jose Alekhinne / February 17, 2026</p> <p>Are you worried about AI taking your job?</p> <p>You might be confusing the thing that's cheap with the thing that's valuable.</p> <p>I keep seeing the same conversation. Engineers, designers, writers: all asking the same question with the same dread: \"What happens when AI can do what I do?\"</p> <p>The question is wrong.</p> <p>AI does not replace workers. AI replaces unstructured effort. The distinction matters, and everything I have learned building <code>ctx</code> reinforces it.</p>","path":["Code Is Cheap. Judgment Is Not."],"tags":[]},{"location":"blog/2026-02-17-code-is-cheap-judgment-is-not/#the-three-confusions","level":2,"title":"The Three Confusions","text":"<p>People who feel doomed by AI usually confuse three things:</p> They confuse... With... Effort Value Typing Thinking Production Judgment <p>Effort is time spent. Value is the outcome that time produces. They are not the same, and they never were. AI just makes the gap impossible to ignore.</p> <p>Typing is mechanical. Thinking is directional. An AI can type faster than any human. It cannot decide what to type without someone framing the problem, sequencing the work, and evaluating the result.</p> <p>Production is making artifacts. Judgment is knowing which artifacts to make, in what order, to what standard, and when to stop. AI floods the system with production capacity. It does not flood the system with judgment.</p>","path":["Code Is Cheap. Judgment Is Not."],"tags":[]},{"location":"blog/2026-02-17-code-is-cheap-judgment-is-not/#code-is-nothing","level":2,"title":"Code Is Nothing","text":"<p>This sounds provocative until you internalize it:</p> <p>Code is cheap. Artifacts are cheap.</p> <p>An AI can generate a thousand lines of working code in minutes. It can scaffold a project, write tests, build a CI pipeline, draft documentation. The raw production of software artifacts is no longer the bottleneck.</p> <p>What is not cheap:</p> <ul> <li>Taste: knowing what belongs and what does not</li> <li>Framing: turning a vague goal into a concrete problem</li> <li>Sequencing: deciding what to build first and why</li> <li>Fanning out: breaking work into parallel streams that   converge</li> <li>Acceptance criteria: defining what \"done\" looks like before   starting</li> <li>Judgment: the thousand small decisions that separate code   that works from code that lasts</li> </ul> <p>These are the skills that direct production. They are human skills. Not because AI is incapable of learning them, but because they require something AI does not have: accountability for outcomes over time.</p>","path":["Code Is Cheap. Judgment Is Not."],"tags":[]},{"location":"blog/2026-02-17-code-is-cheap-judgment-is-not/#the-evidence-from-building-ctx","level":2,"title":"The Evidence From Building ctx","text":"<p>I did not arrive at this conclusion theoretically. I arrived at it by building a tool with an AI agent for three weeks and watching exactly where the human mattered.</p>","path":["Code Is Cheap. Judgment Is Not."],"tags":[]},{"location":"blog/2026-02-17-code-is-cheap-judgment-is-not/#yolo-mode-proved-production-is-cheap","level":3,"title":"YOLO Mode Proved Production Is Cheap","text":"<p>In Building ctx Using ctx, I documented the YOLO phase: auto-accept everything, let the AI ship features at full speed. It produced 14 commands in a week. Impressive output.</p> <p>The code worked. The architecture drifted. Magic strings accumulated. Conventions diverged. The AI was producing at a pace no human could match, and every artifact it produced was a small bet that nobody was evaluating.</p> <p>Production without judgment is not velocity. It is debt accumulation at speed.</p>","path":["Code Is Cheap. Judgment Is Not."],"tags":[]},{"location":"blog/2026-02-17-code-is-cheap-judgment-is-not/#the-31-ratio-proved-judgment-has-a-cadence","level":3,"title":"The 3:1 Ratio Proved Judgment Has a Cadence","text":"<p>In The 3:1 Ratio, the git history told the story: three sessions of forward momentum followed by one session of deliberate consolidation. The consolidation session is where the human applies judgment: reviewing what the AI built, catching drift, realigning conventions.</p> <p>The AI does the refactoring. The human decides what to refactor and when to stop. Without the human, the AI will refactor forever, improving things that do not matter and missing things that do.</p>","path":["Code Is Cheap. Judgment Is Not."],"tags":[]},{"location":"blog/2026-02-17-code-is-cheap-judgment-is-not/#the-attention-budget-proved-framing-is-scarce","level":3,"title":"The Attention Budget Proved Framing Is Scarce","text":"<p>In The Attention Budget, I explained why more context makes AI worse, not better. Every token competes for attention. Dump everything in and the AI sees nothing clearly.</p> <p>This is a framing problem. The human's job is to decide what the AI should focus on: what to include, what to exclude, what to emphasize. <code>ctx agent --budget 4000</code> is not just a CLI flag. It is a forcing function for human judgment about relevance.</p> <p>The AI processes. The human curates.</p>","path":["Code Is Cheap. Judgment Is Not."],"tags":[]},{"location":"blog/2026-02-17-code-is-cheap-judgment-is-not/#skills-design-proved-taste-is-load-bearing","level":3,"title":"Skills Design Proved Taste Is Load-Bearing","text":"<p>The skill trilogy (You Can't Import Expertise, The Anatomy of a Skill That Works) showed that the difference between a useful skill and a useless one is not craftsmanship. It is taste.</p> <p>A well-crafted skill with the wrong focus is worse than no skill at all: it consumes the attention budget with generic advice while the project-specific problems go unchecked. The E/A/R framework (Expert, Activation, Redundant) is a judgment tool. The AI cannot apply it to itself. The human evaluates what the AI already knows, what it needs to be told, and what is noise.</p>","path":["Code Is Cheap. Judgment Is Not."],"tags":[]},{"location":"blog/2026-02-17-code-is-cheap-judgment-is-not/#automation-discipline-proved-restraint-is-a-skill","level":3,"title":"Automation Discipline Proved Restraint Is a Skill","text":"<p>In Not Everything Is a Skill, the lesson was that the urge to automate is not the need to automate. A useful prompt does not automatically deserve to become a slash command. The human applies judgment about frequency, stability, and attention cost.</p> <p>The AI can build the skill. Only the human can decide whether it should exist.</p>","path":["Code Is Cheap. Judgment Is Not."],"tags":[]},{"location":"blog/2026-02-17-code-is-cheap-judgment-is-not/#defense-in-depth-proved-boundaries-require-judgment","level":3,"title":"Defense in Depth Proved Boundaries Require Judgment","text":"<p>In Defense in Depth, the entire security model for unattended AI agents came down to: markdown is not a security boundary. Telling an AI \"don't do bad things\" is production (of instructions). Setting up an unprivileged user in a network-isolated container is judgment (about risk).</p> <p>The AI follows instructions. The human decides which instructions are enforceable and which are wishful thinking.</p>","path":["Code Is Cheap. Judgment Is Not."],"tags":[]},{"location":"blog/2026-02-17-code-is-cheap-judgment-is-not/#parallel-agents-proved-scale-amplifies-the-gap","level":3,"title":"Parallel Agents Proved Scale Amplifies the Gap","text":"<p>In Parallel Agents and Merge Debt, the lesson was that multiplying agents multiplies output -- but it also multiplies the need for judgment. Five agents running in parallel produce five sessions of drift in one clock hour. The human who can frame tasks cleanly, define narrow acceptance criteria, and evaluate results quickly becomes the limiting factor.</p> <p>More agents do not reduce the need for judgment. They increase it.</p>","path":["Code Is Cheap. Judgment Is Not."],"tags":[]},{"location":"blog/2026-02-17-code-is-cheap-judgment-is-not/#the-two-reactions","level":2,"title":"The Two Reactions","text":"<p>When AI floods the system with cheap output, two things happen:</p> <p>Those who only produce: panic. If your value proposition is \"I write code,\" and an AI writes code faster, cheaper, and at higher volume, then the math is unfavorable. Not because AI took your job, but because your job was never the code. It was the judgment around the code, and you were not exercising it.</p> <p>Those who direct: accelerate. If your value proposition is \"I know what to build, in what order, to what standard,\" then AI is the best thing that ever happened to you. Production is no longer the bottleneck. Your ability to frame, sequence, evaluate, and course-correct is now the limiting factor on throughput.</p> <p>The gap between these two is not talent. It is awareness of where the value lives.</p>","path":["Code Is Cheap. Judgment Is Not."],"tags":[]},{"location":"blog/2026-02-17-code-is-cheap-judgment-is-not/#what-this-means-in-practice","level":2,"title":"What This Means in Practice","text":"<p>If you are an engineer reading this, the actionable insight is not \"learn prompt engineering\" or \"master AI tools.\" It is:</p> <p>Get better at the things AI cannot do.</p> AI does this well You need to do this Generate code Frame the problem Write tests Define acceptance criteria Scaffold projects Sequence the work Fix bugs from stack traces Evaluate tradeoffs Produce volume Exercise restraint Follow instructions Decide which instructions matter <p>The skills on the right column are not new. They are the same skills that have always separated senior engineers from junior ones. AI did not create the distinction. AI made it load-bearing.</p>","path":["Code Is Cheap. Judgment Is Not."],"tags":[]},{"location":"blog/2026-02-17-code-is-cheap-judgment-is-not/#if-anything-i-feel-empowered","level":2,"title":"If Anything, I Feel Empowered","text":"<p>I will end with something personal.</p> <p>I am not worried. I am empowered.</p> <p>Before <code>ctx</code>, I could think faster than I could produce. Ideas sat in a queue. The bottleneck was always \"I know what to build, but building it takes too long.\"</p> <p>Now the bottleneck is gone. Production is cheap. The queue is clearing. The limiting factor is how fast I can think, not how fast I can type.</p> <p>That is not a threat. That is the best force multiplier I have ever had.</p> <p>The people who feel threatened are confusing the accelerator for the replacement. AI does not replace the director. It gives the director a bigger orchestra.</p> <p>If you remember one thing from this post...</p> <p>Code is cheap. Judgment is not.</p> <p>AI replaces unstructured effort, not directed expertise. The skills that matter now are the same skills that have always mattered: taste, framing, sequencing, and the discipline to stop.</p> <p>The difference is that now, for the first time, those skills are the only bottleneck left.</p>","path":["Code Is Cheap. Judgment Is Not."],"tags":[]},{"location":"blog/2026-02-17-code-is-cheap-judgment-is-not/#the-arc","level":2,"title":"The Arc","text":"<p>This post is a retrospective. It synthesizes the thread running through every previous entry in this blog:</p> <ul> <li>Building ctx Using ctx showed that production   without direction creates debt</li> <li>Refactoring with Intent   showed that slowing down is not the opposite of progress</li> <li>The Attention Budget showed that curation   outweighs volume</li> <li>The skill trilogy showed that taste determines   whether a tool helps or hinders</li> <li>Not Everything Is a Skill showed that   restraint is a skill in itself</li> <li>Defense in Depth showed that instructions are   not boundaries</li> <li>The 3:1 Ratio showed that judgment has a schedule</li> <li> <p>Parallel Agents showed that scale amplifies   the gap between production and judgment</p> </li> <li> <p>Context as Infrastructure showed that the system   you build for context is infrastructure, not conversation</p> </li> </ul> <p>From YOLO mode to defense in depth, the pattern is the same: production is the easy part. Judgment is the hard part. AI changed the ratio, not the rule.</p> <p>This post synthesizes the thread running through every previous entry in this blog. The evidence is drawn from three weeks of building ctx with AI assistance, the decisions recorded in DECISIONS.md, the learnings captured in LEARNINGS.md, and the git history that tracks where the human mattered and where the AI ran unsupervised.</p> <p>See also: When a System Starts Explaining Itself -- what happens after the arc: the first field notes from the moment the system starts compounding in someone else's hands.</p>","path":["Code Is Cheap. Judgment Is Not."],"tags":[]},{"location":"blog/2026-02-17-context-as-infrastructure/","level":1,"title":"Context as Infrastructure","text":"","path":["Context as Infrastructure"],"tags":[]},{"location":"blog/2026-02-17-context-as-infrastructure/#why-your-ai-needs-a-filesystem-not-a-prompt","level":2,"title":"Why Your AI Needs a Filesystem, Not a Prompt","text":"<p>Jose Alekhinne / February 17, 2026</p> <p>Where does your AI's knowledge live between sessions?</p> <p>If the answer is \"in a prompt I paste at the start,\" you are treating context as a consumable. Something assembled, used, and discarded.</p> <p>What if you treated it as infrastructure instead?</p> <p>This post synthesizes a thread that has been running through every <code>ctx</code> blog post -- from the origin story to the attention budget to the discipline release. The thread is this: context is not a prompt problem. It is an infrastructure problem. And the tools we build for it should look more like filesystems than clipboard managers.</p>","path":["Context as Infrastructure"],"tags":[]},{"location":"blog/2026-02-17-context-as-infrastructure/#the-prompt-paradigm","level":2,"title":"The Prompt Paradigm","text":"<p>Most AI-assisted development treats context as ephemeral:</p> <ol> <li>Start a session.</li> <li>Paste your system prompt, your conventions, your current task.</li> <li>Work.</li> <li>Session ends. Everything evaporates.</li> <li>Next session: paste again.</li> </ol> <p>This works for short interactions. For sustained development -- where decisions compound over days and weeks -- it fails in three ways:</p> <p>It does not persist. A decision made on Tuesday must be re-explained on Wednesday. A learning captured in one session is invisible to the next.</p> <p>It does not scale. As the project grows, the \"paste everything\" approach hits the context window ceiling. You start triaging what to include, often cutting exactly the context that would have prevented the next mistake.</p> <p>It does not compose. A system prompt is a monolith. You cannot load part of it, update one section, or share a subset with a different workflow. It is all or nothing.</p> <p>The Copy-Paste Tax</p> <p>Every session that starts with pasting a prompt is paying a tax: the human time to assemble the context, the risk of forgetting something, and the silent assumption that yesterday's prompt is still accurate today.</p> <p>Over 70+ sessions, that tax compounds into a significant maintenance burden -- one that most developers absorb without questioning it.</p>","path":["Context as Infrastructure"],"tags":[]},{"location":"blog/2026-02-17-context-as-infrastructure/#the-infrastructure-paradigm","level":2,"title":"The Infrastructure Paradigm","text":"<p><code>ctx</code> takes a different approach. Context is not assembled per-session; it is maintained as persistent files in a <code>.context/</code> directory:</p> <pre><code>.context/\n  CONSTITUTION.md     # Inviolable rules\n  TASKS.md            # Current work items\n  CONVENTIONS.md      # Code patterns and standards\n  DECISIONS.md        # Architectural choices with rationale\n  LEARNINGS.md        # Gotchas and lessons learned\n  ARCHITECTURE.md     # System structure\n  GLOSSARY.md         # Domain terminology\n  AGENT_PLAYBOOK.md   # Operating manual for agents\n  journal/            # Enriched session summaries\n  archive/            # Completed work, cold storage\n</code></pre> <p>Each file has a single purpose. Each can be loaded independently. Each persists across sessions, tools, and team members.</p> <p>This is not a novel idea. It is the same idea behind every piece of infrastructure software engineers already use:</p> Traditional Infrastructure ctx Equivalent Database <code>.context/*.md</code> files Configuration files <code>CONSTITUTION.md</code> Environment variables <code>.contextrc</code> Log files <code>journal/</code> Schema migrations Decision records Deployment manifests <code>AGENT_PLAYBOOK.md</code> <p>The parallel is not metaphorical. Context files are infrastructure: they are versioned (git tracks them), they are structured (Markdown with conventions), they have schemas (required fields for decisions and learnings), and they have lifecycle management (archiving, compaction, indexing).</p>","path":["Context as Infrastructure"],"tags":[]},{"location":"blog/2026-02-17-context-as-infrastructure/#separation-of-concerns","level":2,"title":"Separation of Concerns","text":"<p>The most important design decision in <code>ctx</code> is not any individual feature. It is the separation of context into distinct files with distinct purposes.</p> <p>A single <code>CONTEXT.md</code> file would be simpler to implement. It would also be impossible to maintain.</p> <p>Why? Because different types of context have different lifecycles:</p> Context Type Changes Read By Load When Constitution Rarely Every session Always Tasks Every session Session start Always Conventions Weekly Before coding When writing code Decisions When decided When questioning When revisiting Learnings When learned When stuck When debugging Journal Every session Rarely When investigating <p>Loading everything into every session wastes the attention budget on context that is irrelevant to the current task. Loading nothing forces the AI to operate blind.</p> <p>Separation of concerns allows progressive disclosure: load the minimum that matters for this moment, with the option to load more when needed.</p> <pre><code># Session start: load the essentials\nctx agent --budget 4000\n\n# Deep investigation: load everything\ncat .context/DECISIONS.md\ncat .context/journal/2026-02-05-*.md\n</code></pre> <p>The filesystem is the index. File names, directory structure, and timestamps encode relevance. The AI does not need to read every file; it needs to know where to look.</p>","path":["Context as Infrastructure"],"tags":[]},{"location":"blog/2026-02-17-context-as-infrastructure/#the-two-tier-persistence-model","level":2,"title":"The Two-Tier Persistence Model","text":"<p><code>ctx</code> uses two tiers of persistence, and the distinction is architectural:</p> Tier Purpose Location Token Cost Curated Quick context reload <code>.context/*.md</code> Low (budgeted) Full dump Safety net, archaeology <code>.context/journal/*.md</code> Zero (not auto-loaded) <p>The curated tier is what the AI sees at session start. It is optimized for signal density: structured entries, indexed tables, reverse-chronological order (newest first, so the most relevant content survives truncation).</p> <p>The full dump tier is for humans and for deep investigation. It contains everything: enriched journals, archived tasks. It is never auto-loaded because its volume would destroy attention density.</p> <p>This two-tier model is analogous to how traditional systems separate hot and cold storage. The hot path (curated context) is optimized for read performance -- measured not in milliseconds, but in tokens consumed per unit of useful information. The cold path (journal) is optimized for completeness.</p> <p>Nothing Is Ever Truly Lost</p> <p>The full dump tier means that context does not need to be perfect -- it just needs to be findable.</p> <p>A decision that was not captured in DECISIONS.md can be recovered from the session transcript where it was discussed. A learning that was not formalized can be found in the journal entry from that day.</p> <p>The curated tier is the fast path. The full dump tier is the safety net.</p>","path":["Context as Infrastructure"],"tags":[]},{"location":"blog/2026-02-17-context-as-infrastructure/#decision-records-as-first-class-citizens","level":2,"title":"Decision Records as First-Class Citizens","text":"<p>One of the patterns that emerged from <code>ctx</code>'s own development is the power of structured decision records.</p> <p>v0.1.0 allowed adding decisions as one-liners:</p> <pre><code>ctx add decision \"Use PostgreSQL\"\n</code></pre> <p>v0.2.0 enforced structure:</p> <pre><code>ctx add decision \"Use PostgreSQL\" \\\n  --context \"Need a reliable database for user data\" \\\n  --rationale \"ACID compliance, team familiarity\" \\\n  --consequences \"Need connection pooling, team training\"\n</code></pre> <p>The difference is not cosmetic. A one-liner decision teaches the AI what was decided. A structured decision teaches it why -- and why is what prevents the AI from unknowingly reversing the decision in a future session.</p> <p>This is infrastructure thinking: decisions are not notes. They are records with required fields, just like database rows have schemas. The enforcement exists because incomplete records are worse than no records -- they create false confidence that the context is captured when it is not.</p>","path":["Context as Infrastructure"],"tags":[]},{"location":"blog/2026-02-17-context-as-infrastructure/#the-ide-is-the-interface-decision","level":2,"title":"The \"IDE Is the Interface\" Decision","text":"<p>Early in <code>ctx</code>'s development, there was a temptation to build a custom UI: a web dashboard for browsing sessions, editing context, viewing analytics.</p> <p>The decision was no. The IDE is the interface.</p> <pre><code># This is the ctx \"UI\":\ncode .context/\n</code></pre> <p>This decision was not about minimalism for its own sake. It was about recognizing that <code>.context/</code> files are just files -- and files have a mature, well-understood infrastructure:</p> <ul> <li>Version control: <code>git diff .context/DECISIONS.md</code> shows exactly   what changed and when.</li> <li>Search: Your IDE's full-text search works across all context files.</li> <li>Editing: Markdown in any editor, with preview, spell check,   and syntax highlighting.</li> <li>Collaboration: Pull requests on context files work the same as   pull requests on code.</li> </ul> <p>Building a custom UI would have meant maintaining a parallel infrastructure that duplicates what every IDE already provides. It would have introduced its own bugs, its own update cycle, and its own learning curve.</p> <p>The filesystem is not a limitation. It is the most mature, most composable, most portable infrastructure available.</p> <p>Context Files in Git</p> <p>Because <code>.context/</code> lives in the repository, context changes are part of the commit history. A decision made in commit <code>abc123</code> is as traceable as a code change in the same commit.</p> <p>This is not possible with prompt-based context, which exists outside version control entirely.</p>","path":["Context as Infrastructure"],"tags":[]},{"location":"blog/2026-02-17-context-as-infrastructure/#progressive-disclosure-for-ai","level":2,"title":"Progressive Disclosure for AI","text":"<p>The concept of progressive disclosure comes from human interface design: show the user the minimum needed to make progress, with the option to drill deeper.</p> <p><code>ctx</code> applies the same principle to AI context:</p> Level What the AI Sees Token Cost When Level 0 <code>ctx status</code> (one-line summary) ~100 Quick check Level 1 <code>ctx agent --budget 4000</code> ~4,000 Normal work Level 2 <code>ctx agent --budget 8000</code> ~8,000 Complex tasks Level 3 Direct file reads 10,000+ Deep investigation <p>Each level trades tokens for depth. Level 1 is sufficient for most work: the AI knows the active tasks, the key conventions, and the recent decisions. Level 3 is for archaeology: understanding why a decision was made three weeks ago, or finding a pattern in the session history.</p> <p>The explicit <code>--budget</code> flag is the mechanism that makes this work. Without it, the default behavior would be to load everything (because more context feels safer), which destroys the attention density that makes the loaded context useful.</p> <p>The constraint is the feature. A budget of 4,000 tokens forces <code>ctx</code> to prioritize ruthlessly: constitution first, then tasks, then conventions, then decisions, then learnings -- in that order, cutting off when the budget is exhausted.</p>","path":["Context as Infrastructure"],"tags":[]},{"location":"blog/2026-02-17-context-as-infrastructure/#the-philosophical-shift","level":2,"title":"The Philosophical Shift","text":"<p>The shift from \"context as prompt\" to \"context as infrastructure\" changes how you think about AI-assisted development:</p> Prompt Thinking Infrastructure Thinking \"What do I paste today?\" \"What has changed since yesterday?\" \"How do I fit everything in?\" \"What's the minimum that matters?\" \"The AI forgot my conventions\" \"The conventions are in a file\" \"I need to re-explain\" \"I need to update the record\" \"This session is getting slow\" \"Time to compact and archive\" <p>The first column treats AI interaction as a conversation. The second treats it as a system -- one that can be maintained, optimized, and debugged.</p> <p>Context is not something you give the AI. It is something you maintain -- like a database, like a config file, like any other piece of infrastructure that a running system depends on.</p>","path":["Context as Infrastructure"],"tags":[]},{"location":"blog/2026-02-17-context-as-infrastructure/#beyond-ctx-the-principles","level":2,"title":"Beyond ctx: The Principles","text":"<p>The patterns that <code>ctx</code> implements are not specific to <code>ctx</code>. They are applicable to any project that uses AI-assisted development:</p> <ol> <li> <p>Separate context by purpose. Do not put everything in one file.    Different types of information have different lifecycles and    different relevance windows.</p> </li> <li> <p>Make context persistent. If a decision matters, write it down    in a file that survives the session. If a learning matters, capture    it with structure.</p> </li> <li> <p>Budget explicitly. Know how much context you are loading and    whether it is worth the attention cost.</p> </li> <li> <p>Use the filesystem. File names, directory structure, and    timestamps are metadata that the AI can navigate. A well-organized    directory is an index that costs zero tokens to maintain.</p> </li> <li> <p>Version your context. Put context files in git. Changes to    decisions are as important as changes to code.</p> </li> <li> <p>Design for degradation. Sessions will get long. Attention will    dilute. Build mechanisms (compaction, archiving, cooldowns) that    make degradation visible and manageable.</p> </li> </ol> <p>These are not <code>ctx</code> features. They are infrastructure principles that happen to be implemented as a CLI tool. Any team could implement them with nothing more than a directory convention and a few shell scripts.</p> <p>The tool is a convenience. The principles are what matter.</p> <p>If you remember one thing from this post...</p> <p>Prompts are conversations. Infrastructure persists.</p> <p>Your AI does not need a better prompt. It needs a filesystem: versioned, structured, budgeted, and maintained.</p> <p>The best context is the context that was there before you started the session.</p>","path":["Context as Infrastructure"],"tags":[]},{"location":"blog/2026-02-17-context-as-infrastructure/#the-arc","level":2,"title":"The Arc","text":"<p>This post is the architectural companion to the Attention Budget. That post explained why context must be curated (token economics). This one explains how to structure it (filesystem, separation of concerns, persistence tiers).</p> <p>Together with Code Is Cheap, Judgment Is Not, they form a trilogy about what matters in AI-assisted development:</p> <ul> <li>Attention Budget: the resource you're managing</li> <li>Context as Infrastructure: the system you build to manage it</li> <li>Code Is Cheap: the human skill that no system replaces</li> </ul> <p>And the practices that keep it all honest:</p> <ul> <li>The 3:1 Ratio: the cadence for maintaining both   code and context</li> <li>IRC as Context: the historical precedent -- stateless   protocols have always needed stateful wrappers</li> </ul> <p>This post synthesizes ideas from across the ctx blog series: the attention budget primitive, the two-tier persistence model, the IDE decision, and the progressive disclosure pattern. The principles are drawn from three weeks of building ctx and 70+ sessions of treating context as infrastructure rather than conversation.</p> <p>See also: When a System Starts Explaining Itself -- what happens when this infrastructure starts compounding in someone else's environment.</p>","path":["Context as Infrastructure"],"tags":[]},{"location":"blog/2026-02-17-parallel-agents-merge-debt-and-the-myth-of-overnight-progress/","level":1,"title":"Parallel Agents, Merge Debt, and the Myth of Overnight Progress","text":"","path":["Parallel Agents, Merge Debt, and the Myth of Overnight Progress"],"tags":[]},{"location":"blog/2026-02-17-parallel-agents-merge-debt-and-the-myth-of-overnight-progress/#when-the-screen-looks-like-progress","level":2,"title":"When the Screen Looks Like Progress","text":"<p>Jose Alekhinne / 2026-02-17</p> <p>How Many Terminals Are too Many?</p> <p>You discover agents can run in parallel.</p> <p>So you open ten... </p> <p>...Then twenty.</p> <p>The fans spin. Tokens burn. The screen looks like progress.</p> <p>It is NOT progress.</p> <p>There is a phase every builder goes through:</p> <ul> <li>The tooling gets fast enough. </li> <li>The model gets good enough. </li> <li>The temptation becomes irresistible: <ul> <li>more agents, more output, faster delivery.</li> </ul> </li> </ul> <p>So you open terminals. You spawn agents. You watch tokens stream across multiple windows simultaneously, and it feels like multiplication.</p> <p>It is not multiplication.</p> <p>It is merge debt being manufactured in real time.</p> <p>The <code>ctx</code> Manifesto says it plainly:</p> <p>Activity is not impact. Code is not progress.</p> <p>This post is about what happens when you take that seriously in the context of parallel agent workflows.</p>","path":["Parallel Agents, Merge Debt, and the Myth of Overnight Progress"],"tags":[]},{"location":"blog/2026-02-17-parallel-agents-merge-debt-and-the-myth-of-overnight-progress/#the-unit-of-scale-is-not-the-agent","level":2,"title":"The Unit of Scale Is Not the Agent","text":"<p>The naive model says:</p> <p>More agents -&gt; more output -&gt; faster delivery</p> <p>The production model says:</p> <p>Clean context boundaries -&gt; less interference -&gt; higher throughput</p> <p>Parallelism only works when the cognitive surfaces do not overlap.</p> <p>If two agents touch the same files, you did not create parallelism: You created a conflict generator.</p> <p>They will:</p> <ul> <li>Revert each other's changes;</li> <li>Relint each other's formatting;</li> <li>Refactor the same function in different directions.</li> </ul> <p>You watch with 🍿. Nothing ships.</p> <p>This is the same insight from the worktrees post: partition by blast radius, not by priority. </p> <p>Two tasks that touch the same files belong in the same track, no matter how  important the other one is. The constraint is file overlap. </p> <p>Everything else is scheduling.</p>","path":["Parallel Agents, Merge Debt, and the Myth of Overnight Progress"],"tags":[]},{"location":"blog/2026-02-17-parallel-agents-merge-debt-and-the-myth-of-overnight-progress/#the-five-agent-rule","level":2,"title":"The \"Five Agent\" Rule","text":"<p>In practice there is a ceiling.</p> <p>Around five or six concurrent agents:</p> <ul> <li>Token burn becomes noticeable;</li> <li>Supervision cost rises;</li> <li>Coordination noise increases;</li> <li>Returns flatten.</li> </ul> <p>This is not a model limitation:  This is a human merge bandwidth limitation.</p> <p>You are the bottleneck, not the silicon.</p> <p>The attention budget applies to you too: </p> <p>Every additional agent is another stream of output you need to comprehend, verify, and integrate. Your attention density drops the same way the model's does when you overload its context window.</p> <p>Five agents producing verified, mergeable change beats twenty agents producing merge conflicts you spend a day untangling.</p>","path":["Parallel Agents, Merge Debt, and the Myth of Overnight Progress"],"tags":[]},{"location":"blog/2026-02-17-parallel-agents-merge-debt-and-the-myth-of-overnight-progress/#role-separation-beats-file-locking","level":2,"title":"Role Separation Beats File Locking","text":"<p>Real parallelism comes from task topology, not from tooling.</p> <p>Good:</p> Agent Role Touches 1 Documentation <code>docs/</code>, <code>hack/</code> 2 Security scan Read-only audit 3 Implementation <code>internal/cli/</code> 4 Enhancement requests Read-only, files issues <p>Bad:</p> <ul> <li>Four agents editing the same implementation surface</li> </ul> <p>Context is the Boundary</p> <ul> <li>The goal is not to keep agents busy. </li> <li>The goal is to keep contexts isolated.</li> </ul> <p>This is what the codebase audit got right: </p> <ul> <li>Eight agents, all read-only, each analyzing a different dimension. </li> <li>Zero file overlap.</li> <li>Zero merge conflicts. </li> <li>Eight reports that composed cleanly because no agent interfered with another.</li> </ul>","path":["Parallel Agents, Merge Debt, and the Myth of Overnight Progress"],"tags":[]},{"location":"blog/2026-02-17-parallel-agents-merge-debt-and-the-myth-of-overnight-progress/#when-terminals-stop-scaling","level":2,"title":"When Terminals Stop Scaling","text":"<p>There is a moment when more windows stop helping.</p> <p>That is the signal. Not to add orchestration. But to introduce:</p> <pre><code>git worktree\n</code></pre> <p>Because now you are no longer parallelizing execution; you are parallelizing state.</p> <p>State Scales, Windows Don't</p> <ul> <li>State isolation is the real scaling. </li> <li>Window multiplication is theater.</li> </ul> <p>The worktrees post covers the mechanics: </p> <ul> <li>Sibling directories;</li> <li>Branch naming; </li> <li>The inevitable <code>TASKS.md</code> conflicts; </li> <li>The 3-4 worktree ceiling. </li> </ul> <p>The principle underneath is older than <code>git</code>:</p> <p>Shared mutable state is the enemy of parallelism. </p> <p>Always has been.</p> <p>Always will be.</p>","path":["Parallel Agents, Merge Debt, and the Myth of Overnight Progress"],"tags":[]},{"location":"blog/2026-02-17-parallel-agents-merge-debt-and-the-myth-of-overnight-progress/#the-overnight-loop-illusion","level":2,"title":"The Overnight Loop Illusion","text":"<p>Autonomous night runs are impressive.</p> <p>You sleep. The machine produces thousands of lines.</p> <p>In the morning:</p> <ul> <li>You read;</li> <li>You untangle;</li> <li>You reconstruct intent;</li> <li>You spend a day making it shippable.</li> </ul> <p>In retrospect, nothing was accelerated. </p> <p>The bottleneck moved from typing to comprehension.</p> <p>The Comprehension Tax</p> <p>If understanding the output costs more than producing it, the loop is a net loss.</p> <p>Progress is not measured in generated code. Progress is measured in verified, mergeable change.</p> <p>The <code>ctx</code> Manifesto calls this out directly:</p> <p>Verified reality is the scoreboard.</p> <p>The only truth that compounds is verified change in the real world.</p> <p>An overnight run that produces 3,000 lines nobody reviewed is not 3,000 lines of progress: It is 3,000 lines of liability until someone verifies every one of them. </p> <p>And that someone is (insert drumroll here) you: </p> <p>The same bottleneck that was supposedly being bypassed.</p>","path":["Parallel Agents, Merge Debt, and the Myth of Overnight Progress"],"tags":[]},{"location":"blog/2026-02-17-parallel-agents-merge-debt-and-the-myth-of-overnight-progress/#skills-that-fight-the-platform","level":2,"title":"Skills That Fight the Platform","text":"<p>Most marketplace skills are prompt decorations:</p> <ul> <li>They rephrase what the base model already knows;</li> <li>They increase token usage; </li> <li>They reduce clarity:</li> <li>They introduce behavioral drift.</li> </ul> <p>We covered this in depth in Skills That Fight the Platform: judgment suppression, redundant guidance, guilt-tripping, phantom dependencies, universal triggers: Five patterns that make agents worse, not better.</p> <p>A real skill does one of these:</p> <ul> <li>Encodes workflow state;</li> <li>Enforces invariants;</li> <li>Reduces decision branching.</li> </ul> <p>Everything else is packaging.</p> <p>The anatomy post established the criteria: quality gates, negative triggers, examples over rules, skills as contracts. </p> <p>If a skill doesn't meet those criteria... </p> <ul> <li>It is either a recipe (document it in <code>hack/</code>); </li> <li>Or noise (delete it);</li> <li>There is no third option.</li> </ul>","path":["Parallel Agents, Merge Debt, and the Myth of Overnight Progress"],"tags":[]},{"location":"blog/2026-02-17-parallel-agents-merge-debt-and-the-myth-of-overnight-progress/#hooks-are-context-that-execute","level":2,"title":"Hooks Are Context That Execute","text":"<p>The most valuable skills are not prompts:</p> <p>They are constraints embedded in the toolchain.</p> <p>For example: the agent cannot push.</p> <p><code>git push</code> becomes:</p> <p>Stop. A human reviews first.</p> <p>A commit without verification becomes:</p> <p>Did you run tests? Did you run linters? What exactly are you shipping?</p> <p>This is not safety theater; this is intent preservation.</p> <p>The  thing the <code>ctx</code> Manifesto calls \"encoding intent into the environment.\"</p> <p>The Eight Ways a Hook Can Talk catalogued the full spectrum: from silent enrichment to hard blocks. </p> <p>The key insight was that hooks are not just safety rails:  They are context that survives execution.</p> <p>They are the difference between an agent that remembers the rules  and one that enforces them.</p>","path":["Parallel Agents, Merge Debt, and the Myth of Overnight Progress"],"tags":[]},{"location":"blog/2026-02-17-parallel-agents-merge-debt-and-the-myth-of-overnight-progress/#complexity-is-a-tax","level":2,"title":"Complexity Is a Tax","text":"<p>Every extra layer adds cognitive weight:</p> <ul> <li>Orchestration frameworks;</li> <li>Meta agents;</li> <li>Autonomous planning systems...</li> </ul> <p>If a single terminal works, stay there.</p> <p>If five isolated agents work, stop there.</p> <p>Add structure only when a real bottleneck appears. </p> <p>NOT when an influencer suggests one.</p> <p>This is the same lesson from Not Everything Is a Skill:</p> <p>The best automation decision is sometimes not to automate.</p> <p>A recipe in a Markdown file costs nothing until you use it. </p> <p>An orchestration framework costs attention on every run, whether it helps or not.</p>","path":["Parallel Agents, Merge Debt, and the Myth of Overnight Progress"],"tags":[]},{"location":"blog/2026-02-17-parallel-agents-merge-debt-and-the-myth-of-overnight-progress/#literature-is-throughput","level":2,"title":"Literature Is Throughput","text":"<p>Clear writing is not aesthetic: It is compression.</p> <p>Better articulation means:</p> <ul> <li>Fewer tokens;</li> <li>Fewer misinterpretations;</li> <li>Faster convergence.</li> </ul> <p>The attention budget taught us that context is a finite resource with a quadratic cost. </p> <p>Language determines how fast you spend context. </p> <p>A well-written task description that takes 50 tokens outperforms a rambling one that takes 200: Not just because it is cheaper, but because it leaves more  headroom for the model to actually think.</p> <p>Literature is NOT Overrated</p> <ul> <li>Attention is a finite budget. </li> <li>Language determines how fast you spend it.</li> </ul>","path":["Parallel Agents, Merge Debt, and the Myth of Overnight Progress"],"tags":[]},{"location":"blog/2026-02-17-parallel-agents-merge-debt-and-the-myth-of-overnight-progress/#the-real-metric","level":2,"title":"The Real Metric","text":"<p>The real metric is not:</p> <ul> <li>Lines generated;</li> <li>Agents running;</li> <li>Tasks completed while you sleep.</li> </ul> <p>But:</p> <p>Time from idea to verified, mergeable, production change.</p> <p>Everything else is motion.</p> <p>The entire blog series has been circling this point: </p> <ul> <li>The attention budget was about spending tokens wisely. </li> <li>The skills trilogy was about not wasting them on prompt   decoration.</li> <li>The worktrees post was about multiplying throughput   without multiplying interference. </li> <li>The discipline release was about what a release looks   like when polish outweighs features: 3:1.</li> </ul> <p>Every post has arrived (and made me converge) at the same answer so far: </p> <p>The metric is verified change, not generated output.</p>","path":["Parallel Agents, Merge Debt, and the Myth of Overnight Progress"],"tags":[]},{"location":"blog/2026-02-17-parallel-agents-merge-debt-and-the-myth-of-overnight-progress/#ctx-was-never-about-spawning-more-minds","level":2,"title":"<code>ctx</code> Was Never About Spawning More Minds","text":"<p><code>ctx</code> is about:</p> <ul> <li>Isolating context;</li> <li>Preserving intent;</li> <li>Making progress composable.</li> </ul> <p>Parallel agents are powerful. But only when you respect the boundaries that make parallelism real.</p> <p>Otherwise, you are not scaling cognition; you are scaling interference.</p> <p>The Manifesto's thesis holds:</p> <p>Without ctx, intelligence resets. With ctx, creation compounds.</p> <p>Compounding requires structure. </p> <p>Structure requires boundaries.</p> <p>Boundaries require the discipline to stop adding agents when five is enough.</p>","path":["Parallel Agents, Merge Debt, and the Myth of Overnight Progress"],"tags":[]},{"location":"blog/2026-02-17-parallel-agents-merge-debt-and-the-myth-of-overnight-progress/#practical-summary","level":2,"title":"Practical Summary","text":"<p>A production workflow tends to converge to this:</p> Practice Why Stay in one terminal unless necessary Minimize coordination overhead Spawn a small number of agents with non-overlapping responsibilities Conflict avoidance &gt; parallelism Isolate state with worktrees when surfaces grow State isolation is real scaling Encode verification into hooks Intent that survives execution Avoid marketplace prompt cargo cults Skills are contracts, not decorations Measure merge cost, not generation speed The metric is verified change <p>This is slower to watch. Faster to ship.</p> <p>If you remember one thing from this post...</p> <p>Progress is not what the machine produces while you sleep.</p> <p>Progress is what survives contact with the main branch.</p> <p>See also: Code Is Cheap. Judgment Is Not. -- the argument that production capacity was never the bottleneck, and why multiplying agents amplifies the need for human judgment rather than replacing it.</p>","path":["Parallel Agents, Merge Debt, and the Myth of Overnight Progress"],"tags":[]},{"location":"blog/2026-02-17-the-3-1-ratio/","level":1,"title":"The 3:1 Ratio","text":"","path":["The 3:1 Ratio"],"tags":[]},{"location":"blog/2026-02-17-the-3-1-ratio/#scheduling-consolidation-in-ai-development","level":2,"title":"Scheduling Consolidation in AI Development","text":"<p>Jose Alekhinne / February 17, 2026</p> <p>How often should you stop building and start cleaning?</p> <p>Every developer knows technical debt exists. Every developer postpones dealing with it.</p> <p>AI-assisted development makes the problem worse -- not because the AI writes bad code, but because it writes code so fast that drift accumulates before you notice.</p> <p>In Refactoring with Intent, I mentioned a ratio that worked for me: 3:1. Three YOLO sessions create enough surface area to reveal patterns. The fourth session turns those patterns into structure.</p> <p>That was an observation. This post is the evidence.</p>","path":["The 3:1 Ratio"],"tags":[]},{"location":"blog/2026-02-17-the-3-1-ratio/#the-observation","level":2,"title":"The Observation","text":"<p>During the first two weeks of building <code>ctx</code>, I noticed a rhythm in my own productivity. Feature sessions felt great: new commands, new capabilities, visible progress. But after three of them, things would start to feel sticky: variable names that almost made sense, files that had grown past their purpose, patterns that repeated without being formalized.</p> <p>The fourth session -- when I stopped adding and started cleaning -- was always the most painful to start and the most satisfying to finish.</p> <p>It was also the one that made the next three feature sessions faster.</p>","path":["The 3:1 Ratio"],"tags":[]},{"location":"blog/2026-02-17-the-3-1-ratio/#the-evidence-git-history","level":2,"title":"The Evidence: Git History","text":"<p>The <code>ctx</code> git history between January 20 and February 7 tells a clear story when you categorize commits:</p> Week Feature commits Consolidation commits Ratio Jan 20-26 18 5 3.6:1 Jan 27-Feb 1 14 6 2.3:1 Feb 1-7 15 35+ 0.4:1 <p>The first week was pure YOLO. Almost four feature commits for every consolidation commit. The codebase grew fast.</p> <p>The second week started to self-correct. The ratio dropped as refactoring sessions became necessary -- not scheduled, but forced by friction.</p> <p>The third week inverted entirely. v0.3.0 was almost entirely consolidation: the skill migration, the sweep, the documentation standardization. Thirty-five quality commits against fifteen features.</p> <p>The debt from weeks one and two was paid in week three.</p> <p>The Compounding Problem</p> <p>Consolidation debt compounds. Week one's drift doesn't just persist into week two -- it accelerates, because new features are built on top of drifted patterns.</p> <p>By week three, the cost of consolidation was higher than it would have been if spread evenly.</p>","path":["The 3:1 Ratio"],"tags":[]},{"location":"blog/2026-02-17-the-3-1-ratio/#what-drift-actually-looks-like","level":2,"title":"What Drift Actually Looks Like","text":"<p>\"Drift\" sounds abstract. Here is what it looked like concretely in the <code>ctx</code> codebase after three weeks of feature-heavy development:</p>","path":["The 3:1 Ratio"],"tags":[]},{"location":"blog/2026-02-17-the-3-1-ratio/#predicate-naming","level":3,"title":"Predicate Naming","text":"<p>Convention says boolean functions should be named <code>HasX</code>, <code>IsX</code>, <code>CanX</code>. After three feature sprints:</p> <pre><code>// What accumulated:\nfunc CheckIfEnabled() bool    // should be IsEnabled\nfunc ValidateFormat() bool    // should be HasValidFormat\nfunc TestConnection() bool    // should be CanConnect\nfunc VerifyExists() bool      // should be Exists or HasFile\nfunc EnsureReady() bool       // should be IsReady\n</code></pre> <p>Five violations. Not bugs -- but friction that compounds every time someone (human or AI) reads the code and has to infer the naming convention from inconsistent examples.</p>","path":["The 3:1 Ratio"],"tags":[]},{"location":"blog/2026-02-17-the-3-1-ratio/#magic-strings","level":3,"title":"Magic Strings","text":"<pre><code>// Week 1: acceptable prototype\nif entry.Type == \"task\" {\n    filename = \"TASKS.md\"\n}\n\n// Week 3: same pattern in 7+ files\n// Now it's a maintenance liability\n</code></pre> <p>When the same literal appears in seven files, changing it means finding all seven. Missing one means a silent runtime bug. Constants exist to prevent exactly this -- but during feature velocity, nobody stops to extract them.</p> <p>Refactoring with Intent documented the constants consolidation that cleaned this up. The 3:1 ratio is the practice that prevents it from accumulating again.</p>","path":["The 3:1 Ratio"],"tags":[]},{"location":"blog/2026-02-17-the-3-1-ratio/#hardcoded-permissions","level":3,"title":"Hardcoded Permissions","text":"<pre><code>os.WriteFile(path, data, 0644)  // 80+ instances\nos.MkdirAll(path, 0755)         // scattered across packages\n</code></pre> <p>Eighty-plus instances of hardcoded file permissions. Not wrong -- but if we ever need to change the default (and we did, for hook scripts that need execute permissions), it means a codebase-wide search.</p> <p>Drift Is Not Bugs</p> <p>None of these are bugs. The code works. Tests pass.</p> <p>But drift creates false confidence: the codebase looks consistent until you try to change something and discover that five different conventions exist for the same concept.</p>","path":["The 3:1 Ratio"],"tags":[]},{"location":"blog/2026-02-17-the-3-1-ratio/#why-you-cannot-consolidate-on-day-one","level":2,"title":"Why You Cannot Consolidate on Day One","text":"<p>The temptation is to front-load quality: write all the conventions, enforce all the checks, prevent all the drift before it happens.</p> <p>This fails for two reasons.</p> <p>First, you do not know what will drift. Predicate naming violations only become a convention check after you notice three different naming patterns competing. Magic strings only become a consolidation target after you change a literal and discover it exists in seven places.</p> <p>The conventions emerge from the work. They cannot precede it.</p> <p>This is what You Can't Import Expertise meant in practice: the consolidation checks grow from the project's own drift history. You cannot write them on day one because you do not yet know what will drift.</p> <p>Second, premature consolidation slows discovery. During the prototyping phase, the goal is to explore the design space. Enforcing strict conventions on code that might be deleted tomorrow is waste. YOLO mode has its place -- the problem is not YOLO itself, but YOLO without scheduled cleanup.</p> <p>The Consolidation Paradox</p> <p>You need drift history to know what to consolidate.</p> <p>You need consolidation to prevent drift from compounding.</p> <p>The 3:1 ratio resolves this paradox: let drift accumulate for three sessions (enough to see patterns), then consolidate in the fourth (before the patterns become entrenched).</p>","path":["The 3:1 Ratio"],"tags":[]},{"location":"blog/2026-02-17-the-3-1-ratio/#the-consolidation-skill","level":2,"title":"The Consolidation Skill","text":"<p>The <code>ctx</code> project now has a <code>/consolidate</code> skill that encodes nine project-specific checks:</p> Check What It Catches Predicate naming Boolean functions not using Has/Is/Can Magic strings Repeated literals not in config constants File permissions Hardcoded 0644/0755 not using constants Godoc style Missing or non-standard documentation File length Files exceeding 400 lines Large functions Functions exceeding 80 lines Template drift Live skills diverging from templates Import organization Non-standard import grouping TODO/FIXME staleness Old markers that are no longer relevant <p>This is not a generic linter. These are project-specific conventions that emerged from <code>ctx</code>'s own development history. A generic code quality tool would catch some of them. Only a project-specific check catches all of them -- because some of them (predicate naming, template drift) are conventions that exist nowhere except in this project's <code>CONVENTIONS.md</code>.</p>","path":["The 3:1 Ratio"],"tags":[]},{"location":"blog/2026-02-17-the-3-1-ratio/#the-decision-matrix","level":2,"title":"The Decision Matrix","text":"<p>Not all drift needs immediate consolidation. Here is the matrix I use:</p> Signal Action Same literal in 3+ files Extract to constant Same code block in 3+ places Extract to helper Naming convention violated 5+ times Fix and document rule File exceeds 400 lines Split by concern Convention exists but is regularly violated Strengthen enforcement Pattern exists only in one place Leave it alone Code works but is \"ugly\" Leave it alone <p>The last two rows matter. Consolidation is about reducing maintenance cost, not achieving aesthetic perfection. Code that works and exists in one place does not benefit from consolidation -- it benefits from being left alone until it earns its refactoring.</p>","path":["The 3:1 Ratio"],"tags":[]},{"location":"blog/2026-02-17-the-3-1-ratio/#consolidation-as-context-hygiene","level":2,"title":"Consolidation as Context Hygiene","text":"<p>There is a parallel between code consolidation and context management that became clear during the <code>ctx</code> development:</p> Code Consolidation Context Hygiene Extract magic strings Archive completed tasks Standardize naming Keep DECISIONS.md current Remove dead code Compact old sessions Update stale comments Review LEARNINGS.md for staleness Check template drift Verify CONVENTIONS.md matches code <p><code>ctx compact</code> does for context what consolidation does for code: it moves completed work to cold storage, keeping the active context clean and focused. The attention budget applies to both the AI's context window and the developer's mental model of the codebase.</p> <p>When context files accumulate stale entries, the AI's attention is wasted on completed tasks and outdated conventions. When code accumulates drift, the developer's attention is wasted on inconsistencies that obscure the actual logic.</p> <p>Both are solved by the same discipline: periodic, scheduled cleanup.</p> <p>This is also why parallel agents make the problem harder, not easier. Three agents running simultaneously produce three sessions' worth of drift in one clock hour. The consolidation cadence needs to match the output rate, not the calendar.</p>","path":["The 3:1 Ratio"],"tags":[]},{"location":"blog/2026-02-17-the-3-1-ratio/#the-practice","level":2,"title":"The Practice","text":"<p>Here is how the 3:1 ratio works in practice for <code>ctx</code> development:</p> <p>Sessions 1-3: Feature work</p> <ul> <li>Add new capabilities</li> <li>Write tests for new code</li> <li>Do not stop for cleanup unless something is actively broken</li> <li>Note drift as you see it (a comment, a task, a mental note)</li> </ul> <p>Session 4: Consolidation</p> <ul> <li>Run <code>/consolidate</code> to surface accumulated drift</li> <li>Fix the highest-impact items first</li> <li>Update CONVENTIONS.md if new patterns emerged</li> <li>Archive completed tasks</li> <li>Review LEARNINGS.md for anything that became a convention</li> </ul> <p>The key insight is that session 4 is not optional. It is not \"if we have time.\" It is scheduled with the same priority as feature work.</p> <p>The cost of skipping it is not visible immediately. It becomes visible three sessions later, when the next consolidation session takes twice as long because the drift compounded.</p>","path":["The 3:1 Ratio"],"tags":[]},{"location":"blog/2026-02-17-the-3-1-ratio/#what-the-ratio-is-not","level":2,"title":"What the Ratio Is Not","text":"<p>The 3:1 ratio is not a universal law. It is an empirical observation from one project with one developer working with AI assistance.</p> <p>Different projects will have different ratios. A mature codebase with strong conventions might sustain 5:1 or higher. A greenfield prototype might need 2:1. A team of multiple developers with different styles might need 1:1.</p> <p>The number is less important than the practice: consolidation is not a reaction to problems. It is a scheduled activity.</p> <p>If you wait for drift to cause pain before consolidating, you have already paid the compounding cost.</p> <p>If you remember one thing from this post...</p> <p>Three sessions of building. One session of cleaning.</p> <p>Not because the code is dirty -- but because drift compounds silently, and the only way to catch it is to look for it on a schedule.</p> <p>The ratio is the schedule.</p>","path":["The 3:1 Ratio"],"tags":[]},{"location":"blog/2026-02-17-the-3-1-ratio/#the-arc-so-far","level":2,"title":"The Arc So Far","text":"<p>This post sits at a crossroads in the <code>ctx</code> story. Looking back:</p> <ul> <li>Building ctx Using ctx documented the YOLO sprint   that created the initial codebase</li> <li>Refactoring with Intent introduced the 3:1 ratio   as an observation from the first cleanup</li> <li>The Attention Budget explained why drift   matters -- every token of inconsistency consumes the same finite   resource as useful context</li> <li>You Can't Import Expertise showed that   consolidation checks must grow from the project, not a template</li> <li>The Discipline Release proved the ratio works at release   scale: 35 quality commits to 15 feature commits</li> </ul> <p>And looking forward: the same principle applies to context files, to documentation, and to the merge debt that parallel agents produce. Drift is drift, whether it lives in code, in <code>.context/</code>, or in the gap between what your docs say and what your code does.</p> <p>The ratio is the schedule. The schedule is the discipline.</p> <p>This post was drafted from git log analysis of the ctx repository, mapping every commit from January 20 to February 7 into feature vs consolidation categories. The patterns described are drawn from the project's CONVENTIONS.md, LEARNINGS.md, and the <code>/consolidate</code> skill's check list.</p>","path":["The 3:1 Ratio"],"tags":[]},{"location":"blog/2026-02-17-when-a-system-starts-explaining-itself/","level":1,"title":"When a System Starts Explaining Itself","text":"","path":["When a System Starts Explaining Itself"],"tags":[]},{"location":"blog/2026-02-17-when-a-system-starts-explaining-itself/#field-notes-from-the-moment-a-private-workflow-becomes-portable","level":2,"title":"Field Notes from the Moment a Private Workflow Becomes Portable","text":"<p>Jose Alekhinne / February 17, 2026</p> <p>How Do You Know Something Is Working?</p> <p>Not from metrics. Not from GitHub stars. Not from praise.</p> <p>You know, deep in your heart, that it works when people start describing it wrong.</p>","path":["When a System Starts Explaining Itself"],"tags":[]},{"location":"blog/2026-02-17-when-a-system-starts-explaining-itself/#the-first-external-signals","level":2,"title":"The First External Signals","text":"<p>Every new substrate begins as a private advantage:</p> <ul> <li>It lives inside one mind</li> <li>One repository</li> <li>One set of habits</li> </ul> <p>It is fast. It is not yet real.</p> <p>Reality begins when other people describe it in their own language:</p> <ul> <li>Not accurately</li> <li>Not consistently</li> <li>But involuntarily</li> </ul> <p>The early reports arrived without coordination:</p> <p>Better Tasks</p> <p>\"I do not know how, but this creates better tasks than my AI plugin.\"</p> <p>I See Butterflies</p> <p>\"This is better than Adderall.\"</p> <p>Dear Manager...</p> <p>\"Promotion packet? Done. What is next?\"</p> <p>What Is It? Can I Eat It?</p> <p>\"Is this a skill?\" 🦋 </p> <p>Why the Cloak and Dagger?</p> <p>\"Why is this not in the marketplace?\"</p> <p>And then something more important happened:</p> <p>Someone else started making a video!</p> <p>That was the boundary.</p> <p><code>ctx</code> no longer required its creator to be present in order to exist.</p>","path":["When a System Starts Explaining Itself"],"tags":[]},{"location":"blog/2026-02-17-when-a-system-starts-explaining-itself/#misclassification-is-a-sign-of-a-new-primitive","level":2,"title":"Misclassification Is a Sign of a New Primitive","text":"<p>When a tool is understood, it is categorized:</p> <ul> <li>Editor</li> <li>Framework</li> <li>Task manager</li> <li>Plugin</li> </ul> <p>When a substrate appears, it is misclassified:</p> <p>\"Is this a skill?\" 🦋</p> <p>The question is correct. The category is wrong.</p> <ul> <li>Skills live in people.</li> <li>Infrastructure lives in the environment.</li> </ul> <p>ctx Is not a Skill: It is a Form of Relief</p> <p>What early adopters experience is not an ability.</p> <p>It is the removal of a cognitive constraint.</p> <p>This is the same distinction that emerged in the skills trilogy:</p> <ul> <li>A skill is a contract between a human and an agent.  </li> <li>Infrastructure is the ground both stand on.</li> </ul> <p>You do not use infrastructure.</p> <p>You habitualize it.</p>","path":["When a System Starts Explaining Itself"],"tags":[]},{"location":"blog/2026-02-17-when-a-system-starts-explaining-itself/#the-pharmacological-metaphor","level":2,"title":"The Pharmacological Metaphor","text":"<p>\"Better than Adderall\" is not praise.</p> <p>It is a diagnostic:</p> <p>Executive function has been externalized.</p> <ul> <li>The system is not making the user work harder.  </li> <li>It is restoring continuity.</li> </ul> <p>From the primitive context of wetware:</p> <ul> <li>Continuity feels like focus</li> <li>Focus feels like discipline</li> </ul> <p>If it walks like a duck and quacks like a duck, it is a duck.</p> <p>Discipline is usually simulated.</p> <p>Infrastructure makes the simulation unnecessary.</p> <p>The attention budget explained why context degrades:</p> <ul> <li>Attention density drops as volume grows;</li> <li>The middle gets lost;</li> <li>Sessions end and everything evaporates.</li> </ul> <p>The pharmacological metaphor says the same thing from the user’s lens:</p> <p>Save the Cheerleader, Save the World</p> <p>The symptom of lost context is lost focus.</p> <p>Restore the context. Restore the focus.</p> <p>IRC bouncers solved this for chat twenty years ago. <code>ctx</code> solves it for cognition.</p>","path":["When a System Starts Explaining Itself"],"tags":[]},{"location":"blog/2026-02-17-when-a-system-starts-explaining-itself/#throughput-on-ambiguous-work","level":2,"title":"Throughput on Ambiguous Work","text":"<p>Finishing a promotion packet quickly is not a productivity story.</p> <p>It is the collapse of reconstruction cost.</p> <p>Most complex work is not execution. It is:</p> <ul> <li>Remembering why something mattered;</li> <li>Recovering prior decisions;</li> <li>Rebuilding mental state.</li> </ul> <p>Persistent context removes that tax.</p> <p>Velocity appears as a side effect.</p> <p>This Is the Two-Tier Model in Practice</p> <p>The two-tier persistence model</p> <ul> <li>Curated context for fast reload</li> <li>Full journal for archaeology</li> </ul> <p>is what makes this possible.</p> <ul> <li>The user does not notice the system.  </li> <li>They notice that the reconstruction cost disappeared.</li> </ul>","path":["When a System Starts Explaining Itself"],"tags":[]},{"location":"blog/2026-02-17-when-a-system-starts-explaining-itself/#the-moment-of-portability","level":2,"title":"The Moment of Portability","text":"<p>The system becomes real when two things happen:</p> <ol> <li>It can be installed as a versioned artifact</li> <li>It survives contact with a hostile, real codebase</li> </ol> <p>This is why the first integration into a living system matters more than any landing page.</p> <p>Demos prove possibility.</p> <p>Diffs prove reality.</p> <p>The Manifesto calls this out directly:</p> <p>Verified reality is the scoreboard.</p>","path":["When a System Starts Explaining Itself"],"tags":[]},{"location":"blog/2026-02-17-when-a-system-starts-explaining-itself/#the-split-voice","level":2,"title":"The Split Voice","text":"<p>A new substrate requires two channels.</p> <p>The embodied voice:</p> <p>Here is what changed in my actual work.</p> <p>The out of body voice:</p> <p>Here is what this means.</p> <p>One produces trust.</p> <p>The other produces understanding.</p> <p>Neither is sufficient alone.</p> <p>This entire blog has been the second voice.</p> <p>The origin story was the first. The refactoring post was the first. Every release note with concrete diffs was the first.</p> <p>This is the first second.</p>","path":["When a System Starts Explaining Itself"],"tags":[]},{"location":"blog/2026-02-17-when-a-system-starts-explaining-itself/#systems-that-generate-explainers","level":2,"title":"Systems That Generate Explainers","text":"<p>Tools are used.</p> <p>Platforms are extended.</p> <p>Substrates are explained.</p> <p>The first unsolicited explainer is a brittle phase change.</p> <p>It means the idea has become portable between minds.</p> <p>That is the beginning of an ecosystem.</p>","path":["When a System Starts Explaining Itself"],"tags":[]},{"location":"blog/2026-02-17-when-a-system-starts-explaining-itself/#the-absence-of-metrics","level":2,"title":"The Absence of Metrics","text":"<p>Metrics do not matter at this stage.</p> <p>Dashboards are noise.</p> <p>The whole premise of <code>ctx</code> is the ruthless elimination of noise.</p> <p>Numbers optimize funnels; substrates alter cognition.</p> <p>The only valid measurement is *irreversible reality:</p> <ul> <li>A merged PR;</li> <li>A reproducible install;</li> <li>A decision that is never re-litigated.</li> </ul> <p>The merge debt post reached the same conclusion from  another direction:</p> <p>The metric is the verified change, not generated output.</p> <p>For adoption, the same rule applies:</p> <p>The metric is altered behavior, not download counts.</p>","path":["When a System Starts Explaining Itself"],"tags":[]},{"location":"blog/2026-02-17-when-a-system-starts-explaining-itself/#what-is-actually-happening","level":2,"title":"What Is Actually Happening","text":"<p>A private advantage is becoming an environmental property:</p> <p>The system is moving from...</p> <p>personal workflow,</p> <p>to...</p> <p>a *shared infrastructure for thought.</p> <p>Not by growth.  </p> <p>Not by marketing.</p> <p>By altering how real systems evolve.</p> <p>If you remember one thing from this post...</p> <p>You do not know a substrate is real when people praise it.</p> <p>You know it is real when:</p> <ul> <li>They describe it incorrectly;</li> <li>They depend on it unintentionally;</li> <li>They start teaching it to others.</li> </ul> <p>That is the moment the system begins explaining itself.</p>","path":["When a System Starts Explaining Itself"],"tags":[]},{"location":"blog/2026-02-17-when-a-system-starts-explaining-itself/#the-arc","level":2,"title":"The Arc","text":"<p>Every previous post looked inward.</p> <p>This one looks outward.</p> <ul> <li>Building ctx Using ctx: one mind, one repository</li> <li>The Attention Budget: the constraint</li> <li>Context as Infrastructure: the architecture</li> <li>Code Is Cheap. Judgment Is Not.: the bottleneck</li> </ul> <p>This post is the field report from the other side of that bottleneck:</p> <p>The moment the infrastructure compounds in someone else's hands.</p> <p>The arc is not complete.</p> <p>It is becoming portable.</p> <p>These field notes were written the same day the feedback arrived. The quotes are real. Real users. Real codebases. No names. No metrics. No funnel. Only the signal that something shifted.</p>","path":["When a System Starts Explaining Itself"],"tags":[]},{"location":"recipes/","level":1,"title":"Recipes","text":"<p>Workflow recipes showing how <code>ctx</code> commands and skills work together.</p> <p>Each recipe solves a specific problem by combining multiple tools into a step-by-step workflow.</p> <p>Commands vs. Skills</p> <p>Commands (<code>ctx status</code>, <code>ctx add task</code>) run in your terminal.</p> <p>Skills (<code>/ctx-reflect</code>, <code>/ctx-next</code>) run inside your AI coding assistant.</p> <p>Recipes combine both.</p> <p>Think of commands as structure and skills as behavior.</p>","path":["Recipes"],"tags":[]},{"location":"recipes/#guide-your-agent","level":2,"title":"Guide Your Agent","text":"<p>These recipes show explicit commands and skills, but agents trained on the <code>ctx</code> playbook are proactive: they offer to save learnings after debugging, record decisions after trade-offs, create follow-up tasks after completing work, and suggest what to work on next.</p> <p>Your questions train the agent. Asking \"what have we learned?\" or \"is our context clean?\" does two things: </p> <ul> <li>It triggers the workflow right now, </li> <li>and it reinforces the pattern. </li> </ul> <p>The more you guide, the more the agent habituates the behavior and begins  offering on its own.</p> <p>Each recipe includes a Conversational Approach section showing these natural-language patterns.</p> <p>Tip</p> <p>Don't wait passively for proactive behavior: especially in early sessions. </p> <p>Ask, guide, reinforce. Over time, you ask less and  the agent offers more.</p>","path":["Recipes"],"tags":[]},{"location":"recipes/#getting-started","level":2,"title":"Getting Started","text":"","path":["Recipes"],"tags":[]},{"location":"recipes/#setting-up-ctx-across-ai-tools","level":3,"title":"Setting Up ctx Across AI Tools","text":"<p>Initialize <code>ctx</code> and configure hooks for Claude Code, Cursor, Aider, Copilot, or Windsurf. Includes shell completion, watch mode for non-native tools, and verification.</p> <p>Uses: <code>ctx init</code>, <code>ctx hook</code>, <code>ctx agent</code>, <code>ctx completion</code>, <code>ctx watch</code></p>","path":["Recipes"],"tags":[]},{"location":"recipes/#keeping-context-in-a-separate-repo","level":3,"title":"Keeping Context in a Separate Repo","text":"<p>Store context files outside the project tree: in a private repo, shared directory, or anywhere else. Useful for open source projects with private context or multi-repo setups.</p> <p>Uses: <code>ctx init</code>, <code>--context-dir</code>, <code>--allow-outside-cwd</code>, <code>.contextrc</code>, <code>/ctx-status</code></p>","path":["Recipes"],"tags":[]},{"location":"recipes/#daily-workflow","level":2,"title":"Daily Workflow","text":"<p>These recipes cover the workflows you will use every day when working with ctx.</p>","path":["Recipes"],"tags":[]},{"location":"recipes/#the-complete-session","level":3,"title":"The Complete Session","text":"<p>Walk through a full <code>ctx</code> session from start to finish: loading context, picking what to work on, committing with context capture, reflecting, and saving a snapshot.</p> <p>Uses: <code>ctx status</code>, <code>ctx agent</code>, <code>/ctx-remember</code>, <code>/ctx-next</code>, <code>/ctx-commit</code>, <code>/ctx-reflect</code></p>","path":["Recipes"],"tags":[]},{"location":"recipes/#tracking-work-across-sessions","level":3,"title":"Tracking Work Across Sessions","text":"<p>Add, prioritize, complete, snapshot, and archive tasks. Keep <code>TASKS.md</code> focused as your project evolves across dozens of sessions.</p> <p>Uses: <code>ctx add task</code>, <code>ctx complete</code>, <code>ctx tasks archive</code>, <code>ctx tasks snapshot</code>, <code>/ctx-add-task</code>, <code>/ctx-archive</code>, <code>/ctx-next</code></p>","path":["Recipes"],"tags":[]},{"location":"recipes/#persisting-decisions-learnings-and-conventions","level":3,"title":"Persisting Decisions, Learnings, and Conventions","text":"<p>Record architectural decisions with rationale, capture gotchas and lessons learned, and codify coding conventions so they survive across sessions and team members.</p> <p>Uses: <code>ctx add decision</code>, <code>ctx add learning</code>, <code>ctx add convention</code>, <code>ctx decisions reindex</code>, <code>ctx learnings reindex</code>, <code>/ctx-add-decision</code>, <code>/ctx-add-learning</code>, <code>/ctx-add-convention</code>, <code>/ctx-reflect</code></p>","path":["Recipes"],"tags":[]},{"location":"recipes/#syncing-scratchpad-notes-across-machines","level":3,"title":"Syncing Scratchpad Notes Across Machines","text":"<p>Distribute your scratchpad encryption key, push and pull encrypted notes via git, and resolve merge conflicts when two machines edit simultaneously.</p> <p>Uses: <code>ctx init</code>, <code>ctx pad</code>, <code>ctx pad resolve</code>, <code>scp</code></p>","path":["Recipes"],"tags":[]},{"location":"recipes/#using-the-scratchpad","level":3,"title":"Using the Scratchpad","text":"<p>Use the encrypted scratchpad for quick notes, working memory, and sensitive values during AI sessions. Natural language in, encrypted storage out.</p> <p>Uses: <code>ctx pad</code>, <code>/ctx-pad</code>, <code>ctx pad show</code>, <code>ctx pad edit</code></p>","path":["Recipes"],"tags":[]},{"location":"recipes/#maintenance","level":2,"title":"Maintenance","text":"","path":["Recipes"],"tags":[]},{"location":"recipes/#hook-output-patterns","level":3,"title":"Hook Output Patterns","text":"<p>Choose the right output pattern for your Claude Code hooks: <code>VERBATIM</code> relay for user-facing reminders, hard gates for invariants, agent directives for nudges, and five more patterns across the spectrum.</p> <p>Uses: ctx plugin hooks, <code>settings.local.json</code></p>","path":["Recipes"],"tags":[]},{"location":"recipes/#claude-code-permission-hygiene","level":3,"title":"Claude Code Permission Hygiene","text":"<p>Keep <code>.claude/settings.local.json</code> clean: recommended safe defaults, what to never pre-approve, and a maintenance workflow for cleaning up session debris.</p> <p>Uses: <code>ctx init</code>, <code>/ctx-drift</code>, <code>/sanitize-permissions</code>, <code>ctx permissions snapshot</code>, <code>ctx permissions restore</code></p>","path":["Recipes"],"tags":[]},{"location":"recipes/#permission-snapshots","level":3,"title":"Permission Snapshots","text":"<p>Capture a known-good permission baseline as a golden image, then restore at session start to automatically drop session-accumulated permissions.</p> <p>Uses: <code>ctx permissions snapshot</code>, <code>ctx permissions restore</code>, <code>/sanitize-permissions</code></p>","path":["Recipes"],"tags":[]},{"location":"recipes/#detecting-and-fixing-drift","level":3,"title":"Detecting and Fixing Drift","text":"<p>Keep context files accurate by detecting structural drift (stale paths, missing files, stale file ages) and task staleness. Includes alignment audits to verify documentation claims match agent instructions.</p> <p>Uses: <code>ctx drift</code>, <code>ctx sync</code>, <code>ctx compact</code>, <code>ctx status</code>, <code>/ctx-drift</code>, <code>/ctx-alignment-audit</code>, <code>/ctx-status</code>, <code>/ctx-prompt-audit</code></p>","path":["Recipes"],"tags":[]},{"location":"recipes/#history-and-discovery","level":2,"title":"History and Discovery","text":"","path":["Recipes"],"tags":[]},{"location":"recipes/#browsing-and-enriching-past-sessions","level":3,"title":"Browsing and Enriching Past Sessions","text":"<p>Export your AI session history to a browsable journal site. Normalize rendering, enrich entries with metadata, and search across months of work.</p> <p>Uses: <code>ctx recall list/show/export</code>, <code>ctx journal site</code>, <code>ctx journal obsidian</code>, <code>ctx serve</code>, <code>/ctx-recall</code>, <code>/ctx-journal-normalize</code>, <code>/ctx-journal-enrich</code>, <code>/ctx-journal-enrich-all</code></p>","path":["Recipes"],"tags":[]},{"location":"recipes/#advanced","level":2,"title":"Advanced","text":"","path":["Recipes"],"tags":[]},{"location":"recipes/#running-an-unattended-ai-agent","level":3,"title":"Running an Unattended AI Agent","text":"<p>Set up a loop where an AI agent works through tasks overnight without you at the keyboard, using ctx for persistent memory between iterations.</p> <p>This recipe shows how <code>ctx</code> supports long-running agent loops without losing context or intent.</p> <p>Uses: <code>ctx init --ralph</code>, <code>ctx loop</code>, <code>ctx watch</code>, <code>ctx load</code>, <code>/ctx-loop</code>, <code>/ctx-implement</code>, <code>/ctx-context-monitor</code></p>","path":["Recipes"],"tags":[]},{"location":"recipes/#when-to-use-a-team-of-agents","level":3,"title":"When to Use a Team of Agents","text":"<p>Decision framework for choosing between a single agent, parallel worktrees, and a full agent team. </p> <p>This recipe covers the file overlap test, when teams make things worse, and  what ctx provides at each level.</p> <p>Uses: <code>/ctx-worktree</code>, <code>/ctx-next</code>, <code>ctx status</code></p>","path":["Recipes"],"tags":[]},{"location":"recipes/#parallel-agent-development-with-git-worktrees","level":3,"title":"Parallel Agent Development with Git Worktrees","text":"<p>Split a large backlog across 3-4 agents using git worktrees, each on its own branch and working directory. Group tasks by file overlap, work in parallel, merge back.</p> <p>Uses: <code>/ctx-worktree</code>, <code>/ctx-next</code>, <code>git worktree</code>, <code>git merge</code></p>","path":["Recipes"],"tags":[]},{"location":"recipes/#turning-activity-into-content","level":3,"title":"Turning Activity into Content","text":"<p>Generate blog posts from project activity, write changelog posts from commit ranges, and publish a browsable journal site from your session history. </p> <p>The output is generic Markdown, but the skills are tuned for the <code>ctx</code>-style  blog artifacts you see on this website.</p> <p>Uses: <code>ctx journal site</code>, <code>ctx journal obsidian</code>, <code>ctx serve</code>, <code>ctx recall export</code>, <code>/ctx-blog</code>, <code>/ctx-blog-changelog</code>, <code>/ctx-journal-enrich</code>, <code>/ctx-journal-normalize</code></p>","path":["Recipes"],"tags":[]},{"location":"recipes/autonomous-loops/","level":1,"title":"Running an Unattended AI Agent","text":"","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#problem","level":2,"title":"Problem","text":"<p>You have a project with a clear list of tasks, and you want an AI agent to work through them autonomously: overnight, unattended, without you sitting at the keyboard.</p> <p>Each iteration needs to remember what the previous one did, mark tasks as completed, and know when to stop.</p> <p>Without persistent memory, every iteration starts fresh and the loop collapses. With <code>ctx</code>, each iteration can pick up where the last one left off, but only if the agent persists its context as part of the work.</p> <p>This is the key insight: unattended operation works because the agent treats context persistence as a first-class deliverable, not an afterthought.</p> <p>TL;DR</p> <pre><code>ctx init --ralph                                  # 1. init for unattended mode\n# Edit TASKS.md with phased work items\nctx loop --tool claude --max-iterations 10        # 2. generate loop.sh\n./loop.sh 2&gt;&amp;1 | tee /tmp/loop.log &amp;              # 3. run the loop\nctx watch --log /tmp/loop.log                      # 4. process context updates\n# Next morning:\nctx status &amp;&amp; ctx load                             # 5. review results\n</code></pre> <p>Read on for permissions, isolation, and completion signals.</p>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#commands-and-skills-used","level":2,"title":"Commands and Skills Used","text":"Tool Type Purpose <code>ctx init --ralph</code> Command Initialize project for unattended operation (no human in the loop) <code>ctx loop</code> Command Generate the loop shell script <code>ctx watch</code> Command Monitor AI output and persist context updates <code>ctx load</code> Command Display assembled context (for debugging) <code>/ctx-loop</code> Skill Generate loop script from inside Claude Code <code>/ctx-implement</code> Skill Execute a plan step-by-step with verification <code>/ctx-context-monitor</code> Skill Automated context capacity alerts during long sessions","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#the-workflow","level":2,"title":"The Workflow","text":"","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#step-1-initialize-for-unattended-operation","level":3,"title":"Step 1: Initialize for Unattended Operation","text":"<p>Start by creating a <code>.context/</code> directory configured so the agent can work without human input. The <code>--ralph</code> flag sets up <code>PROMPT.md</code> so the agent makes reasonable choices instead of asking clarifying questions.</p> <pre><code>ctx init --ralph\n````\n\nThis creates `.context/` with the template files, a `PROMPT.md` configured for\nautonomous iteration, and seeds Claude Code permissions in\n`.claude/settings.local.json`. Install the ctx plugin for hooks and skills.\n\nWithout `--ralph`, the agent will often pause when requirements are unclear.\nFor unattended runs, you want it to choose a default and document the trade-off\nin `DECISIONS.md` instead.\n\n### Step 2: Populate TASKS.md with Phased Work\n\nOpen `.context/TASKS.md` and organize your work into phases. The agent works\nthrough these systematically, top to bottom, using priority tags to break ties.\n\n```markdown\n# Tasks\n\n## Phase 1: Foundation\n\n- [ ] Set up project structure and build system `#priority:high`\n- [ ] Configure testing framework `#priority:high`\n- [ ] Create CI pipeline `#priority:medium`\n\n## Phase 2: Core Features\n\n- [ ] Implement user registration `#priority:high`\n- [ ] Add email verification `#priority:high`\n- [ ] Create password reset flow `#priority:medium`\n\n## Phase 3: Hardening\n\n- [ ] Add rate limiting to API endpoints `#priority:medium`\n- [ ] Improve error messages `#priority:low`\n- [ ] Write integration tests `#priority:medium`\n</code></pre> <p>Phased organization matters because it gives the agent natural boundaries. Phase 1 tasks should be completable without Phase 2 code existing yet.</p>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#step-3-configure-promptmd","level":3,"title":"Step 3: Configure PROMPT.md","text":"<p>The <code>--ralph</code> flag generates a <code>PROMPT.md</code> that instructs the agent to operate autonomously:</p> <ol> <li>Read <code>.context/CONSTITUTION.md</code> first (hard rules, never violated)</li> <li>Load context from <code>.context/</code> files</li> <li>Pick one task per iteration</li> <li>Complete the task and update context files</li> <li>Commit changes (including <code>.context/</code>)</li> <li>Signal status with a completion signal</li> </ol> <p>You can customize <code>PROMPT.md</code> for your project. The critical parts are the one-task-per-iteration discipline, proactive context persistence, and completion signals at the end:</p> <pre><code>## Signal Status\n\nEnd your response with exactly ONE of:\n\n- `SYSTEM_CONVERGED` — All tasks in TASKS.md are complete (this is the\n  signal the loop script detects by default)\n- `SYSTEM_BLOCKED` — Cannot proceed, need human input (explain why)\n- (no signal) — More work remains, continue to next iteration\n\nNote: the loop script only checks for `SYSTEM_CONVERGED` by default.\n`SYSTEM_BLOCKED` is a convention for the human reviewing the log.\n</code></pre>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#step-4-configure-permissions","level":3,"title":"Step 4: Configure Permissions","text":"<p>An unattended agent needs permission to use tools without prompting. By default, Claude Code asks for confirmation on file writes, bash commands, and other operations, which stops the loop and waits for a human who is not there.</p> <p>There are two approaches.</p>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#option-a-explicit-allowlist-recommended","level":4,"title":"Option A: Explicit Allowlist (Recommended)","text":"<p>Grant only the permissions the agent needs. In <code>.claude/settings.local.json</code>:</p> <pre><code>{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(make:*)\",\n      \"Bash(go:*)\",\n      \"Bash(git:*)\",\n      \"Bash(ctx:*)\",\n      \"Read\",\n      \"Write\",\n      \"Edit\"\n    ]\n  }\n}\n</code></pre> <p>Adjust the <code>Bash</code> patterns for your project's toolchain. The agent can run <code>make</code>, <code>go</code>, <code>git</code>, and <code>ctx</code> commands but cannot run arbitrary shell commands.</p> <p>This is recommended even in sandboxed environments because it limits blast radius.</p>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#option-b-skip-all-permission-checks","level":4,"title":"Option B: Skip All Permission Checks","text":"<p>Claude Code supports a <code>--dangerously-skip-permissions</code> flag that disables all permission prompts:</p> <pre><code>claude --dangerously-skip-permissions -p \"$(cat .context/PROMPT.md)\"\n</code></pre> <p>This flag means what it says</p> <p>With <code>--dangerously-skip-permissions</code>, the agent can execute any shell command, write to any file, and make network requests without confirmation.</p> <p>Only use this on a sandboxed machine: ideally a virtual machine with no access to host credentials, no SSH keys, and no access to production systems.</p> <p>If you would not give an untrusted intern <code>sudo</code> on this machine, do not use this flag.</p>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#enforce-isolation-at-the-os-level","level":4,"title":"Enforce Isolation at the OS Level","text":"<p>Do not skip this section</p> <p>This is not optional hardening. An unattended agent with unrestricted OS access is an unattended shell with unrestricted OS access. The allowlist above is a strong first layer, but do not rely on a single runtime boundary.</p> <p>The only controls an agent cannot override are the ones enforced by the operating system, the container runtime, or the hypervisor.</p> <p>For unattended runs, enforce isolation at the infrastructure level:</p> Layer What to enforce User account Run the agent as a dedicated unprivileged user with no <code>sudo</code> access and no membership in privileged groups (<code>docker</code>, <code>wheel</code>, <code>adm</code>). Filesystem Restrict the project directory via POSIX permissions or ACLs. The agent should have no access to other users' files or system directories. Container Run inside a Docker/Podman sandbox. Mount only the project directory. Drop capabilities (<code>--cap-drop=ALL</code>). Disable network if not needed (<code>--network=none</code>). Never mount the Docker socket and do not run privileged containers. Prefer rootless containers. Virtual machine Prefer a dedicated VM with no shared folders, no host passthrough, and no keys to other machines. Network If the agent does not need the internet, disable outbound access entirely. If it does, restrict to specific domains via firewall rules. Resource limits Apply CPU, memory, and disk limits (cgroups/container limits). A runaway loop should not fill disk or consume all RAM. Self-modification Make instruction files read-only. <code>CLAUDE.md</code>, <code>.claude/settings.local.json</code>, and <code>.context/CONSTITUTION.md</code> should not be writable by the agent user. If using project-local hooks, protect those too. <p>A minimal Docker setup for overnight runs:</p> <pre><code>docker run --rm \\\n  --network=none \\\n  --cap-drop=ALL \\\n  --memory=4g \\\n  --cpus=2 \\\n  -v /path/to/project:/workspace \\\n  -w /workspace \\\n  your-dev-image \\\n  ./loop.sh 2&gt;&amp;1 | tee /tmp/loop.log\n</code></pre> <p>Defense in depth</p> <p>Use multiple layers together: OS-level isolation (the boundary the agent cannot cross), a permission allowlist (what Claude Code will do within that boundary), and <code>CONSTITUTION.md</code> (a soft nudge for the common case).</p>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#step-5-generate-the-loop-script","level":3,"title":"Step 5: Generate the Loop Script","text":"<p>Use <code>ctx loop</code> to generate a <code>loop.sh</code> tailored to your AI tool:</p> <pre><code># Generate for Claude Code with a 10-iteration cap\nctx loop --tool claude --max-iterations 10\n\n# Generate for Aider\nctx loop --tool aider --max-iterations 10\n\n# Custom prompt file and output filename (default prompt is PROMPT.md in project root)\nctx loop --tool claude --prompt my-prompt.md --output my-loop.sh\n</code></pre> <p>The generated script reads <code>PROMPT.md</code>, runs the tool, checks for completion signals, and loops until done or the cap is reached.</p> <p>You can also use the <code>/ctx-loop</code> skill from inside Claude Code.</p> <p>A shell loop is best practice</p> <p>The shell loop approach spawns a fresh AI process each iteration, so the only state that carries between iterations is what lives in <code>.context/</code> and git.</p> <p>Claude Code's built-in <code>/loop</code> runs iterations within the same session, which can allow context window state to leak between iterations. This can be convenient for short runs, but it is less reliable for unattended loops. </p> <p>See Shell Loop vs Built-in Loop for details.</p>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#step-6-run-with-watch-mode","level":3,"title":"Step 6: Run with Watch Mode","text":"<p>Open two terminals. In the first, run the loop. In the second, run <code>ctx watch</code> to process context updates from the AI output.</p> <pre><code># Terminal 1: Run the loop\n./loop.sh 2&gt;&amp;1 | tee /tmp/loop.log\n\n# Terminal 2: Watch for context updates\nctx watch --log /tmp/loop.log\n</code></pre> <p>The watch command parses XML context-update commands from the AI output and applies them:</p> <pre><code>&lt;context-update type=\"complete\"&gt;user registration&lt;/context-update&gt;\n&lt;context-update type=\"learning\"\n  context=\"Setting up user registration\"\n  lesson=\"Email verification needs SMTP configured\"\n  application=\"Add SMTP setup to deployment checklist\"\n&gt;SMTP Requirement&lt;/context-update&gt;\n</code></pre>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#step-7-completion-signals-end-the-loop","level":3,"title":"Step 7: Completion Signals End the Loop","text":"<p>The generated script checks for one completion signal per run. By default this is <code>SYSTEM_CONVERGED</code>. You can change it with the <code>--completion</code> flag:</p> <pre><code>ctx loop --tool claude --completion BOOTSTRAP_COMPLETE --max-iterations 5\n</code></pre> <p>The following signals are conventions used in <code>PROMPT.md</code>:</p> Signal Convention How the script handles it <code>SYSTEM_CONVERGED</code> All tasks in TASKS.md are done Detected by default (<code>--completion</code> default value) <code>SYSTEM_BLOCKED</code> Agent cannot proceed Only detected if you set <code>--completion</code> to this <code>BOOTSTRAP_COMPLETE</code> Initial scaffolding done Only detected if you set <code>--completion</code> to this <p>The script uses <code>grep -q</code> on the agent's output, so any string works as a signal. If you need to detect multiple signals in one run, edit the generated <code>loop.sh</code> to add additional <code>grep</code> checks.</p> <p>When you return in the morning, check the log and the context files:</p> <pre><code>tail -100 /tmp/loop.log\nctx status\nctx load\n</code></pre>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#step-8-use-ctx-implement-for-plan-execution","level":3,"title":"Step 8: Use <code>/ctx-implement</code> for Plan Execution","text":"<p>Within each iteration, the agent can use <code>/ctx-implement</code> to execute multi-step plans with verification between steps. This is useful for complex tasks that touch multiple files.</p> <p>The skill breaks a plan into atomic, verifiable steps:</p> <pre><code>Step 1/6: Create user model .................. OK\nStep 2/6: Add database migration ............. OK\nStep 3/6: Implement registration handler ..... OK\nStep 4/6: Write unit tests ................... OK\nStep 5/6: Run test suite ..................... FAIL\n  -&gt; Fixed: missing test dependency\n  -&gt; Re-verify ................................ OK\nStep 6/6: Update TASKS.md .................... OK\n</code></pre> <p>Each step is verified (build, test, syntax check) before moving to the next.</p>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#putting-it-all-together","level":2,"title":"Putting It All Together","text":"<p>A typical overnight run:</p> <pre><code>ctx init --ralph\n# Edit TASKS.md and PROMPT.md\n\nctx loop --tool claude --max-iterations 20\n\n./loop.sh 2&gt;&amp;1 | tee /tmp/loop.log &amp;\nctx watch --log /tmp/loop.log\n\n# Next morning:\nctx status\nctx load\n</code></pre>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#why-autonomous-loops-work-proactive-context-persistence","level":2,"title":"Why Autonomous Loops Work: Proactive Context Persistence","text":"<p>The autonomous loop pattern works because the agent persists context as part of the job.</p> <p>Without proactive persistence, the loop degrades into disconnected iterations that repeat work, contradict decisions, and lose track of progress. The agent cannot rely on a human to prompt it. It must treat context updates as part of every task, not as a separate step.</p>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#the-agent-playbook-self-check-drives-autonomy","level":3,"title":"The Agent Playbook Self-Check Drives Autonomy","text":"<p>The Agent Playbook defines a self-check prompt the agent applies continuously:</p> <p>\"If this session ended right now, would the next session know what happened?\"</p> <p>In interactive sessions, a human might remind the agent to save context. When the agent runs unattended, nobody is there to remind it.</p> <p>The self-check becomes the trigger: after meaningful work, the agent evaluates whether the context files reflect reality and updates them immediately if they do not.</p>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#what-the-agent-does-proactively-between-iterations","level":3,"title":"What the Agent Does Proactively Between Iterations","text":"<p>At milestones within an iteration, the agent persists without waiting for instructions:</p> Milestone What the agent does proactively Completes a task Marks it <code>[x]</code> in TASKS.md with <code>#done</code> timestamp Discovers a gotcha Adds it to LEARNINGS.md Makes a design choice Records it in DECISIONS.md with rationale Identifies follow-up work Creates new tasks in TASKS.md with <code>#added</code> timestamp Hits an unexpected failure Documents the root cause before moving on","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#example-what-proactive-persistence-looks-like","level":3,"title":"Example: What Proactive Persistence Looks Like","text":"<p>Here is what the agent does during a single iteration beyond writing code:</p> <pre><code>Iteration 4:\n  1. Read TASKS.md -&gt; pick \"Add email verification\" (#priority:high)\n  2. Add #started:2026-01-25-030012 to the task\n  3. Implement the feature (code, tests, docs if needed)\n  4. Tests pass -&gt; mark task [x], add #done:2026-01-25-031544\n  5. Add learning: \"SMTP config must be set before verification handler registers. Order matters in init().\"\n  6. Add decision: \"Use token-based verification links (not codes) because links work better in automated tests.\"\n  7. Create follow-up task: \"Add rate limiting to verification endpoint\" #added:...\n  8. Commit all changes including `.context/`\n  9. No signal emitted -&gt; loop continues to iteration 5\n</code></pre> <p>Steps 2, 4, 5, 6, and 7 are proactive context persistence. The agent was not asked to do any of them.</p>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#context-persistence-at-milestones","level":3,"title":"Context Persistence at Milestones","text":"<p>For long autonomous runs, the agent persists context at natural boundaries, often at phase transitions or after completing a cluster of related tasks. It updates TASKS.md, DECISIONS.md, and LEARNINGS.md as it goes.</p> <p>If the loop crashes at 4 AM, the context files tell you exactly where to resume. You can also use <code>ctx recall list</code> to review the session transcripts.</p>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#the-persistence-contract","level":3,"title":"The Persistence Contract","text":"<p>The autonomous loop has an implicit contract:</p> <ol> <li>Every iteration reads context: <code>TASKS.md</code>, <code>DECISIONS.md</code>, <code>LEARNINGS.md</code></li> <li>Every iteration writes context: task updates, new learnings, decisions</li> <li>Every commit includes <code>.context/</code> so the next iteration sees changes</li> <li>Context stays current: if the loop stopped right now, nothing important is lost</li> </ol> <p>Break any part of this contract and the loop degrades.</p>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#tips","level":2,"title":"Tips","text":"<p>Markdown is not enforcement</p> <p>Your real guardrails are permissions and isolation, not markdown. <code>CONSTITUTION.md</code> can nudge the agent, but it is probabilistic. The permission allowlist and OS isolation are deterministic. For unattended runs, trust the sandbox and the allowlist, not the prose.</p> <ul> <li>Start with a small iteration cap. Use <code>--max-iterations 5</code> on your first run.</li> <li>Keep tasks atomic. Each task should be completable in a single iteration.</li> <li>Check signal discipline. If the loop runs forever, the agent is not emitting   <code>SYSTEM_CONVERGED</code> or <code>SYSTEM_BLOCKED</code>. Make the signal requirement explicit   in <code>PROMPT.md</code>.</li> <li>Commit after context updates. Finish code, update <code>.context/</code>, commit including   <code>.context/</code>, then signal.</li> <li>Use <code>/ctx-context-monitor</code> for long runs. It can warn when context capacity is   running low so the agent saves before hitting limits.</li> </ul>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#next-up","level":2,"title":"Next Up","text":"<p>Turning Activity into Content: Generate blog posts and changelogs from your project activity.</p>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/autonomous-loops/#see-also","level":2,"title":"See Also","text":"<ul> <li>Autonomous Loops: loop pattern, PROMPT.md templates, troubleshooting</li> <li>CLI Reference: ctx loop: flags and options</li> <li>CLI Reference: ctx watch: watch mode details</li> <li>CLI Reference: ctx init: init flags including <code>--ralph</code></li> <li>The Complete Session: interactive workflow</li> <li>Tracking Work Across Sessions: structuring TASKS.md</li> </ul>","path":["Recipes","Running an Unattended AI Agent"],"tags":[]},{"location":"recipes/claude-code-permissions/","level":1,"title":"Claude Code Permission Hygiene","text":"","path":["Recipes","Claude Code Permission Hygiene"],"tags":[]},{"location":"recipes/claude-code-permissions/#the-problem","level":2,"title":"The Problem","text":"<p>Claude Code's <code>.claude/settings.local.json</code> controls what the agent can do without asking. Over time, this file accumulates one-off permissions from individual sessions: Exact commands with hardcoded paths, duplicate entries, and stale skill references. A noisy \"allowlist\" makes it harder to spot dangerous permissions and increases the surface area for unintended behavior.</p> <p>Since <code>settings.local.json</code> is <code>.gitignore</code>d, it drifts independently of your codebase. There is no PR review, no CI check: just whatever you clicked \"Allow\" on.</p> <p>This recipe shows what a well-maintained permission file looks like and how to keep it clean.</p>","path":["Recipes","Claude Code Permission Hygiene"],"tags":[]},{"location":"recipes/claude-code-permissions/#commands-and-skills-used","level":2,"title":"Commands and Skills Used","text":"Command/Skill Role in this workflow <code>ctx init</code> Populates default ctx permissions <code>/ctx-drift</code> Detects missing or stale permission entries <code>/sanitize-permissions</code> Audits for dangerous patterns (security-focused)","path":["Recipes","Claude Code Permission Hygiene"],"tags":[]},{"location":"recipes/claude-code-permissions/#recommended-defaults","level":2,"title":"Recommended Defaults","text":"<p>After running <code>ctx init</code>, your <code>settings.local.json</code> will have the ctx defaults pre-populated. Here is an opinionated safe starting point for a Go project using ctx:</p> <pre><code>{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(/tmp/ctx-*:*)\",\n      \"Bash(CGO_ENABLED=0 go build:*)\",\n      \"Bash(CGO_ENABLED=0 go test:*)\",\n      \"Bash(ctx:*)\",\n      \"Bash(git add:*)\",\n      \"Bash(git branch:*)\",\n      \"Bash(git check-ignore:*)\",\n      \"Bash(git checkout:*)\",\n      \"Bash(git commit:*)\",\n      \"Bash(git diff:*)\",\n      \"Bash(git log:*)\",\n      \"Bash(git remote:*)\",\n      \"Bash(git restore:*)\",\n      \"Bash(git show:*)\",\n      \"Bash(git stash:*)\",\n      \"Bash(git status:*)\",\n      \"Bash(git tag:*)\",\n      \"Bash(go build:*)\",\n      \"Bash(go fmt:*)\",\n      \"Bash(go test:*)\",\n      \"Bash(go vet:*)\",\n      \"Bash(golangci-lint run:*)\",\n      \"Bash(grep:*)\",\n      \"Bash(ls:*)\",\n      \"Bash(make:*)\",\n      \"Skill(ctx-add-convention)\",\n      \"Skill(ctx-add-decision)\",\n      \"Skill(ctx-add-learning)\",\n      \"Skill(ctx-add-task)\",\n      \"Skill(ctx-agent)\",\n      \"Skill(ctx-alignment-audit)\",\n      \"Skill(ctx-archive)\",\n      \"Skill(ctx-blog)\",\n      \"Skill(ctx-blog-changelog)\",\n      \"Skill(ctx-borrow)\",\n      \"Skill(ctx-commit)\",\n      \"Skill(ctx-context-monitor)\",\n      \"Skill(ctx-drift)\",\n      \"Skill(ctx-implement)\",\n      \"Skill(ctx-journal-enrich)\",\n      \"Skill(ctx-journal-enrich-all)\",\n      \"Skill(ctx-journal-normalize)\",\n      \"Skill(ctx-loop)\",\n      \"Skill(ctx-next)\",\n      \"Skill(ctx-pad)\",\n      \"Skill(ctx-prompt-audit)\",\n      \"Skill(ctx-recall)\",\n      \"Skill(ctx-reflect)\",\n      \"Skill(ctx-remember)\",\n      \"Skill(ctx-status)\",\n      \"Skill(ctx-worktree)\",\n      \"WebSearch\"\n    ]\n  }\n}\n</code></pre> <p>This is a starting point, not a mandate</p> <p>Your project may need more or fewer entries. </p> <p>The goal is intentional permissions: Every entry should be there because you decided it belongs, not because you clicked \"Allow\" once during debugging.</p>","path":["Recipes","Claude Code Permission Hygiene"],"tags":[]},{"location":"recipes/claude-code-permissions/#design-principles","level":3,"title":"Design Principles","text":"<p>Use wildcards for trusted binaries. If you trust the binary (your own project's CLI, <code>make</code>, <code>go</code>), a single wildcard like <code>Bash(ctx:*)</code> beats twenty subcommand entries. It reduces noise and means new subcommands work without re-prompting.</p> <p>Keep git commands granular. Unlike <code>ctx</code> or <code>make</code>, git has both safe commands (<code>git log</code>, <code>git status</code>) and destructive ones (<code>git reset --hard</code>, <code>git clean -f</code>). Listing safe commands individually prevents accidentally pre-approving dangerous ones.</p> <p>Pre-approve all ctx skills. Skills shipped with ctx (<code>Skill(ctx-*)</code>) are safe to pre-approve — they are part of your project and you control their content. This prevents the agent from prompting on every skill invocation.</p> <p>Never pre-approve these:</p> Pattern Risk <code>Bash(git push:*)</code> Bypasses <code>block-git-push</code> hook confirmation <code>Bash(git reset:*)</code> Can discard uncommitted work <code>Bash(git clean:*)</code> Deletes untracked files <code>Bash(rm -rf:*)</code> Recursive delete with no confirmation <code>Bash(sudo:*)</code> Privilege escalation (also blocked by hook) <code>Bash(curl:*)</code> / <code>Bash(wget:*)</code> Arbitrary network requests <code>Skill(sanitize-permissions)</code> Edits this file — self-modification vector <code>Skill(release)</code> Runs release pipeline — high impact","path":["Recipes","Claude Code Permission Hygiene"],"tags":[]},{"location":"recipes/claude-code-permissions/#hooks-your-safety-net","level":2,"title":"Hooks: Your Safety Net","text":"<p>Permissions and hooks work together. Even if a command is pre-approved, hooks still run. The difference is that pre-approved commands skip the user confirmation dialog: So if a hook blocks the command, the user never sees it.</p> <p>The ctx plugin ships these blocking hooks:</p> Hook What it blocks <code>ctx system block-non-path-ctx</code> Running ctx from wrong path <p>Project-local hooks (not part of the plugin) can add more:</p> Hook What it blocks <code>block-git-push.sh</code> All <code>git push</code> commands <code>block-dangerous-commands.sh</code> <code>sudo</code>, copies to <code>~/.local/bin</code> <p>Pre-approved + hook-blocked = silent block</p> <p>If you pre-approve <code>Bash(git push:*)</code>, the hook still blocks it, but the user never sees the confirmation dialog. The agent gets a block response and must handle it, which is confusing.</p> <p>It's better not to pre-approve commands that hooks are designed to intercept.</p>","path":["Recipes","Claude Code Permission Hygiene"],"tags":[]},{"location":"recipes/claude-code-permissions/#the-maintenance-workflow","level":2,"title":"The Maintenance Workflow","text":"","path":["Recipes","Claude Code Permission Hygiene"],"tags":[]},{"location":"recipes/claude-code-permissions/#after-busy-sessions","level":3,"title":"After busy sessions","text":"<p>Permissions accumulate fastest during debugging and exploration sessions. After a session where you clicked \"Allow\" many times:</p> <ol> <li>Open <code>.claude/settings.local.json</code> in your editor</li> <li>Look for entries at the bottom of the allowlist (new entries append there)</li> <li>Delete anything that looks session-specific:</li> <li>Exact commands with hardcoded paths</li> <li>Commands with literal string arguments</li> <li>Entries that duplicate an existing wildcard</li> </ol> <p>See <code>hack/runbooks/sanitize-permissions.md</code> for a step-by-step runbook.</p>","path":["Recipes","Claude Code Permission Hygiene"],"tags":[]},{"location":"recipes/claude-code-permissions/#periodically","level":3,"title":"Periodically","text":"<p>Run <code>/ctx-drift</code> to catch permission drift:</p> <ul> <li>Missing <code>Bash(ctx:*)</code> wildcard</li> <li>Missing <code>Skill(ctx-*)</code> entries for installed skills</li> <li>Stale <code>Skill(ctx-*)</code> entries for removed skills</li> <li>Granular <code>Bash(ctx &lt;subcommand&gt;:*)</code> entries that should be consolidated</li> </ul> <p>Run <code>/sanitize-permissions</code> to catch security issues:</p> <ul> <li>Hook bypass patterns</li> <li>Destructive commands</li> <li>Overly broad permissions</li> <li>Injection vectors</li> </ul>","path":["Recipes","Claude Code Permission Hygiene"],"tags":[]},{"location":"recipes/claude-code-permissions/#when-adding-new-skills","level":3,"title":"When adding new skills","text":"<p>If you create a custom <code>ctx-*</code> skill, add its <code>Skill()</code> entry to the allowlist manually. </p> <p><code>ctx init</code> only populates the default permissions: It won't pick up custom skills.</p>","path":["Recipes","Claude Code Permission Hygiene"],"tags":[]},{"location":"recipes/claude-code-permissions/#golden-image-snapshots","level":3,"title":"Golden image snapshots","text":"<p>If manual cleanup is too tedious, use a golden image to automate it. Snapshot a curated permission set, then restore at session start to automatically drop session-accumulated permissions. See the Permission Snapshots recipe for the full workflow.</p>","path":["Recipes","Claude Code Permission Hygiene"],"tags":[]},{"location":"recipes/claude-code-permissions/#adapting-for-other-languages","level":2,"title":"Adapting for Other Languages","text":"<p>The recommended defaults above are Go-specific. For other stacks, swap the build/test tooling:</p> <p>Node.js / TypeScript: <pre><code>\"Bash(npm run:*)\",\n\"Bash(npm test:*)\",\n\"Bash(npx:*)\",\n\"Bash(node:*)\"\n</code></pre></p> <p>Python: <pre><code>\"Bash(pytest:*)\",\n\"Bash(python:*)\",\n\"Bash(pip show:*)\",\n\"Bash(ruff:*)\"\n</code></pre></p> <p>Rust: <pre><code>\"Bash(cargo build:*)\",\n\"Bash(cargo test:*)\",\n\"Bash(cargo clippy:*)\",\n\"Bash(cargo fmt:*)\"\n</code></pre></p> <p>The <code>ctx</code>, <code>git</code>, and skill entries remain the same across all stacks.</p>","path":["Recipes","Claude Code Permission Hygiene"],"tags":[]},{"location":"recipes/claude-code-permissions/#next-up","level":2,"title":"Next Up","text":"<p>Permission Snapshots →: Save and restore permission baselines for reproducible setups.</p>","path":["Recipes","Claude Code Permission Hygiene"],"tags":[]},{"location":"recipes/claude-code-permissions/#see-also","level":2,"title":"See Also","text":"<ul> <li>Setting Up ctx Across AI Tools: full setup recipe   including <code>settings.local.json</code> creation</li> <li>Context Health: keeping <code>.context/</code> files accurate</li> <li><code>hack/runbooks/sanitize-permissions.md</code>:   manual cleanup runbook</li> </ul>","path":["Recipes","Claude Code Permission Hygiene"],"tags":[]},{"location":"recipes/context-health/","level":1,"title":"Detecting and Fixing Drift","text":"","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#the-problem","level":2,"title":"The Problem","text":"<p>Context files drift: you rename a package, delete a module, or finish a sprint, and suddenly <code>ARCHITECTURE.md</code> references paths that no longer exist, <code>TASKS.md</code> is 80 percent completed checkboxes, and <code>CONVENTIONS.md</code> describes patterns you stopped using two months ago.</p> <p>Stale context is worse than no context: </p> <p>An AI tool that trusts outdated references will hallucinate confidently.</p> <p>This recipe shows how to detect drift, fix it, and keep your <code>.context/</code> directory lean and accurate.</p> <p>TL;DR</p> <pre><code>ctx drift                      # detect problems\nctx drift --fix                # auto-fix the easy ones\nctx sync --dry-run &amp;&amp; ctx sync # reconcile after refactors\nctx compact --archive          # archive old completed tasks\nctx status                     # verify\n</code></pre> <p>Or just ask your agent: \"Is our context clean?\"</p>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#commands-and-skills-used","level":2,"title":"Commands and Skills Used","text":"Tool Type Purpose <code>ctx drift</code> Command Detect stale paths, missing files, violations <code>ctx drift --fix</code> Command Auto-fix simple issues <code>ctx sync</code> Command Reconcile context with codebase structure <code>ctx compact</code> Command Archive completed tasks, deduplicate learnings <code>ctx status</code> Command Quick health overview <code>/ctx-drift</code> Skill Structural plus semantic drift detection <code>/ctx-alignment-audit</code> Skill Audit doc claims against agent instructions <code>/ctx-status</code> Skill In-session context summary <code>/ctx-prompt-audit</code> Skill Audit prompt quality and token efficiency","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#the-workflow","level":2,"title":"The Workflow","text":"<p>The best way to maintain context health is conversational: ask your agent, guide it, and let it detect problems, explain them, and fix them with your approval. CLI commands exist for CI pipelines, scripting, and fine-grained control. </p> <p>For day-to-day maintenance, talk to your agent.</p> <p>Your Questions Reinforce the Pattern</p> <p>Asking \"is our context clean?\" does two things:</p> <ul> <li>it triggers a drift check right now</li> <li>it reinforces the habit</li> </ul> <p>This is reinforcement, not enforcement.</p> <p>Do not wait for the agent to be proactive on its own. Guide it, especially in early sessions. Over time, you will ask less and the agent will start offering more.</p>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#step-1-ask-your-agent","level":3,"title":"Step 1: Ask Your Agent","text":"<p>The simplest way to check context health:</p> <pre><code>Is our context clean?\nAnything stale?\nHow healthy are our context files?\n</code></pre> <p>Or invoke the skill directly:</p> <pre><code>/ctx-drift\n</code></pre> <p>The agent performs two layers of analysis:</p> <p>Layer 1, structural checks (via <code>ctx drift</code>): Dead paths, missing files, completed task counts, constitution violations. Fast and programmatic.</p> <p>Layer 2, semantic analysis (agent-driven): Does <code>CONVENTIONS.md</code> describe patterns the code no longer follows? Does <code>DECISIONS.md</code> contain entries whose rationale no longer applies? Are there learnings about bugs that are now fixed? This is where the agent adds value the CLI cannot: It reads both context files and source code and compares them.</p> <p>The agent reports both layers together, explains each finding in plain language, and offers to fix what it can.</p>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#step-2-maintenance-at-session-start","level":3,"title":"Step 2: Maintenance at Session Start","text":"<p>You do not need to ask explicitly. A proactive agent can check context health as part of its startup routine and mention anything worth addressing:</p> <pre><code>Agent: Good morning. I've loaded the context files. A few things\n       before we start:\n\n       - ARCHITECTURE.md references `pkg/auth/` which is now empty\n       - DECISIONS.md hasn't been updated in 40 days\n       - There are 18 completed tasks ready for archival\n\n       Want me to run a quick maintenance pass, or should we jump\n       straight into today's work?\n</code></pre> <p>If the agent does not offer this on its own, a gentle nudge is enough:</p> <pre><code>Anything stale before we start?\nHow's the context looking?\n</code></pre> <p>This turns maintenance from a scheduled chore into a conversation that happens when it matters.</p>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#step-3-real-time-detection-during-work","level":3,"title":"Step 3: Real-Time Detection During Work","text":"<p>Agents can notice drift while working — when a mismatch is directly in the path of their current task. If an agent reads <code>ARCHITECTURE.md</code> to find where to add a handler and <code>internal/handlers/</code> doesn't exist, it will notice because the stale reference blocks its work:</p> <pre><code>Agent: ARCHITECTURE.md references `internal/handlers/` but that directory\n       doesn't exist. I'll look at the actual source tree to find where\n       handlers live now.\n</code></pre> <p>This happens reliably when the drift intersects the task. What is less reliable is the agent generalizing from one mismatch to \"there might be more stale references; let me run drift detection\" That leap requires the agent to know <code>/ctx-drift</code> exists and to decide the current task should pause for maintenance.</p> <p>If you want that behavior, reinforce it:</p> <pre><code>Good catch. Yes, run /ctx-drift and clean up any other stale references.\n</code></pre> <p>Over time, agents that have seen this pattern will start offering proactively. But do not expect it from a cold start.</p>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#step-4-archival-and-cleanup","level":3,"title":"Step 4: Archival and Cleanup","text":"<p><code>ctx drift</code> detects when <code>TASKS.md</code> has more than 10 completed items and flags it as a staleness warning. Running <code>ctx drift --fix</code> archives completed tasks automatically. </p> <p>You can also run <code>/ctx-archive</code> to compact on demand.</p>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#step-5-alignment-audits","level":3,"title":"Step 5: Alignment Audits","text":"<p>A related problem is alignment drift: Documentation that makes claims about agent behavior not backed by actual playbook or skill instructions. </p> <p>Over time, docs accumulate aspirational statements that no instruction teaches  the agent to do.</p> <p>Use <code>/ctx-alignment-audit</code> to trace behavioral claims in documentation against the playbook and skill files. The skill identifies gaps, proposes fixes, and checks instruction file health (token budgets, bloat signals).</p> <p>To avoid confusion with <code>/ctx-prompt-audit</code>:</p> <ul> <li><code>/ctx-alignment-audit</code> checks whether documentation claims are supported by   actual instructions (playbook, skills, <code>CLAUDE.md</code>).</li> <li><code>/ctx-prompt-audit</code> checks whether your context files are clear, compact, and   token-efficient for the model.</li> </ul>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#cli-reference","level":2,"title":"CLI Reference","text":"<p>The conversational approach above uses CLI commands under the hood. When you need direct control, use the commands directly.</p>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#ctx-drift","level":3,"title":"<code>ctx drift</code>","text":"<p>Scan context files for structural problems:</p> <pre><code>ctx drift\n</code></pre> <p>Sample output:</p> <pre><code>Drift Report\n============\n\nWarnings (3):\n  ARCHITECTURE.md:14  path \"internal/api/router.go\" does not exist\n  ARCHITECTURE.md:28  path \"pkg/auth/\" directory is empty\n  CONVENTIONS.md:9    path \"internal/handlers/\" not found\n\nViolations (1):\n  TASKS.md            31 completed tasks (recommend archival)\n\nStaleness:\n  DECISIONS.md        last modified 45 days ago\n  LEARNINGS.md        last modified 32 days ago\n\nExit code: 1 (warnings found)\n</code></pre> Level Meaning Action Warning Stale path references, missing files Fix or remove Violation Constitution rule heuristic failures, heavy clutter Fix soon Staleness Files not updated recently Review content <p>Exit codes: <code>0</code> equals clean, <code>1</code> equals warnings, <code>3</code> equals violations.</p> <p>For CI integration:</p> <pre><code>ctx drift --json | jq '.warnings | length'\n</code></pre>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#ctx-drift-fix","level":3,"title":"<code>ctx drift --fix</code>","text":"<p>Auto-fix mechanical issues:</p> <pre><code>ctx drift --fix\n</code></pre> <p>This handles removing dead path references, updating unambiguous renames,  clearing empty sections. Issues requiring judgment are flagged but left for you.</p> <p>Run <code>ctx drift</code> again afterward to confirm what remains.</p>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#ctx-sync","level":3,"title":"<code>ctx sync</code>","text":"<p>After a refactor, reconcile context with the actual codebase structure:</p> <pre><code>ctx sync --dry-run   # preview first\nctx sync             # apply\n</code></pre> <p><code>ctx sync</code> scans for structural changes, compares with <code>ARCHITECTURE.md</code>,  checks for new dependencies worth documenting, and identifies context referring  to code that no longer exists.</p>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#ctx-compact","level":3,"title":"<code>ctx compact</code>","text":"<p>Consolidate completed tasks and clean up empty sections:</p> <pre><code>ctx compact              # move completed tasks to Completed section, remove empty sections\nctx compact --archive    # also copy tasks older than 7 days to .context/archive/\n</code></pre> <ul> <li>Tasks: moves completed items (with all subtasks done) into the Completed   section of <code>TASKS.md</code></li> <li>All files: removes empty sections left behind</li> <li>With <code>--archive</code>: also writes tasks older than 7 days to   <code>.context/archive/tasks-YYYY-MM-DD.md</code></li> </ul> <p>Without <code>--archive</code>, nothing is deleted — tasks are reorganized in place.</p>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#ctx-status","level":3,"title":"<code>ctx status</code>","text":"<p>Quick health overview:</p> <pre><code>ctx status --verbose\n</code></pre> <p>Shows file counts, token estimates, modification times, and drift warnings in a single glance.</p>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#ctx-alignment-audit-and-ctx-prompt-audit","level":3,"title":"<code>/ctx-alignment-audit</code> and <code>/ctx-prompt-audit</code>","text":"<p>These are both audits, but they answer different questions:</p> <ul> <li><code>/ctx-alignment-audit</code>: are our behavioral claims backed by actual   instructions?</li> <li><code>/ctx-prompt-audit</code>: are our context files readable, compact, and efficient?</li> </ul> <p>Run them inside your AI assistant:</p> <pre><code>/ctx-alignment-audit\n/ctx-prompt-audit\n</code></pre>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#putting-it-all-together","level":2,"title":"Putting It All Together","text":"<p>Conversational approach (recommended):</p> <pre><code>Is our context clean?   -&gt; agent runs structural plus semantic checks\nFix what you can        -&gt; agent auto-fixes and proposes edits\nArchive the done tasks  -&gt; agent runs ctx compact --archive\nHow's token usage?      -&gt; agent checks ctx status\n</code></pre> <p>CLI approach (for CI, scripts, or direct control):</p> <pre><code>ctx drift                      # 1. Detect problems\nctx drift --fix                # 2. Auto-fix the easy ones\nctx sync --dry-run &amp;&amp; ctx sync # 3. Reconcile after refactors\nctx compact --archive          # 4. Archive old completed tasks\nctx status                     # 5. Verify\n</code></pre>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#tips","level":2,"title":"Tips","text":"<p>Agents cross-reference context files with source code during normal work. When drift intersects their current task, they will notice: a renamed package, a deleted directory, a path that doesn't resolve. But they rarely generalize from one mismatch to a full audit on their own. Reinforce the pattern: when an agent mentions a stale reference, ask it to run <code>/ctx-drift</code>. Over time, it starts offering.</p> <p>When an agent says \"this reference looks stale,\" it is usually right.</p> <p>Semantic drift is more damaging than structural drift. <code>ctx drift</code> catches dead paths. But <code>CONVENTIONS.md</code> describing a pattern your code stopped following three weeks ago is worse. When you ask \"is our context clean?\", the agent can  do both checks.</p> <p>Use <code>ctx status</code> as a quick check. It shows file counts, token estimates, and drift warnings in a single glance. Good for a fast \"is everything ok?\" before diving into work.</p> <p>Drift detection in CI: add <code>ctx drift --json</code> to your CI pipeline and fail on exit code 3 (violations). This catches constitution-level problems before they reach upstream.</p> <p>Do not over-compact. Completed tasks have historical value. The <code>--archive</code> flag preserves them in <code>.context/archive/</code> so you can search past work without cluttering active context.</p> <p>Sync is cautious by default. Use <code>--dry-run</code> after large refactors, then apply.</p>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#next-up","level":2,"title":"Next Up","text":"<p>Browsing and Enriching Past Sessions: Export session history to a browsable journal and enrich entries with metadata.</p>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/context-health/#see-also","level":2,"title":"See Also","text":"<ul> <li>Tracking Work Across Sessions: task lifecycle and archival</li> <li>Persisting Decisions, Learnings, and Conventions:    keeping knowledge files current</li> <li>The Complete Session: where maintenance fits in the daily workflow</li> <li>CLI Reference: full flag documentation for all commands</li> <li>Context Files: structure and purpose of each <code>.context/</code> file</li> </ul>","path":["Recipes","Detecting and Fixing Drift"],"tags":[]},{"location":"recipes/external-context/","level":1,"title":"Keeping Context in a Separate Repo","text":"","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#the-problem","level":2,"title":"The Problem","text":"<p><code>ctx</code> files contain project-specific decisions, learnings,  conventions, and tasks. By default, they live in  <code>.context/</code> inside the project tree, and that works well when the context can be public.</p> <p>But sometimes you need the context outside the project:</p> <ul> <li>Open-source projects with private context: Your architectural notes,   internal task lists, and scratchpad entries shouldn't ship with the public   repo.</li> <li>Compliance or IP concerns: Context files reference sensitive design   rationale that belongs in a separate access-controlled repository.</li> <li>Personal preference: You want a single context repo that covers   multiple projects, or you just prefer keeping notes separate from code.</li> </ul> <p><code>ctx</code> supports this through three configuration methods. This recipe shows how to set them up and how to tell your AI assistant where to find the context.</p> <p>TL;DR</p> <p><pre><code>mkdir ~/repos/myproject-context &amp;&amp; cd ~/repos/myproject-context &amp;&amp; git init\ncd ~/repos/myproject\nctx --context-dir ~/repos/myproject-context --allow-outside-cwd init\n</code></pre> Then create <code>.contextrc</code> in the project root: <pre><code>context_dir: ~/repos/myproject-context\nallow_outside_cwd: true\n</code></pre> All <code>ctx</code> commands now use the external directory automatically.</p>","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#commands-and-skills-used","level":2,"title":"Commands and Skills Used","text":"Tool Type Purpose <code>ctx init</code> CLI command Initialize context directory <code>--context-dir</code> Global flag Point ctx at a non-default directory <code>--allow-outside-cwd</code> Global flag Permit context outside the project root <code>.contextrc</code> Config file Persist the context directory setting <code>CTX_DIR</code> Env variable Override context directory per-session <code>/ctx-status</code> Skill Verify context is loading correctly","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#the-workflow","level":2,"title":"The Workflow","text":"","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#step-1-create-the-private-context-repo","level":3,"title":"Step 1: Create the Private Context Repo","text":"<p>Create a separate repository for your context files. This can live anywhere: a private GitHub repo, a shared drive, a sibling directory:</p> <pre><code># Create the context repo\nmkdir ~/repos/myproject-context\ncd ~/repos/myproject-context\ngit init\n</code></pre>","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#step-2-initialize-ctx-pointing-at-it","level":3,"title":"Step 2: Initialize ctx Pointing at It","text":"<p>From your project root, initialize ctx with <code>--context-dir</code> pointing to the external location. Because the directory is outside your project tree, you also need <code>--allow-outside-cwd</code>:</p> <pre><code>cd ~/repos/myproject\nctx --context-dir ~/repos/myproject-context \\\n    --allow-outside-cwd \\\n    init\n</code></pre> <p>This creates the full <code>.context/</code>-style file set inside <code>~/repos/myproject-context/</code> instead of <code>~/repos/myproject/.context/</code>.</p> <p>Boundary Validation</p> <p><code>ctx</code> validates that the <code>.context</code> directory is within the current working directory. </p> <p>If your external directory is truly outside the project root:</p> <ul> <li>Either every <code>ctx</code> command needs <code>--allow-outside-cwd</code>, </li> <li>or you can persist the setting in <code>.contextrc</code> (next step).</li> </ul>","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#step-3-make-it-stick","level":3,"title":"Step 3: Make It Stick","text":"<p>Typing <code>--context-dir</code> and <code>--allow-outside-cwd</code> on every command is tedious. Pick one of these methods to make the configuration permanent.</p>","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#option-a-contextrc-recommended","level":4,"title":"Option A: <code>.contextrc</code> (Recommended)","text":"<p>Create a <code>.contextrc</code> file in your project root:</p> <pre><code># .contextrc — committed to the project repo\ncontext_dir: ~/repos/myproject-context\nallow_outside_cwd: true\n</code></pre> <p>ctx reads <code>.contextrc</code> automatically. Every command now uses the external directory without extra flags:</p> <pre><code>ctx status          # reads from ~/repos/myproject-context\nctx add learning \"Redis MULTI doesn't roll back on error\"\n</code></pre> <p>Commit <code>.contextrc</code></p> <p><code>.contextrc</code> belongs in the project repo. It contains no secrets — just a path and a boundary override. It lets teammates share the same configuration.</p>","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#option-b-ctx_dir-environment-variable","level":4,"title":"Option B: <code>CTX_DIR</code> Environment Variable","text":"<p>Good for CI pipelines, temporary overrides, or when you don't want to commit a <code>.contextrc</code>:</p> <pre><code># In your shell profile (~/.bashrc, ~/.zshrc)\nexport CTX_DIR=~/repos/myproject-context\n</code></pre> <p>Or for a single session:</p> <pre><code>CTX_DIR=~/repos/myproject-context ctx status\n</code></pre>","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#option-c-shell-alias","level":4,"title":"Option C: Shell Alias","text":"<p>If you prefer a shell alias over <code>.contextrc</code>:</p> <pre><code># ~/.bashrc or ~/.zshrc\nalias ctx='ctx --context-dir ~/repos/myproject-context --allow-outside-cwd'\n</code></pre>","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#priority-order","level":4,"title":"Priority Order","text":"<p>When multiple methods are set, <code>ctx</code> resolves the context directory in this order (highest priority first):</p> <ol> <li><code>--context-dir</code> flag</li> <li><code>CTX_DIR</code> environment variable</li> <li><code>context_dir</code> in <code>.contextrc</code></li> <li>Default: <code>.context/</code></li> </ol>","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#step-4-configure-claudemd-to-reference-the-external-context","level":3,"title":"Step 4: Configure <code>CLAUDE.md</code> to Reference the External Context","text":"<p>When context lives outside the project tree, your AI assistant needs to know where to find it. Claude Code reads <code>CLAUDE.md</code> from the project root, so add a pointer there:</p> <pre><code># CLAUDE.md\n\n## Context Location\n\nThis project's context files live in a separate repository:\n**~/repos/myproject-context/**\n\nWhen using ctx commands, the `.contextrc` in this project root handles\nthe path automatically. To load context manually:\n\n```bash\nctx agent --budget 4000 --context-dir ~/repos/myproject-context --allow-outside-cwd\n</code></pre> <p>Read the context files from that directory: - <code>~/repos/myproject-context/TASKS.md</code>: current work items - <code>~/repos/myproject-context/DECISIONS.md</code>: architectural decisions - <code>~/repos/myproject-context/CONVENTIONS.md</code>: code patterns - <code>~/repos/myproject-context/CONSTITUTION.md</code>: hard rules <pre><code>The ctx plugin's PreToolUse hook runs `ctx agent` automatically. To make it\nuse the external path, create a `.contextrc` in the project root (Step 3\nabove) — the hook inherits the same configuration. No manual hook\nediting is needed.\n\nIf you use `CTX_DIR` instead of `.contextrc`, export it in your shell\nprofile so the hook process inherits it:\n\n```bash\nexport CTX_DIR=~/repos/myproject-context\n</code></pre></p>","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#step-5-share-with-teammates","level":3,"title":"Step 5: Share with Teammates","text":"<p>Teammates clone both repos and set up <code>.contextrc</code>:</p> <pre><code># Clone the project\ngit clone git@github.com:org/myproject.git\ncd myproject\n\n# Clone the private context repo\ngit clone git@github.com:org/myproject-context.git ~/repos/myproject-context\n</code></pre> <p>If <code>.contextrc</code> is already committed to the project, they're done — ctx commands will find the external context automatically.</p> <p>If teammates use different paths, each developer sets their own <code>CTX_DIR</code>:</p> <pre><code>export CTX_DIR=~/my-own-path/myproject-context\n</code></pre> <p>For scratchpad key distribution across the team, see the Syncing Scratchpad Notes recipe.</p>","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#step-6-day-to-day-sync","level":3,"title":"Step 6: Day-to-Day Sync","text":"<p>The external context repo has its own git history. Treat it like any other repo — commit and push after sessions:</p> <pre><code>cd ~/repos/myproject-context\n\n# After a session\ngit add -A\ngit commit -m \"Session: refactored auth module, added rate-limit learning\"\ngit push\n</code></pre> <p>Your AI assistant can do this too. When ending a session:</p> <pre><code>You: \"Save what we learned and push the context repo.\"\n\nAgent: [runs ctx add learning, then commits and pushes the context repo]\n</code></pre> <p>You can also set up a post-session habit: project code gets committed to the project repo, context gets committed to the context repo.</p>","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#conversational-approach","level":2,"title":"Conversational Approach","text":"<p>You don't need to remember the flags. Ask your assistant:</p> <pre><code>You: \"Set up ctx to use ~/repos/myproject-context as the context directory.\"\n\nAgent: \"I'll create a .contextrc in the project root pointing to that path.\n       I'll also update CLAUDE.md so future sessions know where to find\n       context. Want me to initialize the context files there too?\"\n</code></pre> <pre><code>You: \"My context is in a separate repo. Can you load it?\"\n\nAgent: [reads .contextrc, finds the path, loads context from the external dir]\n       \"Loaded. You have 3 pending tasks, last session was about the auth\n       refactor.\"\n</code></pre>","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#tips","level":2,"title":"Tips","text":"<ul> <li>Start simple. If you don't need external context yet, don't set it up.   The default <code>.context/</code> in-tree is the easiest path. Move to an external   repo when you have a concrete reason.</li> <li>One context repo per project. Sharing a single context directory across   multiple projects creates confusion. Keep the mapping 1:1.</li> <li>Use <code>.contextrc</code> over env vars when the path is stable. It's committed,   documented, and works for the whole team without per-developer shell setup.</li> <li>Don't forget the boundary flag. The most common error is   <code>Error: context directory is outside the project root</code>. Set   <code>allow_outside_cwd: true</code> in <code>.contextrc</code> or pass <code>--allow-outside-cwd</code>.</li> <li>Commit both repos at session boundaries. Context without code history   (or code without context history) loses half the value.</li> </ul>","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#next-up","level":2,"title":"Next Up","text":"<p>Hook Output Patterns →: Design clear, consistent output for ctx hooks.</p>","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/external-context/#see-also","level":2,"title":"See Also","text":"<ul> <li>Setting Up ctx Across AI Tools: initial setup recipe</li> <li>Syncing Scratchpad Notes Across Machines: distribute   encryption keys when context is shared</li> <li>CLI Reference: all global flags including   <code>--context-dir</code> and <code>--allow-outside-cwd</code></li> </ul>","path":["Recipes","Keeping Context in a Separate Repo"],"tags":[]},{"location":"recipes/hook-output-patterns/","level":1,"title":"Hook Output Patterns","text":"","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#the-problem","level":2,"title":"The Problem","text":"<p>Claude Code hooks can output text, JSON, or nothing at all. But the format of that output determines who sees it and who acts on it. </p> <p>Choose the wrong pattern, and your carefully crafted warning gets silently  absorbed by the agent, or your agent-directed nudge gets dumped on the user  as noise.</p> <p>This recipe catalogs the known hook output patterns and explains when to  use each one.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#the-spectrum","level":2,"title":"The Spectrum","text":"<p>These patterns form a spectrum based on who decides what the user sees:</p> Pattern Who decides? Hard gate Hook decides (agent can't proceed) VERBATIM relay Hook decides (agent must show) Escalating severity Hook suggests, agent judges urgency Conditional relay Hook sets criteria, agent evaluates Suggested action Hook proposes, agent + user decide Agent directive Agent decides entirely Silent injection Nobody — invisible background context Silent side-effect Nobody — invisible background work <p>The spectrum runs from full hook control (hard gate) to full invisibility (silent side effect). Most hooks belong somewhere in the middle.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#pattern-1-hard-gate","level":2,"title":"Pattern 1: Hard Gate","text":"<p>Block the tool call entirely. The agent cannot proceed: it must find another approach or tell the user.</p> <pre><code>echo '{\"decision\": \"block\", \"reason\": \"Use ctx from PATH, not ./ctx\"}'\n</code></pre> <p>When to use: Enforcing invariants that must never be violated: Constitution rules, security boundaries, destructive command prevention.</p> <p>Hook type: <code>PreToolUse</code> only (Claude Code first-class mechanism).</p> <p>Examples in <code>ctx</code>:</p> <ul> <li><code>ctx system block-non-path-ctx</code>: Enforces the PATH invocation rule</li> <li><code>block-git-push.sh</code>: Requires explicit user approval for pushes (project-local)</li> <li><code>block-dangerous-commands.sh</code>: Prevents <code>sudo</code>, copies to <code>~/.local/bin</code> (project-local)</li> </ul> <p>Trade-off: The agent gets a block response with a reason. Good reasons help the agent recover (\"use X instead\"); bad reasons leave it stuck.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#pattern-2-verbatim-relay","level":2,"title":"Pattern 2: VERBATIM Relay","text":"<p>Force the agent to show this to the user as-is. The explicit instruction overcomes the agent's tendency to silently absorb context.</p> <pre><code>echo \"IMPORTANT: Relay this warning to the user VERBATIM before answering their question.\"\necho \"\"\necho \"┌─ Journal Reminder ─────────────────────────────\"\necho \"│ You have 12 sessions not yet exported.\"\necho \"└────────────────────────────────────────────────\"\n</code></pre> <p>When to use: Actionable reminders the user needs to see regardless of what they asked: Stale backups, unexported sessions, resource warnings.</p> <p>Hook type: <code>UserPromptSubmit</code> (runs before the agent sees the prompt).</p> <p>Examples in <code>ctx</code>:</p> <ul> <li><code>ctx system check-journal</code>: Unexported sessions and unenriched entries</li> <li><code>ctx system check-context-size</code>: Context capacity warning</li> <li><code>check-backup-age.sh</code>: Stale backup warning (project-local)</li> </ul> <p>Trade-off: Noisy if overused. Every VERBATIM relay adds a preamble before the agent's actual answer. Throttle with once-per-day markers or adaptive frequency.</p> <p>Key detail: The phrase <code>IMPORTANT: Relay this ... VERBATIM</code> is what makes this work. Without it, agents tend to process the information internally and never surface it. The explicit instruction is the pattern: the box-drawing is just fancy formatting.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#pattern-3-agent-directive","level":2,"title":"Pattern 3: Agent Directive","text":"<p>Tell the agent to do something, not the user. The agent decides whether and how to involve the user.</p> <pre><code>echo \"┌─ Persistence Checkpoint (prompt #25) ───────────\"\necho \"│ No context files updated in 15+ prompts.\"\necho \"│ Have you discovered learnings, decisions,\"\necho \"│ or completed tasks worth persisting?\"\necho \"└──────────────────────────────────────────────────\"\n</code></pre> <p>When to use: Behavioral nudges. The hook detects a condition and asks the agent to consider an action. The user may never need to know.</p> <p>Hook type: <code>UserPromptSubmit</code>.</p> <p>Examples in <code>ctx</code>:</p> <ul> <li><code>ctx system check-persistence</code>: Nudges the agent to persist context</li> </ul> <p>Trade-off: No guarantee the agent acts. The nudge is one signal among many in the context window. Strong phrasing helps (\"Have you...?\" is better than \"Consider...\"), but ultimately the agent decides.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#pattern-4-silent-context-injection","level":2,"title":"Pattern 4: Silent Context Injection","text":"<p>Load context with no visible output. The agent gets enriched without either party noticing.</p> <pre><code>ctx agent --budget 4000 2&gt;/dev/null || true\n</code></pre> <p>When to use: Background context loading that should be invisible. The agent benefits from the information, but neither it, nor the user needs to know it happened.</p> <p>Hook type: <code>PreToolUse</code> with <code>.*</code> matcher (runs on every tool call).</p> <p>Examples in <code>ctx</code>:</p> <ul> <li>The <code>ctx agent</code> <code>PreToolUse</code> hook: injects project context silently</li> </ul> <p>Trade-off: Adds latency to every tool call. Keep the injected content small and fast to generate.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#pattern-5-silent-side-effect","level":2,"title":"Pattern 5: Silent Side-Effect","text":"<p>Do work, produce no output: Housekeeping that needs no acknowledgment.</p> <pre><code>find \"$CTX_TMPDIR\" -type f -mtime +15 -delete\n</code></pre> <p>When to use: Cleanup, log rotation, temp file management. Anything where the action is the point and nobody needs to know it happened.</p> <p>Hook type: <code>SessionEnd</code>, or any hook where output is irrelevant.</p> <p>Examples in <code>ctx</code>:</p> <ul> <li><code>ctx system cleanup-tmp</code>: Removes stale temp files on session end</li> </ul> <p>Trade-off: None, if the action is truly invisible. If it can fail in a way that matters, consider logging.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#pattern-6-conditional-relay","level":3,"title":"Pattern 6: Conditional Relay","text":"<p>Tell the agent to relay only if a condition holds in context.</p> <pre><code>echo \"If the user's question involves modifying .context/ files,\"\necho \"relay this warning VERBATIM:\"\necho \"\"\necho \"┌─ Context Integrity ─────────────────────────────\"\necho \"│ CONSTITUTION.md has not been verified in 7 days.\"\necho \"└────────────────────────────────────────────────\"\necho \"\"\necho \"Otherwise, proceed normally.\"\n</code></pre> <p>When to use: Warnings that only matter in certain contexts. Avoids noise when the user is doing unrelated work.</p> <p>Trade-off: Depends on the agent's judgment about when the condition holds. More fragile than VERBATIM relay, but less noisy.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#pattern-7-suggested-action","level":3,"title":"Pattern 7: Suggested Action","text":"<p>Give the agent a specific command to propose to the user.</p> <pre><code>echo \"┌─ Stale Dependencies ──────────────────────────\"\necho \"│ go.sum is 30+ days newer than go.mod.\"\necho \"│ Suggested: run \\`go mod tidy\\`\"\necho \"│ Ask the user before proceeding.\"\necho \"└───────────────────────────────────────────────\"\n</code></pre> <p>When to use: The hook detects a fixable condition and knows the fix. Goes beyond a nudge: Gives the agent a concrete next step. The agent still asks for permission but knows exactly what to propose.</p> <p>Trade-off: The suggestion might be wrong or outdated. The \"ask the user before proceeding\" part is critical.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#pattern-8-escalating-severity","level":3,"title":"Pattern 8: Escalating Severity","text":"<p>Different urgency tiers with different relay expectations.</p> <pre><code># INFO: agent processes silently, mentions if relevant\necho \"INFO: Last test run was 3 days ago.\"\n\n# WARN: agent should mention to user at next natural pause\necho \"WARN: 12 uncommitted changes across 3 branches.\"\n\n# CRITICAL: agent must relay immediately, before any other work\necho \"CRITICAL: Relay VERBATIM before answering. Disk usage at 95%.\"\n</code></pre> <p>When to use: When you have multiple hooks producing output and need to avoid overwhelming the user. INFO gets absorbed, WARN gets mentioned, CRITICAL interrupts.</p> <p>Trade-off: Requires agent training or convention to recognize the tiers. Without a shared protocol, the prefixes are just text.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#choosing-a-pattern","level":2,"title":"Choosing a Pattern","text":"<pre><code>Is the agent about to do something forbidden?\n  └─ Yes → Hard gate\n\nDoes the user need to see this regardless of what they asked?\n  └─ Yes → VERBATIM relay\n  └─ Sometimes → Conditional relay\n\nShould the agent consider an action?\n  └─ Yes, with a specific fix → Suggested action\n  └─ Yes, open-ended → Agent directive\n\nIs this background context the agent should have?\n  └─ Yes → Silent injection\n\nIs this housekeeping?\n  └─ Yes → Silent side-effect\n</code></pre>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#design-tips","level":2,"title":"Design Tips","text":"<p>Throttle aggressively. VERBATIM relays that fire every prompt will be ignored or resented. Use once-per-day markers (<code>touch $REMINDED</code>), adaptive frequency (every Nth prompt), or staleness checks (only fire if condition persists).</p> <p>Include actionable commands. \"You have 12 unexported sessions\" is less useful than \"You have 12 unexported sessions. Run: <code>ctx recall export --all</code>.\" Give the user (or agent) the exact next step.</p> <p>Use box-drawing for visual structure. The <code>┌─ ─┐ │ └─ ─┘</code> pattern makes hook output visually distinct from agent prose. It also signals \"this is machine-generated, not agent opinion.\"</p> <p>Test the silence path. Most hook runs should produce no output (the condition isn't met). Make sure the common case is fast and silent.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#common-pitfalls","level":2,"title":"Common Pitfalls","text":"<p>Lessons from 19 days of hook debugging in <code>ctx</code>. Every one of these was encountered, debugged, and fixed in production.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#silent-misfire-wrong-key-name","level":3,"title":"Silent misfire: wrong key name","text":"<pre><code>{ \"PreToolUseHooks\": [ ... ] }\n</code></pre> <p>The key is <code>PreToolUse</code>, not <code>PreToolUseHooks</code>. Claude Code validates silently -- a misspelled key means the hook is ignored with no error. Always test with a debug <code>echo</code> first to confirm the hook fires before adding real logic.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#json-escaping-breaks-shell-commands","level":3,"title":"JSON escaping breaks shell commands","text":"<p>Go's <code>json.Marshal</code> escapes <code>&gt;</code>, <code>&lt;</code>, and <code>&amp;</code> as Unicode sequences (<code>\\u003e</code>) by default. This breaks shell commands in generated config:</p> <pre><code>\"command\": \"ctx agent 2\\u003e/dev/null\"\n</code></pre> <p>Fix: use <code>json.Encoder</code> with <code>SetEscapeHTML(false)</code> when generating hook configuration.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#stdin-not-environment-variables","level":3,"title":"Stdin, not environment variables","text":"<p>Hook input arrives as JSON via stdin, not environment variables:</p> <pre><code># Wrong:\nCOMMAND=\"$CLAUDE_TOOL_INPUT\"\n\n# Right:\nHOOK_INPUT=$(cat)\nCOMMAND=$(echo \"$HOOK_INPUT\" | jq -r '.tool_input.command // empty')\n</code></pre>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#regex-overfitting","level":3,"title":"Regex overfitting","text":"<p>A regex meant to catch <code>ctx</code> as a binary will also match <code>ctx</code> as a directory component:</p> <pre><code># Too broad -- blocks: git -C /home/jose/WORKSPACE/ctx status\n(/home/|/tmp/|/var/)[^ ]*ctx[^ ]*\n\n# Narrow to binary only:\n(/home/|/tmp/|/var/)[^ ]*/ctx( |$)\n</code></pre> <p>Test hook regexes against paths that contain the target string as a substring, not just as the final component.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#repetition-fatigue","level":3,"title":"Repetition fatigue","text":"<p>Injecting context on every tool call sounds safe. In practice, after seeing the same context injection fifteen times, the agent treats it as background noise -- conventions stated in the injected context get violated because salience has been destroyed by repetition.</p> <p>Fix: cooldowns. <code>ctx agent --session $PPID --cooldown 10m</code> injects at most once per ten minutes per session using a tombstone file in <code>/tmp/</code>. This is not an optimization; it is a correction for a design flaw. Every injection consumes attention budget -- 50 tool calls at 4,000 tokens each means 200,000 tokens of repeated context, most of it wasted.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#hardcoded-paths","level":3,"title":"Hardcoded paths","text":"<p>A username rename (<code>parallels</code> to <code>jose</code>) broke every hook at once. Use <code>$CLAUDE_PROJECT_DIR</code> instead of absolute paths:</p> <pre><code>\"command\": \"\\\"$CLAUDE_PROJECT_DIR\\\"/.claude/hooks/block-git-push.sh\"\n</code></pre> <p>If the platform provides a runtime variable for paths, always use it.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#next-up","level":2,"title":"Next Up","text":"<p>Using the Scratchpad →: Store short-lived sensitive notes in an encrypted scratchpad.</p>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/hook-output-patterns/#see-also","level":2,"title":"See Also","text":"<ul> <li>Claude Code Permission Hygiene: how   permissions and hooks work together</li> <li>Defense in Depth:   why hooks matter for agent security</li> </ul>","path":["Recipes","Hook Output Patterns"],"tags":[]},{"location":"recipes/knowledge-capture/","level":1,"title":"Persisting Decisions, Learnings, and Conventions","text":"","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/knowledge-capture/#problem","level":2,"title":"Problem","text":"<p>You debug a subtle issue, discover the root cause, and move on.</p> <p>Three weeks later, a different session hits the same issue. The knowledge existed briefly in one session's memory but was never written down.</p> <p>Architectural decisions suffer the same fate: you weigh trade-offs, pick an approach, and six sessions later the AI suggests the alternative you already rejected.</p> <p>How do you make sure important context survives across sessions?</p>","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/knowledge-capture/#commands-and-skills-used","level":2,"title":"Commands and Skills Used","text":"Tool Type Purpose <code>ctx add decision</code> Command Record an architectural decision <code>ctx add learning</code> Command Record a gotcha, tip, or lesson <code>ctx add convention</code> Command Record a coding pattern or standard <code>ctx decisions reindex</code> Command Rebuild the quick-reference index <code>ctx learnings reindex</code> Command Rebuild the quick-reference index <code>/ctx-add-decision</code> Skill AI-guided decision capture with validation <code>/ctx-add-learning</code> Skill AI-guided learning capture with validation <code>/ctx-add-convention</code> Skill AI-guided convention recording with placement <code>/ctx-reflect</code> Skill Surface items worth persisting at breakpoints","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/knowledge-capture/#the-workflow","level":2,"title":"The Workflow","text":"","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/knowledge-capture/#step-1-understand-what-to-persist","level":3,"title":"Step 1: Understand What to Persist","text":"<p>Three context files serve different purposes:</p> <p>Decisions (<code>DECISIONS.md</code>) answer \"why is it this way?\" They record trade-offs between alternatives with structured fields: context, rationale, and consequences. Decisions prevent re-debating settled questions.</p> <p>Learnings (<code>LEARNINGS.md</code>) answer \"what did we discover the hard way?\" They record gotchas and debugging insights specific to this project with structured fields: context, lesson, and application. </p> <p>Learnings prevent repeating past mistakes.</p> <p>Conventions (<code>CONVENTIONS.md</code>) answer \"how do we do things here?\" They record patterns and standards. No structured fields required: just a name, a rule, and an example. Conventions keep code consistent across sessions.</p> <p>Decision, Learning, or Convention?</p> <ul> <li>If you chose between alternatives, it is a decision.</li> <li>If you discovered something surprising, it is a learning.</li> <li>If you are codifying a repeated pattern, it is a convention.</li> </ul>","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/knowledge-capture/#step-2-record-decisions","level":3,"title":"Step 2: Record Decisions","text":"<p>Decisions have three structured fields: </p> <ul> <li>context, </li> <li>rationale, </li> <li>and consequences.</li> </ul> <p>The easiest way to record one is to tell your agent:</p> <pre><code>You: \"Save that as a decision: we picked file-based cooldown\n      tokens over env vars.\"\n\nAgent: \"Recorded in DECISIONS.md:\n  - Decision: Use file-based cooldown tokens instead of env vars\n  - Context: Hook subprocesses cannot persist env vars to parent shell\n  - Rationale: File tokens survive across processes. Simpler than\n    IPC. Cleanup is automatic via TTL.\n  - Consequences: Tombstone files accumulate in /tmp. Cannot share\n    state across machines.\"\n</code></pre> <p>The agent was present for the trade-off discussion. It fills in the structured fields from what it observed, which is hard to reconstruct later as a terminal one-liner.</p> <p>When multiple options were considered, the agent includes rejected alternatives in the rationale automatically.</p> <p>The <code>/ctx-add-decision</code> skill also guides you through the fields interactively. For quick decisions, it supports a Y-statement:</p> <p>\"In the context of [situation], facing [constraint], we decided for [choice] and against [alternatives], to achieve [benefit], accepting that [trade-off].\"</p> CLI command for scripting and automation <p>When no agent is in the loop (CI pipelines, shell scripts, hooks), use the CLI directly with structured flags:</p> <pre><code>ctx add decision \"Use file-based cooldown tokens instead of env vars\" \\\n  --context \"Hook subprocesses cannot persist env vars to parent shell\" \\\n  --rationale \"File tokens survive across processes. Simpler than IPC. Cleanup is automatic via TTL.\" \\\n  --consequences \"Tombstone files accumulate in /tmp. Cannot share state across machines.\"\n</code></pre>","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/knowledge-capture/#step-3-record-learnings","level":3,"title":"Step 3: Record Learnings","text":"<p>Learnings have three structured fields: context, lesson, and application.</p> <p>Again, your agent is the best tool for this. It was there when you discovered the gotcha and can express it more completely than a backslash-escaped terminal command:</p> <pre><code>You: \"That subprocess thing was painful. Save it as a learning.\"\n\nAgent: \"Added to LEARNINGS.md:\n  - Learning: Claude Code hooks run in a subprocess\n  - Context: Set env var in PreToolUse hook, but it was not visible\n    in the main session\n  - Lesson: Hook scripts execute in a child process. Env changes do\n    not propagate to parent.\n  - Application: Use tombstone files for hook-to-session\n    communication. Never rely on hook env vars.\"\n</code></pre> <p>You said one sentence. The agent produced a structured entry with all three fields filled from the session context.</p> <p>That is the point: the agent has the full conversation and can be far more expressive than what you would type at a command prompt.</p> <p>The <code>/ctx-add-learning</code> skill applies three quality filters:</p> <ul> <li>(1) Could someone Google this in 5 minutes?</li> <li>(2) Is it specific to this codebase?</li> <li>(3) Did it take real effort to discover?</li> </ul> <p>All three must pass.</p> <p>Learnings capture principles and heuristics, not code snippets.</p> CLI command for scripting and automation <p>When no agent is in the loop:</p> <pre><code>ctx add learning \"Claude Code hooks run in a subprocess\" \\\n  --context \"Set env var in PreToolUse hook, but it was not visible in the main session\" \\\n  --lesson \"Hook scripts execute in a child process. Env changes do not propagate to parent.\" \\\n  --application \"Use tombstone files for hook-to-session communication. Never rely on hook env vars.\"\n</code></pre>","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/knowledge-capture/#step-4-record-conventions","level":3,"title":"Step 4: Record Conventions","text":"<p>Conventions are simpler: just a name, a rule, and optionally a section.</p> <p>These are short enough that either approach works:</p> <pre><code>You: \"We've been using kebab-case for every CLI flag. Codify that.\"\n\nAgent: \"Added to CONVENTIONS.md under Naming:\n  'Use kebab-case for all CLI flag names.'\"\n</code></pre> <p>Or from the terminal:</p> <pre><code>ctx add convention \"Use kebab-case for all CLI flag names\" --section \"Naming\"\n</code></pre> <p>Conventions work best for rules that come up repeatedly. Codify a pattern the third time you see it, not the first.</p>","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/knowledge-capture/#step-5-reindex-after-manual-edits","level":3,"title":"Step 5: Reindex After Manual Edits","text":"<p><code>DECISIONS.md</code> and <code>LEARNINGS.md</code> maintain a quick-reference index at the top: a compact table of date and title for each entry. The index updates automatically via <code>ctx add</code>, but falls out of sync after hand edits.</p> <pre><code>ctx decisions reindex\nctx learnings reindex\n</code></pre> <p>Run reindex after any manual edit. The index lets AI tools scan all entries without reading the full file, which matters when token budgets are tight.</p>","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/knowledge-capture/#step-6-use-ctx-reflect-to-surface-what-to-capture","level":3,"title":"Step 6: Use /ctx-reflect to Surface What to Capture","text":"<p>At natural breakpoints (after completing a feature, fixing a bug, or before ending a session) use <code>/ctx-reflect</code> to identify items worth persisting.</p> <pre><code>/ctx-reflect\n</code></pre> <p>The skill walks through learnings, decisions, tasks, and session notes, skipping categories with nothing to report. The output includes specific commands for each suggested persist:</p> <pre><code>This session implemented file-based cooldown for `ctx agent` and\ndiscovered that hook subprocesses cannot set env vars in the parent.\n\nI'd suggest persisting:\n- **Learning**: Hook subprocesses cannot propagate env vars\n  `ctx add learning \"...\" --context \"...\" --lesson \"...\" --application \"...\"`\n- **Decision**: File-based cooldown tokens over env vars\n  `ctx add decision \"...\" --context \"...\" --rationale \"...\" --consequences \"...\"`\n\nWant me to persist any of these?\n</code></pre> <p>The skill always asks before persisting.</p> <p>Keep It Conversational</p> <p><code>/ctx-reflect</code> is not the only way to trigger reflection.</p> <p>Agents trained on the ctx playbook naturally surface persist-worthy items at breakpoints, even without invoking the skill explicitly.</p> <p>A conversational prompt like \"anything worth saving?\" or \"let's wrap up\" can trigger the same review.</p> <p>The skill provides a structured checklist, but the behavior is available through natural conversation.</p>","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/knowledge-capture/#step-7-the-conversational-approach","level":3,"title":"Step 7: The Conversational Approach","text":"<p>The commands shown in Steps 2 to 4 are precise, but you rarely need to type them yourself. When working with an agent that has loaded the ctx playbook, natural language triggers the same operations.</p> <p>You ask, the agent acts:</p> You say What the agent does \"What have we learned this session?\" Reviews recent work, identifies learnings, offers to persist \"Save that as a decision\" Captures the trade-off you just discussed with structured fields \"Any gotchas worth remembering?\" Scans recent work for non-obvious lessons \"Record that convention\" Adds the pattern you just agreed on to CONVENTIONS.md \"Let's wrap up\" Runs through the reflect checklist conversationally <p>Example exchange:</p> <pre><code>You: \"What did we learn from that debugging session?\"\n\nAgent: \"We discovered three things worth persisting:\n  1. Hook subprocesses can't propagate env vars to the parent. We\n     spent 20 minutes on this before switching to tombstone files.\n  2. Tombstone files need a TTL or they accumulate in /tmp.\n  3. The cooldown logic must check file mtime, not just existence.\n  Want me to save these as learnings?\"\n\nYou: \"Yes, all of them.\"\n\nAgent: \"Done. Added all three to LEARNINGS.md with structured fields.\"\n</code></pre> <p>The agent can also be proactive without being asked. The playbook encourages agents to persist context at natural milestones.</p> <p>You may see:</p> <ul> <li>After fixing a tricky bug: \"I noticed this was a non-obvious issue.   Want me to save it as a learning?\"</li> <li>After choosing between approaches: \"We just made a trade-off between   file-based tokens and IPC. Should I record this as a decision?\"</li> <li>At session milestones: the agent checks what is worth persisting and offers a   brief summary.</li> </ul> <p>When agents run unattended (no human in the loop), they may persist directly:</p> <ul> <li>\"I've added the subprocess env var gotcha to LEARNINGS.md so we don't hit it again.\"</li> <li>\"Recorded the decision to use file-based tokens over env vars in DECISIONS.md.\"</li> <li>\"Marked the cooldown task done and added a follow-up for TTL cleanup.\"</li> </ul> <p>This is behavior by design.</p> <p>The playbook's self-check prompt, \"If this session ended right now, would the next session know what happened?\" drives agents to persist early and often rather than waiting for explicit instructions.</p>","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/knowledge-capture/#putting-it-all-together","level":2,"title":"Putting It All Together","text":"","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/knowledge-capture/#command-line-approach-scripting-and-automation","level":3,"title":"Command-line approach (scripting and automation)","text":"<pre><code># Decision: record the trade-off\nctx add decision \"Use PostgreSQL over SQLite\" \\\n  --context \"Need concurrent multi-user access\" \\\n  --rationale \"SQLite locks on writes; Postgres handles concurrency\" \\\n  --consequences \"Requires a database server; team needs Postgres training\"\n\n# Learning: record the gotcha\nctx add learning \"SQL migrations must be idempotent\" \\\n  --context \"Deploy failed when migration ran twice after rollback\" \\\n  --lesson \"CREATE TABLE without IF NOT EXISTS fails on retry\" \\\n  --application \"Always use IF NOT EXISTS guards in migrations\"\n\n# Convention: record the pattern\nctx add convention \"API handlers return structured errors\" --section \"API\"\n\n# Reindex after manual edits\nctx decisions reindex\nctx learnings reindex\n\n# Reflect at breakpoints (from AI assistant)\n# /ctx-reflect\n</code></pre>","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/knowledge-capture/#conversational-approach-interactive-sessions","level":3,"title":"Conversational approach (interactive sessions)","text":"<pre><code>You: \"We just picked Postgres over SQLite for the concurrency\n      reasons. Save that?\"\n\nAgent: \"Recorded. Added to DECISIONS.md:\n  - Decision: Use PostgreSQL over SQLite\n  - Context: Need concurrent multi-user access\n  - Rationale: SQLite locks on writes; Postgres handles concurrency\n  - Consequences: Requires a database server; team needs Postgres\n    training\"\n\nYou: \"Also that migration thing. The deploy blew up when the\n      migration ran twice.\"\n\nAgent: \"Got it. Added to LEARNINGS.md:\n  - Learning: SQL migrations must be idempotent\n  - Lesson: CREATE TABLE without IF NOT EXISTS fails on retry\n  - Application: Always use IF NOT EXISTS guards in migrations\"\n\nYou: \"Good. Anything else worth saving before we wrap up?\"\n\nAgent: \"We've been using structured error returns in every API\n  handler this session. Want me to codify that as a convention?\"\n\nYou: \"Do it.\"\n\nAgent: \"Done. Added 'API handlers return structured errors' to\n  CONVENTIONS.md under the API section.\"\n</code></pre> <p>Both approaches produce the same structured entries in the same context files.</p> <ul> <li>The conversational approach is the natural fit for interactive sessions; </li> <li>the CLI commands are better suited for scripts, hooks, and automation pipelines.</li> </ul>","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/knowledge-capture/#tips","level":2,"title":"Tips","text":"<ul> <li>Record decisions at the moment of choice. The alternatives you considered and   the reasons you rejected them fade quickly. Capture trade-offs while they are   fresh.</li> <li>Learnings should fail the Google test. If someone could find it in a 5-minute   search, it does not belong in LEARNINGS.md.</li> <li>Conventions earn their place through repetition. Add a convention the third   time you see a pattern, not the first.</li> <li>Use <code>/ctx-reflect</code> at natural breakpoints. The checklist catches items you   might otherwise lose.</li> <li>**Keep the entries self-contained^^. Each entry should make sense on its own. A   future session may load only one due to token budget constraints.</li> <li>Reindex after every hand edit. It takes less than a second. A stale index   causes AI tools to miss entries.</li> <li>Prefer the structured fields. The verbosity forces clarity. A decision without   a rationale is just a fact. A learning without an application is just a story.</li> <li>Talk to your agent, do not type commands. In interactive sessions, the   conversational approach is the recommended way to capture knowledge. Say   \"save that as a learning\" or \"any decisions worth recording?\" and let the   agent handle the structured fields. Reserve the CLI commands for scripting,   automation, and CI/CD pipelines where there is no agent in the loop.</li> <li>Trust the agent's proactive instincts. Agents trained on the ctx playbook will   offer to persist context at milestones. A brief \"want me to save this?\" is   cheaper than re-discovering the same lesson three sessions later.</li> </ul>","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/knowledge-capture/#next-up","level":2,"title":"Next Up","text":"<p>Detecting and Fixing Drift: Keep context files accurate as your codebase evolves.</p>","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/knowledge-capture/#see-also","level":2,"title":"See Also","text":"<ul> <li>Tracking Work Across Sessions: managing the tasks that   decisions and learnings support</li> <li>The Complete Session: full session lifecycle including   reflection and context persistence</li> <li>Detecting and Fixing Drift: keeping knowledge files   accurate as the codebase evolves</li> <li>CLI Reference: full documentation for <code>ctx add</code>,   <code>ctx decisions</code>, <code>ctx learnings</code></li> <li>Context Files: format and conventions for <code>DECISIONS.md</code>,   <code>LEARNINGS.md</code>, and <code>CONVENTIONS.md</code></li> </ul>","path":["Recipes","Persisting Decisions, Learnings, and Conventions"],"tags":[]},{"location":"recipes/multi-tool-setup/","level":1,"title":"Setting Up ctx Across AI Tools","text":"","path":["Recipes","Setting Up ctx Across AI Tools"],"tags":[]},{"location":"recipes/multi-tool-setup/#the-problem","level":2,"title":"The Problem","text":"<p>You have installed <code>ctx</code> and want to set it up with your AI coding assistant so that context persists across sessions. Different tools have different integration depths. For example: </p> <ul> <li>Claude Code supports native hooks that load and save context automatically</li> <li>Cursor injects context via its system prompt</li> <li>Aider reads context files through its <code>--read</code> flag</li> </ul> <p>This recipe walks through the complete setup for each tool, from initialization through verification, so you end up with a working memory layer regardless of which AI tool you use.</p> <p>TL;DR</p> <pre><code>cd your-project\nctx init                              # creates .context/ and seeds permissions\nsource &lt;(ctx completion zsh)          # shell completion (or bash/fish)\n# For other tools:\nctx hook cursor                       # or: aider, copilot, windsurf\n</code></pre> <p>Then start your AI tool and ask: \"Do you remember?\"</p>","path":["Recipes","Setting Up ctx Across AI Tools"],"tags":[]},{"location":"recipes/multi-tool-setup/#commands-and-skills-used","level":2,"title":"Commands and Skills Used","text":"Command/Skill Role in this workflow <code>ctx init</code> Create <code>.context/</code> directory, templates, and permissions <code>ctx hook</code> Generate integration configuration for a specific AI tool <code>ctx agent</code> Print a token-budgeted context packet for AI consumption <code>ctx load</code> Output assembled context in read order (for manual pasting) <code>ctx watch</code> Auto-apply context updates from AI output (non-native tools) <code>ctx completion</code> Generate shell autocompletion for bash, zsh, or fish <code>ctx recall export</code> Export sessions to editable journal Markdown","path":["Recipes","Setting Up ctx Across AI Tools"],"tags":[]},{"location":"recipes/multi-tool-setup/#the-workflow","level":2,"title":"The Workflow","text":"","path":["Recipes","Setting Up ctx Across AI Tools"],"tags":[]},{"location":"recipes/multi-tool-setup/#step-1-initialize-ctx","level":3,"title":"Step 1: Initialize ctx","text":"<p>Run <code>ctx init</code> in your project root. This creates the <code>.context/</code> directory with all template files and seeds ctx permissions in <code>settings.local.json</code>.</p> <pre><code>cd your-project\nctx init\n</code></pre> <p>This produces the following structure:</p> <pre><code>.context/\n  CONSTITUTION.md     # Hard rules the AI must never violate\n  TASKS.md            # Current and planned work\n  CONVENTIONS.md      # Code patterns and standards\n  ARCHITECTURE.md     # System overview\n  DECISIONS.md        # Architectural decisions with rationale\n  LEARNINGS.md        # Lessons learned, gotchas, tips\n  GLOSSARY.md         # Domain terms and abbreviations\n  AGENT_PLAYBOOK.md   # How AI tools should use this system\n</code></pre> <p>For Claude Code, install the ctx plugin to get hooks and skills:</p> <pre><code>claude /plugin marketplace add ActiveMemory/ctx\nclaude /plugin install ctx@activememory-ctx\n</code></pre> <p>If you only need the core files (useful for lightweight setups with Cursor or Copilot), use the <code>--minimal</code> flag:</p> <pre><code>ctx init --minimal\n</code></pre> <p>This creates only <code>TASKS.md</code>, <code>DECISIONS.md</code>, and <code>CONSTITUTION.md</code>.</p>","path":["Recipes","Setting Up ctx Across AI Tools"],"tags":[]},{"location":"recipes/multi-tool-setup/#step-2-generate-tool-specific-hooks","level":3,"title":"Step 2: Generate Tool-Specific Hooks","text":"<p>If you are using a tool other than Claude Code (which is configured automatically by <code>ctx init</code>), generate its integration configuration:</p> <pre><code># For Cursor\nctx hook cursor\n\n# For Aider\nctx hook aider\n\n# For GitHub Copilot\nctx hook copilot\n\n# For Windsurf\nctx hook windsurf\n</code></pre> <p>Each command prints the configuration you need. How you apply it depends on the tool.</p> <p>Claude is a First-Class Citizen</p> <p>With the ctx plugin installed, Claude Code gets hooks and skills automatically. The <code>PreToolUse</code> hook runs <code>ctx agent --budget 4000</code> on every tool call (with a 10-minute cooldown so it only fires once per window).</p> <p>Cursor: Add the system prompt snippet to <code>.cursor/settings.json</code>:</p> <pre><code>{\n  \"ai.systemPrompt\": \"Read .context/TASKS.md and .context/CONVENTIONS.md before responding. Follow rules in .context/CONSTITUTION.md.\"\n}\n</code></pre> <p>Context files appear in Cursor's file tree. You can also paste a context packet directly into chat:</p> <pre><code>ctx agent --budget 4000 | xclip    # Linux\nctx agent --budget 4000 | pbcopy   # macOS\n</code></pre> <p>Aider: Create <code>.aider.conf.yml</code> so context files are loaded on every session:</p> <pre><code>read:\n  - .context/CONSTITUTION.md\n  - .context/TASKS.md\n  - .context/CONVENTIONS.md\n  - .context/DECISIONS.md\n</code></pre> <p>Then start Aider normally:</p> <pre><code>aider\n</code></pre> <p>Or specify files on the command line:</p> <pre><code>aider --read .context/TASKS.md --read .context/CONVENTIONS.md\n</code></pre>","path":["Recipes","Setting Up ctx Across AI Tools"],"tags":[]},{"location":"recipes/multi-tool-setup/#step-3-set-up-shell-completion","level":3,"title":"Step 3: Set Up Shell Completion","text":"<p>Shell completion lets you tab-complete ctx subcommands and flags, which is especially useful while learning the CLI.</p> <pre><code># Bash (add to ~/.bashrc)\nsource &lt;(ctx completion bash)\n\n# Zsh (add to ~/.zshrc)\nsource &lt;(ctx completion zsh)\n\n# Fish\nctx completion fish &gt; ~/.config/fish/completions/ctx.fish\n</code></pre> <p>After sourcing, typing <code>ctx a&lt;TAB&gt;</code> completes to <code>ctx agent</code>, and <code>ctx recall &lt;TAB&gt;</code> shows <code>list</code>, <code>show</code>, and <code>export</code>.</p>","path":["Recipes","Setting Up ctx Across AI Tools"],"tags":[]},{"location":"recipes/multi-tool-setup/#step-4-verify-the-setup-works","level":3,"title":"Step 4: Verify the Setup Works","text":"<p>Start a fresh session in your AI tool and ask:</p> <p>\"Do you remember?\"</p> <p>A correctly configured tool responds with specific context: current tasks from <code>TASKS.md</code>, recent decisions, and previous session topics. It should not say \"I don't have memory\" or \"Let me search for files.\"</p> <p>This question checks the passive side of memory. A properly set-up agent is also proactive: it treats context maintenance as part of its job.</p> <ul> <li>After a debugging session, it offers to save a learning</li> <li>After a trade-off discussion, it asks whether to record the decision</li> <li>After completing a task, it suggests follow-up items</li> </ul> <p>The \"do you remember?\" check verifies both halves: recall and responsibility.</p> <p>For example, after resolving a tricky bug, a proactive agent might say:</p> <p>That Redis timeout issue was subtle. Want me to save this as a learning so we don't hit it again?</p> <p>If you see behavior like this, the setup is working end to end.</p> <p>In Claude Code, you can also invoke the <code>/ctx-status</code> skill:</p> <pre><code>/ctx-status\n</code></pre> <p>This prints a summary of all context files, token counts, and recent activity, confirming that hooks are loading context.</p> <p>If context is not loading, check the basics:</p> Symptom Fix <code>ctx: command not found</code> Ensure ctx is in your PATH: <code>which ctx</code> Hook errors Verify plugin is installed: <code>claude /plugin list</code> Context not refreshing Cooldown may be active; wait 10 minutes or set <code>--cooldown 0</code>","path":["Recipes","Setting Up ctx Across AI Tools"],"tags":[]},{"location":"recipes/multi-tool-setup/#step-5-enable-watch-mode-for-non-native-tools","level":3,"title":"Step 5: Enable Watch Mode for Non-Native Tools","text":"<p>Tools like Aider, Copilot, and Windsurf do not support native hooks for saving context automatically. For these, run <code>ctx watch</code> alongside your AI tool.</p> <p>Pipe the AI tool's output through <code>ctx watch</code>:</p> <pre><code># Terminal 1: Run Aider with output logged\naider 2&gt;&amp;1 | tee /tmp/aider.log\n\n# Terminal 2: Watch the log for context updates\nctx watch --log /tmp/aider.log\n</code></pre> <p>Or for any generic tool:</p> <pre><code>your-ai-tool 2&gt;&amp;1 | tee /tmp/ai.log &amp;\nctx watch --log /tmp/ai.log\n</code></pre> <p>When the AI emits structured update commands, <code>ctx watch</code> parses and applies them automatically:</p> <pre><code>&lt;context-update type=\"learning\"\n  context=\"Debugging rate limiter\"\n  lesson=\"Redis MULTI/EXEC does not roll back on error\"\n  application=\"Wrap rate-limit checks in Lua scripts instead\"\n&gt;Redis Transaction Behavior&lt;/context-update&gt;\n</code></pre> <p>To preview changes without modifying files:</p> <pre><code>ctx watch --dry-run --log /tmp/ai.log\n</code></pre>","path":["Recipes","Setting Up ctx Across AI Tools"],"tags":[]},{"location":"recipes/multi-tool-setup/#step-6-export-session-transcripts-optional","level":3,"title":"Step 6: Export Session Transcripts (Optional)","text":"<p>If you want to browse past session transcripts, export them to the journal:</p> <pre><code>ctx recall export --all\n</code></pre> <p>This converts raw session data into editable Markdown files in <code>.context/journal/</code>. You can then enrich them with metadata using <code>/ctx-journal-enrich-all</code> inside your AI assistant.</p>","path":["Recipes","Setting Up ctx Across AI Tools"],"tags":[]},{"location":"recipes/multi-tool-setup/#putting-it-together","level":2,"title":"Putting It Together","text":"<p>Here is the condensed setup for all three tools:</p> <pre><code># -- Common (run once per project) --\ncd your-project\nctx init\nsource &lt;(ctx completion zsh)       # or bash/fish\n\n# -- Claude Code (automatic, just verify) --\n# Start Claude Code, then ask: \"Do you remember?\"\n\n# -- Cursor --\nctx hook cursor\n# Add the system prompt to .cursor/settings.json\n# Paste context: ctx agent --budget 4000 | pbcopy\n\n# -- Aider --\nctx hook aider\n# Create .aider.conf.yml with read: paths\n# Run watch mode alongside: ctx watch --log /tmp/aider.log\n\n# -- Verify any tool --\n# Ask your AI: \"Do you remember?\"\n# Expect: specific tasks, decisions, recent context\n</code></pre>","path":["Recipes","Setting Up ctx Across AI Tools"],"tags":[]},{"location":"recipes/multi-tool-setup/#tips","level":2,"title":"Tips","text":"<ul> <li>Start with <code>ctx init</code> (not <code>--minimal</code>) for your first project. The full   template set gives the agent more to work with, and you can always delete   files later.</li> <li>For Claude Code, the token budget is configured in the plugin's <code>hooks.json</code>.   To customize, adjust the <code>--budget</code> flag in the <code>ctx agent</code> hook command.</li> <li>The <code>--session $PPID</code> flag isolates cooldowns per Claude Code process, so   parallel sessions do not suppress each other.</li> <li>Commit your <code>.context/</code> directory to version control. Several ctx features   (journals, changelogs, blog generation) rely on git history.</li> <li>For Cursor and Copilot, keep <code>CONVENTIONS.md</code> visible. These tools treat   open files as higher-priority context.</li> <li>Run <code>ctx drift</code> periodically to catch stale references before they confuse   the agent.</li> <li>The agent playbook instructs the agent to persist context at natural   milestones (completed tasks, decisions, gotchas). In practice, this   works best when you reinforce the habit: a quick \"anything worth saving?\"   after a debugging session goes a long way.</li> </ul>","path":["Recipes","Setting Up ctx Across AI Tools"],"tags":[]},{"location":"recipes/multi-tool-setup/#next-up","level":2,"title":"Next Up","text":"<p>Claude Code Permission Hygiene →: Recommended permission defaults and maintenance workflow for Claude Code.</p>","path":["Recipes","Setting Up ctx Across AI Tools"],"tags":[]},{"location":"recipes/multi-tool-setup/#see-also","level":2,"title":"See Also","text":"<ul> <li>The Complete Session: full session lifecycle recipe</li> <li>CLI Reference: all commands and flags</li> <li>Integrations: detailed per-tool integration docs</li> </ul>","path":["Recipes","Setting Up ctx Across AI Tools"],"tags":[]},{"location":"recipes/parallel-worktrees/","level":1,"title":"Parallel Agent Development with Git Worktrees","text":"","path":["Recipes","Parallel Agent Development with Git Worktrees"],"tags":[]},{"location":"recipes/parallel-worktrees/#problem","level":2,"title":"Problem","text":"<p>You have a large backlog — 10, 20, 30 open tasks — and many of them are independent: docs work that doesn't touch Go code, a new package that doesn't overlap with existing ones, test coverage for a stable module.</p> <p>Running one agent at a time means serial execution. You want 3-4 agents working in parallel, each on its own track, without stepping on each other's files.</p> <p>Git worktrees solve this. Each worktree is a separate working directory with its own branch, but they share the same <code>.git</code> object database. Combined with ctx's persistent context, each agent session picks up the full project state and works independently.</p> <p>TL;DR</p> <p><pre><code>/ctx-worktree                                     # 1. group tasks by file overlap\n</code></pre> <pre><code>git worktree add ../myproject-docs -b work/docs   # 2. create worktrees\ncd ../myproject-docs &amp;&amp; claude                     # 3. launch agents (one per track)\n</code></pre> <pre><code>/ctx-worktree teardown docs                        # 4. merge back and clean up\n</code></pre></p> <p>TASKS.md will conflict on merge — accept all <code>[x]</code> completions from both sides.</p>","path":["Recipes","Parallel Agent Development with Git Worktrees"],"tags":[]},{"location":"recipes/parallel-worktrees/#commands-and-skills-used","level":2,"title":"Commands and Skills Used","text":"Tool Type Purpose <code>/ctx-worktree</code> Skill Create, list, and tear down worktrees <code>/ctx-next</code> Skill Pick tasks from the backlog for each track <code>git worktree</code> Command Underlying git worktree management <code>git merge</code> Command Merge completed tracks back to main","path":["Recipes","Parallel Agent Development with Git Worktrees"],"tags":[]},{"location":"recipes/parallel-worktrees/#the-workflow","level":2,"title":"The Workflow","text":"","path":["Recipes","Parallel Agent Development with Git Worktrees"],"tags":[]},{"location":"recipes/parallel-worktrees/#step-1-assess-the-backlog","level":3,"title":"Step 1: Assess the Backlog","text":"<p>Start in your main checkout. Ask the agent to analyze your tasks and group them by blast radius — which files and directories each task touches.</p> <pre><code>/ctx-worktree\nLook at TASKS.md and group the pending tasks into 2-3 independent\ntracks based on which files they'd touch. Show me the grouping\nbefore creating anything.\n</code></pre> <p>The agent reads TASKS.md, estimates file overlap, and proposes groups:</p> <pre><code>Proposed worktree groups:\n\n  work/docs    — recipe updates, blog post (touches: docs/)\n  work/crypto  — scratchpad encryption infra (touches: internal/crypto/)\n  work/tests   — recall test coverage (touches: internal/cli/recall/)\n</code></pre>","path":["Recipes","Parallel Agent Development with Git Worktrees"],"tags":[]},{"location":"recipes/parallel-worktrees/#step-2-create-the-worktrees","level":3,"title":"Step 2: Create the Worktrees","text":"<p>Once you approve the grouping, the agent creates worktrees as sibling directories:</p> <pre><code>Create the worktrees for those three groups.\n</code></pre> <p>Behind the scenes:</p> <pre><code>git worktree add ../myproject-docs -b work/docs\ngit worktree add ../myproject-crypto -b work/crypto\ngit worktree add ../myproject-tests -b work/tests\n</code></pre> <p>Each worktree is a full working copy on its own branch.</p>","path":["Recipes","Parallel Agent Development with Git Worktrees"],"tags":[]},{"location":"recipes/parallel-worktrees/#step-3-launch-agents","level":3,"title":"Step 3: Launch Agents","text":"<p>Open a separate terminal (or editor window) for each worktree and start a Claude Code session:</p> <pre><code># Terminal 1\ncd ../myproject-docs\nclaude\n\n# Terminal 2\ncd ../myproject-crypto\nclaude\n\n# Terminal 3\ncd ../myproject-tests\nclaude\n</code></pre> <p>Each agent sees the full project, including <code>.context/</code>, and can work independently. Do not run <code>ctx init</code> in worktrees — the context directory is already tracked in git.</p>","path":["Recipes","Parallel Agent Development with Git Worktrees"],"tags":[]},{"location":"recipes/parallel-worktrees/#step-4-work","level":3,"title":"Step 4: Work","text":"<p>Each agent works through its assigned tasks. They can read TASKS.md to know what's assigned to their track, use <code>/ctx-next</code> to pick the next item, and commit normally on their <code>work/*</code> branch.</p>","path":["Recipes","Parallel Agent Development with Git Worktrees"],"tags":[]},{"location":"recipes/parallel-worktrees/#step-5-merge-back","level":3,"title":"Step 5: Merge Back","text":"<p>As each track finishes, return to the main checkout and merge:</p> <pre><code>/ctx-worktree teardown docs\n</code></pre> <p>The agent checks for uncommitted changes, merges <code>work/docs</code> into your current branch, removes the worktree, and deletes the branch.</p>","path":["Recipes","Parallel Agent Development with Git Worktrees"],"tags":[]},{"location":"recipes/parallel-worktrees/#step-6-handle-tasksmd-conflicts","level":3,"title":"Step 6: Handle TASKS.md Conflicts","text":"<p>TASKS.md will almost always conflict when merging — multiple agents marked different tasks as <code>[x]</code>. This is expected and easy to resolve:</p> <p>Accept all completions from both sides. No task should go from <code>[x]</code> back to <code>[ ]</code>. The merge resolution is always additive.</p> <pre><code>The merge has a conflict in TASKS.md. Both branches completed\ndifferent tasks. Accept all [x] completions from both sides.\n</code></pre>","path":["Recipes","Parallel Agent Development with Git Worktrees"],"tags":[]},{"location":"recipes/parallel-worktrees/#step-7-cleanup","level":3,"title":"Step 7: Cleanup","text":"<p>After all tracks are merged, verify everything is clean:</p> <pre><code>/ctx-worktree list\n</code></pre> <p>Should show only the main working tree. All <code>work/*</code> branches should be gone.</p>","path":["Recipes","Parallel Agent Development with Git Worktrees"],"tags":[]},{"location":"recipes/parallel-worktrees/#conversational-approach","level":2,"title":"Conversational Approach","text":"<p>You don't have to use the skill directly for every step. These natural prompts work:</p> <ul> <li>\"I have a big backlog. Can we split it across worktrees?\"</li> <li>\"Which of these tasks can run in parallel without conflicts?\"</li> <li>\"Merge the docs track back in.\"</li> <li>\"Clean up all the worktrees, we're done.\"</li> </ul>","path":["Recipes","Parallel Agent Development with Git Worktrees"],"tags":[]},{"location":"recipes/parallel-worktrees/#tips","level":2,"title":"Tips","text":"<ul> <li>3-4 worktrees max. Beyond that, merge complexity outweighs the   parallelism benefit. The skill enforces this limit.</li> <li>Group by package or directory, not by priority. Two high-priority   tasks that touch the same files must be in the same track.</li> <li>TASKS.md will conflict on merge. This is normal. Accept all <code>[x]</code>   completions — the resolution is always additive.</li> <li>Don't run <code>ctx init</code> in worktrees. The <code>.context/</code> directory is   tracked in git. Running init overwrites shared context files.</li> <li>Name worktrees by concern, not by number. <code>work/docs</code> and   <code>work/crypto</code> are more useful than <code>work/track-1</code> and <code>work/track-2</code>.</li> <li>Commit frequently in each worktree. Smaller commits make merge   conflicts easier to resolve.</li> </ul>","path":["Recipes","Parallel Agent Development with Git Worktrees"],"tags":[]},{"location":"recipes/parallel-worktrees/#next-up","level":2,"title":"Next Up","text":"<p>When to Use a Team of Agents →: Decide when multi-agent coordination is worth the overhead.</p>","path":["Recipes","Parallel Agent Development with Git Worktrees"],"tags":[]},{"location":"recipes/parallel-worktrees/#see-also","level":2,"title":"See Also","text":"<ul> <li>Running an Unattended AI Agent — for serial   autonomous loops instead of parallel tracks</li> <li>Tracking Work Across Sessions — managing the   task backlog that feeds into parallelization</li> <li>The Complete Session — the session workflow   each agent follows inside its worktree</li> </ul>","path":["Recipes","Parallel Agent Development with Git Worktrees"],"tags":[]},{"location":"recipes/permission-snapshots/","level":1,"title":"Permission Snapshots","text":"","path":["Recipes","Permission Snapshots"],"tags":[]},{"location":"recipes/permission-snapshots/#the-problem","level":2,"title":"The Problem","text":"<p>Claude Code's <code>.claude/settings.local.json</code> accumulates one-off permissions every time you click \"Allow.\" After busy sessions the file is full of session-specific entries that expand the agent's surface area beyond intent.</p> <p>Since <code>settings.local.json</code> is <code>.gitignore</code>d, there is no PR review or CI check. The file drifts independently on every machine, and there is no built-in way to reset to a known-good state.</p>","path":["Recipes","Permission Snapshots"],"tags":[]},{"location":"recipes/permission-snapshots/#the-solution","level":2,"title":"The Solution","text":"<p>Save a curated <code>settings.local.json</code> as a golden image, then restore from it to drop session-accumulated permissions. The golden file (<code>.claude/settings.golden.json</code>) is committed to version control and shared with the team.</p>","path":["Recipes","Permission Snapshots"],"tags":[]},{"location":"recipes/permission-snapshots/#commands-and-skills-used","level":2,"title":"Commands and Skills Used","text":"Command/Skill Role in this workflow <code>ctx permissions snapshot</code> Save settings.local.json as golden image <code>ctx permissions restore</code> Reset settings.local.json from golden image <code>/sanitize-permissions</code> Audit for dangerous patterns before snapshotting","path":["Recipes","Permission Snapshots"],"tags":[]},{"location":"recipes/permission-snapshots/#step-by-step","level":2,"title":"Step by Step","text":"","path":["Recipes","Permission Snapshots"],"tags":[]},{"location":"recipes/permission-snapshots/#1-curate-your-permissions","level":3,"title":"1. Curate your permissions","text":"<p>Start with a clean <code>settings.local.json</code>. Optionally run <code>/sanitize-permissions</code> to remove dangerous patterns first.</p> <p>Review the file manually. Every entry should be there because you decided it belongs, not because you clicked \"Allow\" once during debugging.</p> <p>See the Permission Hygiene recipe for recommended defaults.</p>","path":["Recipes","Permission Snapshots"],"tags":[]},{"location":"recipes/permission-snapshots/#2-take-a-snapshot","level":3,"title":"2. Take a snapshot","text":"<pre><code>ctx permissions snapshot\n# Saved golden image: .claude/settings.golden.json\n</code></pre> <p>This creates a byte-for-byte copy. No re-encoding, no indent changes.</p>","path":["Recipes","Permission Snapshots"],"tags":[]},{"location":"recipes/permission-snapshots/#3-commit-the-golden-file","level":3,"title":"3. Commit the golden file","text":"<pre><code>git add .claude/settings.golden.json\ngit commit -m \"Add permission golden image\"\n</code></pre> <p>The golden file is not gitignored (unlike <code>settings.local.json</code>). This is intentional: it becomes a team-shared baseline.</p>","path":["Recipes","Permission Snapshots"],"tags":[]},{"location":"recipes/permission-snapshots/#4-auto-restore-at-session-start","level":3,"title":"4. Auto-restore at session start","text":"<p>Add this instruction to your <code>CLAUDE.md</code>:</p> <pre><code>## On Session Start\n\nRun `ctx permissions restore` to reset permissions to the golden image.\n</code></pre> <p>The agent will restore the golden image at the start of every session, automatically dropping any permissions accumulated during previous sessions.</p>","path":["Recipes","Permission Snapshots"],"tags":[]},{"location":"recipes/permission-snapshots/#5-update-when-intentional-changes-are-made","level":3,"title":"5. Update when intentional changes are made","text":"<p>When you add a new permanent permission (not a one-off debugging entry):</p> <pre><code># Edit settings.local.json with the new permission\n# Then update the golden image:\nctx permissions snapshot\ngit add .claude/settings.golden.json\ngit commit -m \"Update permission golden image: add cargo test\"\n</code></pre>","path":["Recipes","Permission Snapshots"],"tags":[]},{"location":"recipes/permission-snapshots/#conversational-approach","level":2,"title":"Conversational Approach","text":"<p>You don't need to remember exact commands. These natural-language prompts work with agents trained on the ctx playbook:</p> What you say What happens \"Save my current permissions as baseline\" Agent runs <code>ctx permissions snapshot</code> \"Reset permissions to the golden image\" Agent runs <code>ctx permissions restore</code> \"Clean up my permissions\" Agent runs <code>/sanitize-permissions</code> then snapshot \"What permissions did I accumulate?\" Agent diffs local vs golden","path":["Recipes","Permission Snapshots"],"tags":[]},{"location":"recipes/permission-snapshots/#next-up","level":2,"title":"Next Up","text":"<p>Keeping Context in a Separate Repo →: Share <code>.context/</code> across projects or keep it in a dedicated repository.</p>","path":["Recipes","Permission Snapshots"],"tags":[]},{"location":"recipes/permission-snapshots/#see-also","level":2,"title":"See Also","text":"<ul> <li>Permission Hygiene: recommended defaults and   maintenance workflow</li> <li>CLI Reference: ctx permissions:   full command documentation</li> </ul>","path":["Recipes","Permission Snapshots"],"tags":[]},{"location":"recipes/publishing/","level":1,"title":"Turning Activity into Content","text":"","path":["Recipes","Turning Activity into Content"],"tags":[]},{"location":"recipes/publishing/#problem","level":2,"title":"Problem","text":"<p>Your <code>.context/</code> directory is full of decisions, learnings, and session history.</p> <p>Your <code>git log</code> tells the story of a project evolving.</p> <p>But none of this is visible to anyone outside your terminal.</p> <p>You want to turn this raw activity into:</p> <ul> <li>a browsable journal site</li> <li>blog posts</li> <li>changelog posts</li> </ul> <p>TL;DR</p> <p><pre><code>ctx recall export --all             # 1. export sessions to markdown\n</code></pre> <pre><code>/ctx-journal-normalize              # 2. fix rendering issues\n/ctx-journal-enrich-all             # 3. add metadata and tags\n</code></pre> <pre><code>ctx journal site --serve            # 4. build and serve the journal\n</code></pre> <pre><code>/ctx-blog about the caching layer   # 5. draft a blog post\n/ctx-blog-changelog v0.1.0 \"v0.2\"   # 6. write a changelog post\n</code></pre></p> <p>Read on for details on each stage.</p>","path":["Recipes","Turning Activity into Content"],"tags":[]},{"location":"recipes/publishing/#commands-and-skills-used","level":2,"title":"Commands and Skills Used","text":"Tool Type Purpose <code>ctx recall export</code> Command Export session JSONL to editable markdown <code>ctx journal site</code> Command Generate a static site from journal entries <code>ctx journal obsidian</code> Command Generate an Obsidian vault from journal entries <code>ctx serve</code> Command Serve the journal site locally <code>make journal</code> Makefile Shortcut for export + site rebuild <code>/ctx-journal-normalize</code> Skill Fix markdown rendering in exported entries <code>/ctx-journal-enrich-all</code> Skill Batch-enrich all unenriched entries (recommended) <code>/ctx-journal-enrich</code> Skill Add metadata, summaries, and tags to one entry <code>/ctx-blog</code> Skill Draft a blog post from recent project activity <code>/ctx-blog-changelog</code> Skill Write a themed post from a commit range","path":["Recipes","Turning Activity into Content"],"tags":[]},{"location":"recipes/publishing/#the-workflow","level":2,"title":"The Workflow","text":"","path":["Recipes","Turning Activity into Content"],"tags":[]},{"location":"recipes/publishing/#step-1-export-sessions-to-markdown","level":3,"title":"Step 1: Export Sessions to Markdown","text":"<p>Raw session data lives as JSONL files in Claude Code's internal storage. The first step is converting these into readable, editable markdown.</p> <pre><code># Export all sessions from the current project\nctx recall export --all\n\n# Export from all projects (if you work across multiple repos)\nctx recall export --all --all-projects\n\n# Export a single session by ID or slug\nctx recall export abc123\nctx recall export gleaming-wobbling-sutherland\n````\n\nExported files land in `.context/journal/` as individual Markdown files with\nsession metadata and the full conversation transcript. Re-exporting preserves\nany YAML frontmatter added by enrichment.\n\nUse `--skip-existing` to leave existing files untouched, or `--force` to\noverwrite everything.\n\n### Step 2: Normalize Exported Entries\n\nRaw exports can have rendering issues: nested code fences that break syntax\nhighlighting, metadata blocks that render poorly, and malformed lists. The\n`/ctx-journal-normalize` skill fixes these in the source files before site\ngeneration.\n\n```text\n/ctx-journal-normalize\n</code></pre> <p>The skill:</p> <ol> <li>Backs up <code>.context/journal/</code> before modifying anything</li> <li>Converts <code>**Key**: value</code> metadata blocks into collapsible HTML tables</li> <li>Fixes fence nesting so code blocks render with proper highlighting</li> <li>Marks processed files with <code>&lt;!-- normalized --&gt;</code> so reruns skip them</li> </ol> <p>Run normalize before enrich. Clean Markdown produces better metadata extraction in the next step.</p>","path":["Recipes","Turning Activity into Content"],"tags":[]},{"location":"recipes/publishing/#step-3-enrich-entries-with-metadata","level":3,"title":"Step 3: Enrich Entries with Metadata","text":"<p>Raw entries have timestamps and conversations but lack the structured metadata that makes a journal searchable. Use <code>/ctx-journal-enrich-all</code> to process your entire backlog at once:</p> <pre><code>/ctx-journal-enrich-all\n</code></pre> <p>The skill finds all unenriched entries, filters out noise (suggestion sessions, very short sessions, multipart continuations), and processes each one by extracting titles, topics, technologies, and summaries from the conversation.</p> <p>For large backlogs (20+ entries), it can spawn subagents to process entries in parallel.</p> <p>To enrich a single entry instead:</p> <pre><code>/ctx-journal-enrich twinkly-stirring-kettle\n/ctx-journal-enrich 2026-01-24\n</code></pre> <p>After enrichment, an entry gains YAML frontmatter:</p> <pre><code>---\ntitle: \"Implement Redis caching for API endpoints\"\ndate: 2026-01-24\ntype: feature\noutcome: completed\ntopics:\n  - caching\n  - api-performance\ntechnologies:\n  - go\n  - redis\nkey_files:\n  - internal/api/middleware/cache.go\n  - internal/cache/redis.go\n---\n</code></pre> <p>This metadata powers better navigation in the journal site: </p> <ul> <li>titles replace slugs, </li> <li>summaries appear in the index, </li> <li>and search covers topics and technologies.</li> </ul>","path":["Recipes","Turning Activity into Content"],"tags":[]},{"location":"recipes/publishing/#step-4-generate-the-journal-site","level":3,"title":"Step 4: Generate the Journal Site","text":"<p>With entries exported, normalized, and enriched, generate the static site:</p> <pre><code># Generate site files\nctx journal site\n\n# Generate and build static HTML\nctx journal site --build\n\n# Generate and serve locally (opens at http://localhost:8000)\nctx journal site --serve\n\n# Custom output directory\nctx journal site --output ~/my-journal\n</code></pre> <p>The site is generated in <code>.context/journal-site/</code> by default. It uses zensical for static site generation (<code>pipx install zensical</code>).</p> <p>Or use the Makefile shortcut that combines export and rebuild:</p> <pre><code>make journal\n</code></pre> <p>This runs <code>ctx recall export --all</code> followed by <code>ctx journal site --build</code>, then reminds you to normalize and enrich before rebuilding. To serve the built site, use <code>make journal-serve</code> or <code>ctx serve</code>.</p>","path":["Recipes","Turning Activity into Content"],"tags":[]},{"location":"recipes/publishing/#alternative-export-to-obsidian-vault","level":3,"title":"Alternative: Export to Obsidian Vault","text":"<p>If you use Obsidian for knowledge management, generate a vault instead of (or alongside) the static site:</p> <pre><code>ctx journal obsidian\nctx journal obsidian --output ~/vaults/ctx-journal\n</code></pre> <p>This produces an Obsidian-ready directory with wikilinks, MOC (Map of Content) pages for topics/files/types, and a \"Related Sessions\" footer on each entry for graph connectivity. Open the output directory in Obsidian as a vault.</p> <p>The vault uses the same enriched source entries as the static site. Both outputs can coexist — the static site goes to <code>.context/journal-site/</code>, the vault to <code>.context/journal-obsidian/</code>.</p>","path":["Recipes","Turning Activity into Content"],"tags":[]},{"location":"recipes/publishing/#step-5-draft-blog-posts-from-activity","level":3,"title":"Step 5: Draft Blog Posts from Activity","text":"<p>When your project reaches a milestone worth sharing, use <code>/ctx-blog</code> to draft a post from recent activity. The skill gathers context from multiple sources: <code>git log</code>, <code>DECISIONS.md</code>, <code>LEARNINGS.md</code>, completed tasks, and journal entries.</p> <pre><code>/ctx-blog about the caching layer we just built\n/ctx-blog last week's refactoring work\n/ctx-blog lessons learned from the migration\n</code></pre> <p>The skill gathers recent commits, decisions, and learnings; identifies a narrative arc; drafts an outline for approval; writes the full post; and saves it to <code>docs/blog/YYYY-MM-DD-slug.md</code>.</p> <p>Posts are written in first person with code snippets, commit references, and an honest discussion of what went wrong.</p>","path":["Recipes","Turning Activity into Content"],"tags":[]},{"location":"recipes/publishing/#step-6-write-changelog-posts-from-commit-ranges","level":3,"title":"Step 6: Write Changelog Posts from Commit Ranges","text":"<p>For release notes or \"what changed\" posts, <code>/ctx-blog-changelog</code> takes a starting commit and a theme, then analyzes everything that changed:</p> <pre><code>/ctx-blog-changelog 040ce99 \"building the journal system\"\n/ctx-blog-changelog HEAD~30 \"what's new in v0.2.0\"\n/ctx-blog-changelog v0.1.0 \"the road to v0.2.0\"\n</code></pre> <p>The skill diffs the commit range, identifies the most-changed files, and constructs a narrative organized by theme rather than chronology, including a key commits table and before/after comparisons.</p>","path":["Recipes","Turning Activity into Content"],"tags":[]},{"location":"recipes/publishing/#the-conversational-approach","level":2,"title":"The Conversational Approach","text":"<p>You do not need to remember any commands. When the Agent Playbook is active, your agent can suggest content at natural moments:</p> <p>\"We just shipped the caching layer and closed 3 tasks. Want me to draft a blog post about it?\"</p> <p>\"Your journal has 6 new entries since the last rebuild. Want me to normalize, enrich, and regenerate the site?\"</p> <p>You can also drive it with natural language:</p> <pre><code>\"write about what we did this week\"\n\"turn today's session into a blog post\"\n\"make a changelog post covering everything since the last release\"\n\"enrich the last few journal entries\"\n</code></pre> <p>The agent has full visibility into your <code>.context/</code> state (tasks completed, decisions recorded, learnings captured), so its suggestions are grounded in what actually happened.</p>","path":["Recipes","Turning Activity into Content"],"tags":[]},{"location":"recipes/publishing/#putting-it-together","level":2,"title":"Putting It Together","text":"<p>The full pipeline from raw transcripts to published content:</p> <pre><code># 1. Export all sessions\nctx recall export --all\n\n# 2. In Claude Code: normalize rendering\n/ctx-journal-normalize\n\n# 3. In Claude Code: enrich all entries with metadata\n/ctx-journal-enrich-all\n\n# 4. Build and serve the journal site\nmake journal\nmake journal-serve\n\n# 4b. Or generate an Obsidian vault\nctx journal obsidian\n\n# 5. In Claude Code: draft a blog post\n/ctx-blog about the features we shipped this week\n\n# 6. In Claude Code: write a changelog post\n/ctx-blog-changelog v0.1.0 \"what's new in v0.2.0\"\n</code></pre> <p>The journal pipeline is idempotent at every stage. You can rerun <code>ctx recall export --all</code> without losing enrichment. You can rerun <code>/ctx-journal-normalize</code> and it skips already-normalized files. You can rebuild the site as many times as you want.</p>","path":["Recipes","Turning Activity into Content"],"tags":[]},{"location":"recipes/publishing/#tips","level":2,"title":"Tips","text":"<ul> <li>Export regularly. Run <code>ctx recall export --all --skip-existing</code> after each   session to keep your journal current without reprocessing old entries.</li> <li>Normalize before enriching. The enrichment skill reads conversation content to   extract metadata. Clean Markdown produces better results than raw exports with   broken fences.</li> <li>Use batch enrichment. <code>/ctx-journal-enrich-all</code> filters noise (suggestion   sessions, trivial sessions, multipart continuations) so you do not have to   decide what is worth enriching.</li> <li>Keep journal files in <code>.gitignore</code>. Session journals can contain sensitive   data: file contents, commands, internal discussions, and error messages with   stack traces. Add <code>.context/journal/</code> and <code>.context/journal-site/</code> to   <code>.gitignore</code>.</li> <li>Use <code>/ctx-blog</code> for narrative posts and <code>/ctx-blog-changelog</code> for release   posts. One finds a story in recent activity, the other explains a commit   range by theme.</li> <li>Let the agent remind you. A proactive agent can suggest content generation   after milestones: shipping a feature, closing tasks, or finishing a long   debugging session.</li> <li>Edit the drafts. These skills produce drafts, not final posts. Review the   narrative, add your perspective, and remove anything that does not serve the   reader.</li> </ul>","path":["Recipes","Turning Activity into Content"],"tags":[]},{"location":"recipes/publishing/#next-up","level":2,"title":"Next Up","text":"<p>Back to the beginning: Setting Up ctx Across AI Tools</p> <p>Or explore the full recipe list.</p>","path":["Recipes","Turning Activity into Content"],"tags":[]},{"location":"recipes/publishing/#see-also","level":2,"title":"See Also","text":"<ul> <li>Session Journal: journal system, enrichment schema, context monitor</li> <li>CLI Reference: ctx recall: export, list, show session history</li> <li>CLI Reference: ctx journal site: static site generation</li> <li>CLI Reference: ctx journal obsidian: Obsidian vault export</li> <li>CLI Reference: ctx serve: local site serving</li> <li>Browsing and Enriching Past Sessions: journal browsing workflow</li> <li>The Complete Session: capturing context during a session</li> </ul>","path":["Recipes","Turning Activity into Content"],"tags":[]},{"location":"recipes/scratchpad-sync/","level":1,"title":"Syncing Scratchpad Notes Across Machines","text":"","path":["Recipes","Syncing Scratchpad Notes Across Machines"],"tags":[]},{"location":"recipes/scratchpad-sync/#problem","level":2,"title":"Problem","text":"<p>You work from multiple machines — a desktop and a laptop, or a local machine and a remote dev server.</p> <p>The scratchpad entries are encrypted. The ciphertext (<code>.context/scratchpad.enc</code>) travels with git, but the encryption key (<code>.context/.scratchpad.key</code>) is gitignored. Without the key on each machine, you cannot read or write entries.</p> <p>How do you distribute the key and keep the scratchpad in sync?</p> <p>TL;DR</p> <pre><code>ctx init                                                 # 1. generates .scratchpad.key\nscp .context/.scratchpad.key user@machine-b:project/.context/  # 2. copy key\nchmod 600 project/.context/.scratchpad.key                # 3. secure it\n# Normal git push/pull syncs the encrypted scratchpad.enc\n# On conflict: ctx pad resolve → rebuild → git add + commit\n</code></pre>","path":["Recipes","Syncing Scratchpad Notes Across Machines"],"tags":[]},{"location":"recipes/scratchpad-sync/#commands-and-skills-used","level":2,"title":"Commands and Skills Used","text":"Tool Type Purpose <code>ctx init</code> CLI command Initialize context (generates key automatically) <code>ctx pad add</code> CLI command Add a scratchpad entry <code>ctx pad rm</code> CLI command Remove a scratchpad entry <code>ctx pad edit</code> CLI command Edit a scratchpad entry <code>ctx pad resolve</code> CLI command Show both sides of a merge conflict <code>scp</code> Shell Copy the key file between machines <code>git push</code> / <code>git pull</code> Shell Sync the encrypted file via git <code>/ctx-pad</code> Skill Natural language interface to pad commands","path":["Recipes","Syncing Scratchpad Notes Across Machines"],"tags":[]},{"location":"recipes/scratchpad-sync/#the-workflow","level":2,"title":"The Workflow","text":"","path":["Recipes","Syncing Scratchpad Notes Across Machines"],"tags":[]},{"location":"recipes/scratchpad-sync/#step-1-initialize-on-machine-a","level":3,"title":"Step 1: Initialize on Machine A","text":"<p>Run <code>ctx init</code> on your first machine. The key is created automatically:</p> <pre><code>ctx init\n# ...\n# Created .context/.scratchpad.key (0600)\n# Created .context/scratchpad.enc\n</code></pre> <p>The key is gitignored. The <code>.enc</code> file is tracked.</p>","path":["Recipes","Syncing Scratchpad Notes Across Machines"],"tags":[]},{"location":"recipes/scratchpad-sync/#step-2-copy-the-key-to-machine-b","level":3,"title":"Step 2: Copy the Key to Machine B","text":"<p>Use any secure transfer method:</p> <pre><code># scp\nscp .context/.scratchpad.key user@machine-b:project/.context/\n\n# Or use a password manager, USB drive, etc.\n</code></pre> <p>Set permissions on Machine B:</p> <pre><code>chmod 600 project/.context/.scratchpad.key\n</code></pre> <p>Secure the Transfer</p> <p>The key is a raw 256-bit AES key. Anyone with the key can decrypt the scratchpad. Use an encrypted channel (SSH, password manager vault) — never paste it in plaintext over email or chat.</p>","path":["Recipes","Syncing Scratchpad Notes Across Machines"],"tags":[]},{"location":"recipes/scratchpad-sync/#step-3-normal-pushpull-workflow","level":3,"title":"Step 3: Normal Push/Pull Workflow","text":"<p>The encrypted file is committed, so standard git sync works:</p> <pre><code># Machine A: add entries and push\nctx pad add \"staging API key: sk-test-abc123\"\ngit add .context/scratchpad.enc\ngit commit -m \"Update scratchpad\"\ngit push\n\n# Machine B: pull and read\ngit pull\nctx pad\n#   1. staging API key: sk-test-abc123\n</code></pre> <p>Both machines have the same key, so both can decrypt the same <code>.enc</code> file.</p>","path":["Recipes","Syncing Scratchpad Notes Across Machines"],"tags":[]},{"location":"recipes/scratchpad-sync/#step-4-read-and-write-from-either-machine","level":3,"title":"Step 4: Read and Write from Either Machine","text":"<p>Once the key is distributed, all <code>ctx pad</code> commands work identically on both machines. Entries added on Machine A are visible on Machine B after a <code>git pull</code>, and vice versa.</p>","path":["Recipes","Syncing Scratchpad Notes Across Machines"],"tags":[]},{"location":"recipes/scratchpad-sync/#step-5-handle-merge-conflicts","level":3,"title":"Step 5: Handle Merge Conflicts","text":"<p>If both machines add entries between syncs, pulling will create a merge conflict on <code>.context/scratchpad.enc</code>. Git cannot merge binary (encrypted) content automatically.</p> <p>Use <code>ctx pad resolve</code> to see both sides:</p> <pre><code>ctx pad resolve\n# === Ours (this machine) ===\n#   1. staging API key: sk-test-abc123\n#   2. check DNS after deploy\n#\n# === Theirs (incoming) ===\n#   1. staging API key: sk-test-abc123\n#   2. new endpoint: api.example.com/v2\n</code></pre> <p>Then reconstruct the merged scratchpad:</p> <pre><code># Start fresh with all entries from both sides\nctx pad add \"staging API key: sk-test-abc123\"\nctx pad add \"check DNS after deploy\"\nctx pad add \"new endpoint: api.example.com/v2\"\n\n# Mark the conflict resolved\ngit add .context/scratchpad.enc\ngit commit -m \"Resolve scratchpad merge conflict\"\n</code></pre>","path":["Recipes","Syncing Scratchpad Notes Across Machines"],"tags":[]},{"location":"recipes/scratchpad-sync/#merge-conflict-walkthrough","level":2,"title":"Merge Conflict Walkthrough","text":"<p>Here's a full scenario showing how conflicts arise and how to resolve them:</p> <p>1. Both machines start in sync (1 entry):</p> <pre><code>Machine A: 1. staging API key: sk-test-abc123\nMachine B: 1. staging API key: sk-test-abc123\n</code></pre> <p>2. Both add entries independently:</p> <pre><code>Machine A adds: \"check DNS after deploy\"\nMachine B adds: \"new endpoint: api.example.com/v2\"\n</code></pre> <p>3. Machine A pushes first. Machine B pulls and gets a conflict:</p> <pre><code>git pull\n# CONFLICT (content): Merge conflict in .context/scratchpad.enc\n</code></pre> <p>4. Machine B runs <code>ctx pad resolve</code>:</p> <pre><code>ctx pad resolve\n# === Ours ===\n#   1. staging API key: sk-test-abc123\n#   2. new endpoint: api.example.com/v2\n#\n# === Theirs ===\n#   1. staging API key: sk-test-abc123\n#   2. check DNS after deploy\n</code></pre> <p>5. Rebuild with entries from both sides and commit:</p> <pre><code># Clear and rebuild (or use the skill to guide you)\nctx pad add \"staging API key: sk-test-abc123\"\nctx pad add \"check DNS after deploy\"\nctx pad add \"new endpoint: api.example.com/v2\"\n\ngit add .context/scratchpad.enc\ngit commit -m \"Merge scratchpad: keep entries from both machines\"\n</code></pre>","path":["Recipes","Syncing Scratchpad Notes Across Machines"],"tags":[]},{"location":"recipes/scratchpad-sync/#conversational-approach","level":3,"title":"Conversational Approach","text":"<p>When working with an AI assistant, you can resolve conflicts naturally:</p> <pre><code>You: \"I have a scratchpad merge conflict. Can you resolve it?\"\n\nAgent: \"Let me check both sides.\"\n       [runs ctx pad resolve]\n       \"Ours has 2 entries, theirs has 2 entries. Entry 1 is the\n       same on both sides. I'll merge the unique entries from each.\n       Done — 3 entries total. Want me to commit the resolution?\"\n</code></pre>","path":["Recipes","Syncing Scratchpad Notes Across Machines"],"tags":[]},{"location":"recipes/scratchpad-sync/#tips","level":2,"title":"Tips","text":"<ul> <li>Back up the key. If you lose it, you lose access to all encrypted   entries. Store a copy in your password manager.</li> <li>One key per project. Each <code>ctx init</code> generates a unique key.   Don't reuse keys across projects.</li> <li>Plaintext fallback for non-sensitive projects. If encryption adds   friction and you have nothing sensitive, set <code>scratchpad_encrypt: false</code>   in <code>.contextrc</code>. Merge conflicts become trivial text merges.</li> <li>Never commit the key. It's gitignored by default. Don't override   this.</li> </ul>","path":["Recipes","Syncing Scratchpad Notes Across Machines"],"tags":[]},{"location":"recipes/scratchpad-sync/#next-up","level":2,"title":"Next Up","text":"<p>Parallel Agent Development with Git Worktrees →: Run multiple agents on independent task tracks using git worktrees.</p>","path":["Recipes","Syncing Scratchpad Notes Across Machines"],"tags":[]},{"location":"recipes/scratchpad-sync/#see-also","level":2,"title":"See Also","text":"<ul> <li>Scratchpad: feature overview, all commands, when   to use scratchpad vs context files</li> <li>Persisting Decisions, Learnings, and Conventions:   for structured knowledge that outlives the scratchpad</li> </ul>","path":["Recipes","Syncing Scratchpad Notes Across Machines"],"tags":[]},{"location":"recipes/scratchpad-with-claude/","level":1,"title":"Using the Scratchpad","text":"","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/scratchpad-with-claude/#problem","level":2,"title":"Problem","text":"<p>During a session you accumulate quick notes, reminders, intermediate values, and sometimes sensitive tokens. They don't fit <code>TASKS.md</code> (not work items) or <code>DECISIONS.md</code> (not decisions). They don't have the structured fields that <code>LEARNINGS.md</code> requires.</p> <p>Without somewhere to put them, they get lost between sessions.</p> <p>How do you capture working memory that persists across sessions without polluting your structured context files?</p>","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/scratchpad-with-claude/#commands-and-skills-used","level":2,"title":"Commands and Skills Used","text":"Tool Type Purpose <code>ctx pad</code> CLI command List all scratchpad entries <code>ctx pad show N</code> CLI command Output raw text of entry N (pipe-friendly) <code>ctx pad add</code> CLI command Add a new entry <code>ctx pad edit</code> CLI command Replace, append to, or prepend to an entry <code>ctx pad add --file</code> CLI command Ingest a file as a blob entry <code>ctx pad show N --out</code> CLI command Extract a blob entry to a file <code>ctx pad rm</code> CLI command Remove an entry <code>ctx pad mv</code> CLI command Reorder entries <code>/ctx-pad</code> Skill Natural language interface to all pad commands","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/scratchpad-with-claude/#the-workflow","level":2,"title":"The Workflow","text":"","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/scratchpad-with-claude/#step-1-add-a-note-naturally","level":3,"title":"Step 1: Add a Note Naturally","text":"<p>You don't need to remember any syntax. Just tell your assistant what to jot down:</p> <pre><code>You: \"jot down: check DNS propagation after deploy\"\n\nAgent: \"Added to scratchpad:\n  1. check DNS propagation after deploy\"\n</code></pre> <p>Behind the scenes, the agent runs <code>ctx pad add \"check DNS propagation after deploy\"</code>.</p>","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/scratchpad-with-claude/#step-2-view-your-scratchpad","level":3,"title":"Step 2: View Your Scratchpad","text":"<pre><code>You: \"show my scratchpad\"\n\nAgent: \"Your scratchpad has 3 entries:\n  1. check DNS propagation after deploy\n  2. staging API endpoint: api.staging.example.com/v2\n  3. retry limit should be 5, not 3\"\n</code></pre>","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/scratchpad-with-claude/#step-3-edit-an-entry","level":3,"title":"Step 3: Edit an Entry","text":"<pre><code>You: \"update entry 2 to include the new endpoint\"\n\nAgent: \"Updated entry 2:\n  was: staging API endpoint: api.staging.example.com/v2\n  now: staging API endpoint: api.prod.example.com/v2\"\n</code></pre> <p>For partial edits, the agent can use <code>--append</code> or <code>--prepend</code>:</p> <pre><code>You: \"append the port number to entry 2\"\n\nAgent: \"Updated entry 2:\n  staging API endpoint: api.prod.example.com/v2 :8443\"\n</code></pre>","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/scratchpad-with-claude/#step-4-compose-entries","level":3,"title":"Step 4: Compose Entries","text":"<p>Use <code>ctx pad show N</code> to pipe entry content into other operations:</p> <pre><code>You: \"append the content of entry 3 to entry 1\"\n\nAgent: [runs ctx pad edit 1 --append \"$(ctx pad show 3)\"]\n       \"Done. Entry 1 is now:\n        check DNS propagation after deploy retry limit should be 5, not 3\"\n</code></pre>","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/scratchpad-with-claude/#step-5-reorder-by-priority","level":3,"title":"Step 5: Reorder by Priority","text":"<pre><code>You: \"move entry 4 to the top\"\n\nAgent: [runs ctx pad mv 4 1]\n       \"Moved entry 4 to position 1. Scratchpad reordered.\"\n</code></pre>","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/scratchpad-with-claude/#step-6-clean-up","level":3,"title":"Step 6: Clean Up","text":"<pre><code>You: \"remove entry 2, it's done\"\n\nAgent: [runs ctx pad rm 2]\n       \"Removed entry 2. 3 entries remaining.\"\n</code></pre>","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/scratchpad-with-claude/#step-7-store-a-file-as-a-blob","level":3,"title":"Step 7: Store a File as a Blob","text":"<p>The scratchpad can hold small files (up to 64 KB) as encrypted blob entries. The file is base64-encoded and stored alongside a label you provide:</p> <pre><code># Ingest a file — the first argument is the label\nctx pad add \"deploy config\" --file ./deploy.yaml\n\n# List shows the label with a [BLOB] marker\nctx pad\n#   1. check DNS propagation after deploy\n#   2. deploy config [BLOB]\n</code></pre>","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/scratchpad-with-claude/#step-8-extract-a-blob","level":3,"title":"Step 8: Extract a Blob","text":"<p>Use <code>show --out</code> to write the decoded file back to disk:</p> <pre><code># Write blob entry to a file\nctx pad show 2 --out ./recovered-deploy.yaml\n\n# Or print to stdout (for piping)\nctx pad show 2 | head -5\n</code></pre> <p>Blob entries are encrypted identically to text entries — they're just base64-encoded before encryption. The <code>--out</code> flag decodes and writes the raw bytes.</p>","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/scratchpad-with-claude/#conversational-approach","level":2,"title":"Conversational Approach","text":"<p>The <code>/ctx-pad</code> skill translates natural language into commands. You describe intent; the agent handles the mechanics.</p> You say What the agent does \"jot down: check DNS after deploy\" <code>ctx pad add \"check DNS after deploy\"</code> \"remember this: retry limit is 5\" <code>ctx pad add \"retry limit is 5\"</code> \"show my scratchpad\" / \"what's on my pad\" <code>ctx pad</code> \"show me entry 3\" / \"what's in entry 3\" <code>ctx pad show 3</code> \"delete the third one\" / \"remove entry 3\" <code>ctx pad rm 3</code> \"change entry 2 to ...\" / \"replace entry 2 with ...\" <code>ctx pad edit 2 \"new text\"</code> \"append '-- important' to entry 3\" / \"add to entry 3: ...\" <code>ctx pad edit 3 --append \" -- important\"</code> \"prepend 'URGENT:' to entry 1\" <code>ctx pad edit 1 --prepend \"URGENT: \"</code> \"add the port to entry 2\" <code>ctx pad edit 2 --append \":8443\"</code> \"prioritize entry 4\" / \"move entry 4 to the top\" <code>ctx pad mv 4 1</code> \"move entry 1 to the bottom\" / \"deprioritize entry 1\" <code>ctx pad mv 1 N</code> \"anything on my scratchpad?\" <code>ctx pad</code> <p>The skill recognizes variations: \"scratchpad\", \"pad\", \"notes\", \"sticky notes\", \"jot down\", \"remember this\", \"note to self\". You don't need to use exact trigger phrases.</p> <p>The key insight is ambiguity around \"add\": \"add a note\" creates a new entry, while \"add to entry 3\" appends to an existing one. The skill distinguishes these from context.</p>","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/scratchpad-with-claude/#when-to-use-scratchpad-vs-context-files","level":2,"title":"When to Use Scratchpad vs Context Files","text":"Situation Use Temporary reminders (\"check X after deploy\") Scratchpad Working values during debugging (ports, endpoints, counts) Scratchpad Sensitive tokens or API keys (short-term storage) Scratchpad Quick notes that don't fit anywhere else Scratchpad Work items with completion tracking TASKS.md Trade-offs between alternatives with rationale DECISIONS.md Reusable lessons with context/lesson/application LEARNINGS.md Codified patterns and standards CONVENTIONS.md <p>Decision guide:</p> <ul> <li>If it has structured fields (context, rationale, lesson, application),   it belongs in a context file.</li> <li>If it's a work item you'll mark done, it belongs in <code>TASKS.md</code>.</li> <li>If it's a quick note, reminder, or working value — especially if it's   sensitive or ephemeral — it belongs on the scratchpad.</li> </ul> <p>Scratchpad Is Not a Junk Drawer</p> <p>The scratchpad is for working memory, not long-term storage. If a note is still relevant after several sessions, promote it: a persistent reminder becomes a task, a recurring value becomes a convention, a hard-won insight becomes a learning.</p>","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/scratchpad-with-claude/#tips","level":2,"title":"Tips","text":"<ul> <li>Entries persist across sessions. The scratchpad is committed   (encrypted) to git, so entries survive session boundaries. Pick up   where you left off.</li> <li>Entries are numbered and reorderable. Use <code>ctx pad mv</code> to put   high-priority items at the top.</li> <li><code>ctx pad show N</code> enables unix piping. Output raw entry text   with no numbering prefix. Compose with <code>--append</code>, <code>--prepend</code>, or   other shell tools.</li> <li>Never mention the key file contents to the AI. The agent knows   how to use <code>ctx pad</code> commands but should never read or print   <code>.context/.scratchpad.key</code> directly.</li> <li>Encryption is transparent. You interact with plaintext; the   encryption/decryption happens automatically on every read/write.</li> </ul>","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/scratchpad-with-claude/#next-up","level":2,"title":"Next Up","text":"<p>Syncing Scratchpad Notes Across Machines →: Distribute encryption keys and scratchpad data across environments.</p>","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/scratchpad-with-claude/#see-also","level":2,"title":"See Also","text":"<ul> <li>Scratchpad: feature overview, all 9 commands,   encryption details, plaintext override</li> <li>Persisting Decisions, Learnings, and Conventions:   for structured knowledge that outlives the scratchpad</li> <li>The Complete Session: full session lifecycle   showing how the scratchpad fits into the broader workflow</li> </ul>","path":["Recipes","Using the Scratchpad"],"tags":[]},{"location":"recipes/session-archaeology/","level":1,"title":"Browsing and Enriching Past Sessions","text":"","path":["Recipes","Browsing and Enriching Past Sessions"],"tags":[]},{"location":"recipes/session-archaeology/#the-problem","level":2,"title":"The Problem","text":"<p>After weeks of AI-assisted development you have dozens of sessions scattered across JSONL files in <code>~/.claude/projects/</code>. Finding the session where you debugged the Redis connection pool, or remembering what you decided about the caching strategy three Tuesdays ago, often means grepping raw JSON.</p> <p>There is no table of contents, no search, and no summaries.</p> <p>This recipe shows how to turn that raw session history into a browsable, searchable, and enriched journal site you can navigate in your browser.</p> <p>TL;DR</p> <pre><code># Terminal: export and generate\nctx recall export --all\nctx journal site --serve\n</code></pre> <pre><code># AI assistant: normalize and enrich\n/ctx-journal-normalize\n/ctx-journal-enrich-all\n</code></pre> <pre><code># Terminal: rebuild with enrichments\nctx journal site --serve\n</code></pre> <p>Read on for what each stage does and why.</p>","path":["Recipes","Browsing and Enriching Past Sessions"],"tags":[]},{"location":"recipes/session-archaeology/#commands-and-skills-used","level":2,"title":"Commands and Skills Used","text":"Tool Type Purpose <code>ctx recall list</code> Command List parsed sessions with metadata <code>ctx recall show</code> Command Inspect a specific session in detail <code>ctx recall export</code> Command Export sessions to editable journal Markdown <code>ctx journal site</code> Command Generate a static site from journal entries <code>ctx journal obsidian</code> Command Generate an Obsidian vault from journal entries <code>ctx serve</code> Command Serve the journal site locally <code>/ctx-recall</code> Skill Browse sessions inside your AI assistant <code>/ctx-journal-normalize</code> Skill Fix rendering issues in exported Markdown <code>/ctx-journal-enrich</code> Skill Add frontmatter metadata to a single entry <code>/ctx-journal-enrich-all</code> Skill Batch-enrich all unenriched entries","path":["Recipes","Browsing and Enriching Past Sessions"],"tags":[]},{"location":"recipes/session-archaeology/#the-workflow","level":2,"title":"The Workflow","text":"<p>The session journal follows a four-stage pipeline.</p> <p>Each stage is idempotent and safe to re-run. Each stage skips entries that have already been processed.</p> <pre><code>export -&gt; normalize -&gt; enrich -&gt; rebuild\n</code></pre> Stage Tool What it does Skips if Where Export <code>ctx recall export --all</code> Converts session JSONL to Markdown <code>--skip-existing</code> flag CLI or agent Normalize <code>/ctx-journal-normalize</code> Fixes nested fences and metadata formatting <code>&lt;!-- normalized --&gt;</code> marker Agent only Enrich <code>/ctx-journal-enrich-all</code> Adds frontmatter, summaries, topic tags Frontmatter already present Agent only Rebuild <code>ctx journal site --build</code> Generates browsable static HTML N/A CLI only Obsidian <code>ctx journal obsidian</code> Generates Obsidian vault with wikilinks N/A CLI only <p>Where to run Each Stage</p> <p>Export (Steps 1 to 3) works equally well from the terminal or inside your AI assistant via <code>/ctx-recall</code>. The CLI is fine here: the agent adds no special intelligence, it just runs the same command.</p> <p>Normalize and enrich (Steps 4 to 5) require the agent: they need it to read, analyze, and edit Markdown.</p> <p>Rebuild and serve (Step 6) is a terminal operation that starts a long-running server.</p>","path":["Recipes","Browsing and Enriching Past Sessions"],"tags":[]},{"location":"recipes/session-archaeology/#step-1-list-your-sessions","level":3,"title":"Step 1: List Your Sessions","text":"<p>Start by seeing what sessions exist for the current project:</p> <pre><code>ctx recall list\n</code></pre> <p>Sample output:</p> <pre><code>Sessions (newest first)\n=======================\n\n  Slug                           Project   Date         Duration  Turns  Tokens\n  gleaming-wobbling-sutherland   ctx       2026-02-07   1h 23m    47     82,341\n  twinkly-stirring-kettle        ctx       2026-02-06   0h 45m    22     38,102\n  bright-dancing-hopper          ctx       2026-02-05   2h 10m    63     124,500\n  quiet-flowing-dijkstra         ctx       2026-02-04   0h 18m    11     15,230\n  ...\n</code></pre> <p>Slugs Look Cryptic?</p> <p>These auto-generated slugs (<code>gleaming-wobbling-sutherland</code>) are hard to recognize later.</p> <p>Use <code>/ctx-journal-enrich</code> to add human-readable titles, topic tags, and summaries to exported journal entries, making them easier to find.</p> <p>Filter by project or tool if you work across multiple codebases:</p> <pre><code>ctx recall list --project ctx --limit 10\nctx recall list --tool claude-code\nctx recall list --all-projects\n</code></pre>","path":["Recipes","Browsing and Enriching Past Sessions"],"tags":[]},{"location":"recipes/session-archaeology/#step-2-inspect-a-specific-session","level":3,"title":"Step 2: Inspect a Specific Session","text":"<p>Before exporting everything, inspect a single session to see its metadata and conversation summary:</p> <pre><code>ctx recall show --latest\n</code></pre> <p>Or look up a specific session by its slug, partial ID, or UUID:</p> <pre><code>ctx recall show gleaming-wobbling-sutherland\nctx recall show twinkly\nctx recall show abc123\n</code></pre> <p>Add <code>--full</code> to see the complete message content instead of the summary view:</p> <pre><code>ctx recall show --latest --full\n</code></pre> <p>This is useful for checking what happened before deciding whether to export and enrich it.</p>","path":["Recipes","Browsing and Enriching Past Sessions"],"tags":[]},{"location":"recipes/session-archaeology/#step-3-export-sessions-to-the-journal","level":3,"title":"Step 3: Export Sessions to the Journal","text":"<p>Export converts raw session data into editable Markdown files in <code>.context/journal/</code>:</p> <pre><code># Export all sessions from the current project\nctx recall export --all\n\n# Export a single session\nctx recall export gleaming-wobbling-sutherland\n\n# Include sessions from all projects\nctx recall export --all --all-projects\n</code></pre> <p>Each exported file contains session metadata (date, time, duration, model, project, git branch), a tool usage summary, and the full conversation transcript.</p> <p>Re-exporting is safe. By default, re-running <code>ctx recall export --all</code> regenerates conversation content while preserving any YAML frontmatter you or the enrichment skill have added.</p> <p>You can also use <code>--skip-existing</code> to leave exported files completely untouched.</p> <p>--force Overwrites Journal Files</p> <p>If you want to overwrite existing files, use <code>--force</code>.</p> <p>This triggers a full overwrite and frontmatter will be lost.</p> <p>Back up your journal before using this flag.</p>","path":["Recipes","Browsing and Enriching Past Sessions"],"tags":[]},{"location":"recipes/session-archaeology/#step-4-normalize-rendering","level":3,"title":"Step 4: Normalize Rendering","text":"<p>Raw exported sessions often have rendering problems: nested code fences that break Markdown parsers, malformed metadata tables, or broken list formatting.</p> <p>The <code>/ctx-journal-normalize</code> skill fixes these issues in the source files before site generation.</p> <p>Inside your AI assistant:</p> <pre><code>/ctx-journal-normalize\n</code></pre> <p>The skill backs up <code>.context/journal/</code> before modifying anything and marks each processed file with a <code>&lt;!-- normalized: YYYY-MM-DD --&gt;</code> comment so subsequent runs skip already-normalized entries.</p> <p>Normalize Before Enrich</p> <p>Run normalize before enrich. </p> <p>The enrichment skill reads conversation content to extract metadata, and clean Markdown produces better results.</p>","path":["Recipes","Browsing and Enriching Past Sessions"],"tags":[]},{"location":"recipes/session-archaeology/#step-5-enrich-with-metadata","level":3,"title":"Step 5: Enrich with Metadata","text":"<p>Raw exports have timestamps and transcripts but lack the semantic metadata that makes sessions searchable: topics, technology tags, outcome status, and summaries. The <code>/ctx-journal-enrich*</code> skills add this structured frontmatter.</p> <p>Batch enrichment (recommended):</p> <pre><code>/ctx-journal-enrich-all\n</code></pre> <p>The skill finds all unenriched entries, filters out noise (suggestion sessions, very short sessions, multipart continuations), and processes each one by extracting titles, topics, technologies, and  summaries from the conversation.</p> <p>It shows you a grouped summary before applying changes so you can scan quickly rather than reviewing one by one.</p> <p>For large backlogs (20+ entries), the skill can spawn subagents to process entries in parallel.</p> <p>Single-entry enrichment:</p> <pre><code>/ctx-journal-enrich twinkly\n/ctx-journal-enrich 2026-02-06\n</code></pre> <p>Each enriched entry gets YAML frontmatter like this:</p> <pre><code>---\ntitle: \"Implement Redis caching middleware\"\ndate: 2026-02-06\ntype: feature\noutcome: completed\ntopics:\n  - caching\n  - api-performance\ntechnologies:\n  - go\n  - redis\nlibraries:\n  - go-redis/redis\nkey_files:\n  - internal/cache/redis.go\n  - internal/api/middleware/cache.go\n---\n</code></pre> <p>The skill also generates a summary and can extract decisions,  learnings, and tasks mentioned during the session.</p>","path":["Recipes","Browsing and Enriching Past Sessions"],"tags":[]},{"location":"recipes/session-archaeology/#step-6-generate-and-serve-the-site","level":3,"title":"Step 6: Generate and Serve the Site","text":"<p>With exported, normalized, and enriched journal files,  generate the static site:</p> <pre><code># Generate site structure only\nctx journal site\n\n# Generate and build static HTML\nctx journal site --build\n\n# Generate, build, and serve locally\nctx journal site --serve\n</code></pre> <p>Then open <code>http://localhost:8000</code> to browse.</p> <p>The site includes a date-sorted index, individual session pages with full conversations, search (press <code>/</code>), dark mode, and enriched titles in the navigation when frontmatter exists.</p> <p>You can also serve an existing site without regenerating using <code>ctx serve</code>.</p> <p>The site generator requires <code>zensical</code> (<code>pipx install zensical</code>).</p>","path":["Recipes","Browsing and Enriching Past Sessions"],"tags":[]},{"location":"recipes/session-archaeology/#where-the-agent-adds-value","level":2,"title":"Where the Agent Adds Value","text":"<p>Export, list, and show are mechanical. The agent runs the same CLI commands you would, so you can stay in your terminal for those.</p> <p>The agent earns its keep in normalize and enrich. </p> <p>These require reading conversation content, understanding what happened,  and producing structured metadata. That is agent work, not CLI work.</p> <p>You can also ask your agent to browse sessions conversationally instead of remembering flags:</p> <pre><code>What did we work on last week?\nShow me the session about Redis.\nExport everything to the journal.\n</code></pre> <p>This is convenient but not required: <code>ctx recall list</code> gives you the same inventory.</p> <p>Where the agent genuinely helps is chaining the pipeline:</p> <pre><code>You:   What happened last Tuesday?\nAgent: Last Tuesday you worked on two sessions:\n       - bright-dancing-hopper (2h 10m): refactored the middleware\n         pipeline and added Redis caching\n       - quiet-flowing-dijkstra (18m): quick fix for a nil pointer\n         in the config loader\n       Want me to export and enrich them?\nYou:   Yes, do it.\nAgent: Exports both, normalizes, enriches, then proposes frontmatter.\n</code></pre> <p>The value is staying in one context while the agent runs export -&gt; normalize -&gt; enrich without you manually switching tools.</p>","path":["Recipes","Browsing and Enriching Past Sessions"],"tags":[]},{"location":"recipes/session-archaeology/#putting-it-all-together","level":2,"title":"Putting It All Together","text":"<p>A typical pipeline from raw sessions to a browsable site:</p> <pre><code># Terminal: export and generate\nctx recall export --all\nctx journal site --serve\n</code></pre> <pre><code># AI assistant: normalize and enrich\n/ctx-journal-normalize\n/ctx-journal-enrich-all\n</code></pre> <pre><code># Terminal: rebuild with enrichments\nctx journal site --serve\n</code></pre> <p>If your project includes <code>Makefile.ctx</code> (deployed by <code>ctx init</code>), use <code>make journal</code> to combine export and rebuild stages. Then normalize and enrich inside Claude Code, then <code>make journal</code> again to pick up enrichments.</p>","path":["Recipes","Browsing and Enriching Past Sessions"],"tags":[]},{"location":"recipes/session-archaeology/#tips","level":2,"title":"Tips","text":"<ul> <li>Start with <code>/ctx-recall</code> inside your AI assistant. If you want to quickly check what happened in a recent session without leaving your editor, <code>/ctx-recall</code> lets you browse interactively without exporting.</li> <li>Large sessions may be split automatically. Sessions with 200+ messages can be split into multiple parts (<code>session-abc123.md</code>, <code>session-abc123-p2.md</code>, <code>session-abc123-p3.md</code>) with navigation links between them. The site generator can handle this.</li> <li>Suggestion sessions can be separated. Claude Code can generate short suggestion sessions for autocomplete. These may appear under a separate section in the site index, so they do not clutter your main session list.</li> <li>Your agent is a good session browser. You do not need to remember slugs, dates, or flags. Ask \"what did we do yesterday?\" or \"find the session about Redis\"  and it can map the question to recall commands.</li> </ul> <p>Journal files are sensitive</p> <p>Journal files MUST be <code>.gitignore</code>d.</p> <p>Session transcripts can contain sensitive data such as file contents, commands, error messages with stack traces, and potentially API keys.</p> <p>Add <code>.context/journal/</code>, <code>.context/journal-site/</code>, and <code>.context/journal-obsidian/</code> to your <code>.gitignore</code>.</p>","path":["Recipes","Browsing and Enriching Past Sessions"],"tags":[]},{"location":"recipes/session-archaeology/#next-up","level":2,"title":"Next Up","text":"<p>Running an Unattended AI Agent: Set up an AI agent that works through tasks overnight without you at the keyboard.</p>","path":["Recipes","Browsing and Enriching Past Sessions"],"tags":[]},{"location":"recipes/session-archaeology/#see-also","level":2,"title":"See Also","text":"<ul> <li>The Complete Session: where session saving fits in the daily workflow</li> <li>Turning Activity into Content: generating blog posts from session history</li> <li>Session Journal: full documentation of the journal system</li> <li>CLI Reference: ctx recall: all recall subcommands and flags</li> <li>CLI Reference: ctx journal: site generation options</li> <li>CLI Reference: ctx serve: local serving options</li> <li>Context Files: the <code>.context/</code> directory structure</li> </ul>","path":["Recipes","Browsing and Enriching Past Sessions"],"tags":[]},{"location":"recipes/session-lifecycle/","level":1,"title":"The Complete Session","text":"","path":["Recipes","The Complete Session"],"tags":[]},{"location":"recipes/session-lifecycle/#the-problem","level":2,"title":"The Problem","text":"<p>\"What does a full ctx session look like start to finish?\"</p> <p>You have <code>ctx</code> installed and your <code>.context/</code> directory initialized, but the individual commands and skills feel disconnected.</p> <p>How do they fit together into a coherent workflow?</p> <p>This recipe walks through a complete session, from opening your editor to persisting context before you close it, so you can see how each piece connects.</p> <p>TL;DR</p> <ol> <li>Load: \"Do you remember?\" or <code>/ctx-remember</code></li> <li>Orient: <code>/ctx-status</code> — check file health and token usage</li> <li>Pick: <code>/ctx-next</code> — choose what to work on</li> <li>Work: implement, test, iterate</li> <li>Commit: <code>/ctx-commit</code> — commit and capture decisions/learnings</li> <li>Reflect: <code>/ctx-reflect</code> — identify what to persist</li> </ol> <p>Read on for the full walkthrough with examples.</p>","path":["Recipes","The Complete Session"],"tags":[]},{"location":"recipes/session-lifecycle/#commands-and-skills-used","level":2,"title":"Commands and Skills Used","text":"Tool Type Purpose <code>ctx status</code> CLI command Quick health check on context files <code>ctx agent</code> CLI command Load token-budgeted context packet <code>ctx recall list</code> CLI command List previous sessions <code>ctx recall show</code> CLI command Inspect a specific session in detail <code>/ctx-remember</code> Skill Recall project context with structured readback <code>/ctx-agent</code> Skill Load full context packet inside the assistant <code>/ctx-status</code> Skill Show context summary with commentary <code>/ctx-next</code> Skill Suggest what to work on with rationale <code>/ctx-commit</code> Skill Commit code and prompt for context capture <code>/ctx-reflect</code> Skill Structured reflection checkpoint <code>/ctx-recall</code> Skill Browse session history inside your AI assistant <code>/ctx-context-monitor</code> Skill Automatic context capacity monitoring","path":["Recipes","The Complete Session"],"tags":[]},{"location":"recipes/session-lifecycle/#the-workflow","level":2,"title":"The Workflow","text":"<p>The session lifecycle has seven steps. You will not always use every step (for example, a quick bugfix might skip reflection, and a research session might skip committing) but the full arc looks like this:</p> <p>Load context &gt; Orient &gt; Pick a Task &gt; Work &gt; Commit &gt; Reflect</p>","path":["Recipes","The Complete Session"],"tags":[]},{"location":"recipes/session-lifecycle/#step-1-load-context","level":3,"title":"Step 1: Load Context","text":"<p>Start every session by loading what you know. The fastest way is a single prompt:</p> <pre><code>Do you remember what we were working on?\n</code></pre> <p>This triggers the <code>/ctx-remember</code> skill. Behind the scenes, the assistant runs <code>ctx agent --budget 4000</code>, reads the files listed in the context packet (<code>TASKS.md</code>, <code>DECISIONS.md</code>, <code>LEARNINGS.md</code>, <code>CONVENTIONS.md</code>), checks <code>ctx recall list --limit 3</code> for recent sessions, and then presents a structured readback:</p> <p>What is a Readback?</p> <p>A readback is a structured summary where the agent plays back what it knows:</p> <ul> <li>last session</li> <li>active tasks</li> <li>recent decisions</li> </ul> <p>This way, you can confirm it loaded the right context.</p> <p>The term \"readback\" comes from aviation, where pilots repeat instructions back to air traffic control to confirm they heard correctly.</p> <p>Same idea in <code>ctx</code>: The agent tells you what it \"thinks\" is going on, and you correct anything that's off before the work begins.</p> <ul> <li>Last session: topic, date, what was accomplished</li> <li>Active work: pending and in-progress tasks</li> <li>Recent context: 1-2 decisions or learnings that matter now</li> <li>Next step: suggestion or question about what to focus on</li> </ul> <p>The readback should feel like a recall, not a file system tour. If you see \"Let me check if there are files...\" instead of a confident summary, the context system is not loaded properly.</p> <p>As an alternative, if you want raw data instead of a readback, run <code>ctx status</code> in your terminal or invoke <code>/ctx-status</code> for a summarized health check showing file counts, token usage, and recent activity.</p>","path":["Recipes","The Complete Session"],"tags":[]},{"location":"recipes/session-lifecycle/#step-2-orient","level":3,"title":"Step 2: Orient","text":"<p>After loading context, verify you understand the current state.</p> <pre><code>/ctx-status\n</code></pre> <p>The status output shows which context files are populated, how many tokens they consume, and which files were recently modified. Look for:</p> <ul> <li>Empty core files: <code>TASKS.md</code> or <code>CONVENTIONS.md</code> with no content means   the context is sparse</li> <li>High token count (over 30k): the context is bloated and might   need <code>ctx compact</code></li> <li>No recent activity: files may be stale and need updating</li> </ul> <p>If the status looks healthy and the readback from Step 1 gave you enough context, skip ahead.</p> <p>If something seems off (stale tasks, missing decisions...), spend a minute reading the relevant file before proceeding.</p>","path":["Recipes","The Complete Session"],"tags":[]},{"location":"recipes/session-lifecycle/#step-3-pick-what-to-work-on","level":3,"title":"Step 3: Pick What to Work On","text":"<p>With context loaded, choose a task. You can pick one yourself, or ask the assistant to recommend:</p> <pre><code>/ctx-next\n</code></pre> <p>The skill reads <code>TASKS.md</code>, checks recent sessions to avoid re-suggesting completed work, and presents 1-3 ranked recommendations with rationale.</p> <p>It prioritizes in-progress tasks over new starts (finishing is better than starting), respects explicit priority tags, and favors momentum: continuing a thread from a recent session is cheaper than context-switching.</p> <p>If you already know what you want to work on, state it directly:</p> <pre><code>Let's work on the session enrichment feature.\n</code></pre>","path":["Recipes","The Complete Session"],"tags":[]},{"location":"recipes/session-lifecycle/#step-4-do-the-work","level":3,"title":"Step 4: Do the Work","text":"<p>This is the main body of the session: write code, fix bugs, refactor, research—whatever the task requires.</p> <p>During this phase, a few <code>ctx</code>-specific patterns help:</p> <p>Check decisions before choosing: when you face a design choice, check if a prior decision covers it.</p> <pre><code>Is this consistent with our decisions?\n</code></pre> <p>Constrain scope: keep the assistant focused on the task at hand.</p> <pre><code>Only change files in internal/cli/session/. Nothing else.\n</code></pre> <p>Use <code>/ctx-implement</code> for multistep plans: if the task has multiple steps, this skill executes them one at a time with build/test verification between each step.</p> <p>Context monitoring runs automatically: the <code>/ctx-context-monitor</code> skill is triggered by a hook at adaptive intervals. Early in a session it stays silent. After 16+ prompts it starts monitoring, and past 30 prompts it checks frequently. If context capacity is running high, it will suggest saving unsaved work. You typically do not need to invoke this skill manually.</p>","path":["Recipes","The Complete Session"],"tags":[]},{"location":"recipes/session-lifecycle/#step-5-commit-with-context","level":3,"title":"Step 5: Commit with Context","text":"<p>When the work is ready, use the context-aware commit instead of raw <code>git commit</code>:</p> <pre><code>/ctx-commit\n</code></pre> <p>As an alternative, you can ask the assistant \"can we commit this?\" and it will pick up the <code>/ctx-commit</code> skill for you.</p> <p>The skill runs a pre-commit build check (for Go projects, <code>go build</code>), reviews the staged changes, drafts a commit message focused on \"why\" rather than \"what\", and then commits.</p> <p>After the commit succeeds, it prompts you:</p> <pre><code>**Any context to capture?**\n\n- **Decision**: Did you make a design choice or trade-off?\n- **Learning**: Did you hit a gotcha or discover something?\n- **Neither**: No context to capture; we are done.\n</code></pre> <p>If you made a decision, the skill records it with <code>ctx add decision</code>. If you learned something, it records it with <code>ctx add learning</code> including context, lesson, and application fields. This is the bridge between committing code and remembering why the code looks the way it does.</p> <p>If source code changed in areas that affect documentation, the skill also offers to check for doc drift.</p> <p>The Agent May Recommend Committing</p> <p>You do not always need to invoke <code>/ctx-commit</code> explicitly.</p> <p>After a commit, the agent may proactively offer to capture context:</p> <p>\"We just made a trade-off there. Want me to record it as a decision?\"</p> <p>This is normal: The Agent Playbook encourages persisting at milestones, and a commit is a natural milestone.</p>","path":["Recipes","The Complete Session"],"tags":[]},{"location":"recipes/session-lifecycle/#step-6-reflect","level":3,"title":"Step 6: Reflect","text":"<p>At natural breakpoints (after finishing a feature, resolving a complex bug, or before switching tasks) pause to reflect:</p> <pre><code>/ctx-reflect\n</code></pre> <p>The skill works through a checklist: learnings discovered, decisions made, tasks completed or created, and whether there are items worth persisting. It then presents a summary with specific items to persist, each with the exact command to run:</p> <p>I would suggest persisting:</p> <ul> <li>Learning: <code>$PPID</code> in PreToolUse hooks resolves to the Claude Code PID   <code>ctx add learning --context \"...\" --lesson \"...\" --application \"...\"</code></li> <li>Task: mark \"Add cooldown to ctx agent\" as done</li> <li>Decision: tombstone-based cooldown with 10m default   <code>ctx add decision \"...\"</code></li> </ul> <p>Want me to persist any of these?</p> <p>The skill asks before persisting anything. You choose what to keep.</p> <p>Not every commit needs reflection. A typo fix does not. But when you have been debugging for an hour and finally understand the root cause, that is worth a reflection checkpoint.</p> <p>Agents Reflect at Milestones</p> <p>Agents often reflect without explicit invocation.</p> <p>After completing a significant piece of work, the agent may naturally surface items worth persisting:</p> <p>\"We discovered that <code>$PPID</code> resolves differently inside hooks. Should I save that as a learning?\"</p> <p>This is the agent following the Work-Reflect-Persist cycle from the Agent Playbook.</p> <p>You do not need to say <code>/ctx-reflect</code> for this to happen; the agent treats milestones as reflection triggers on its own.</p>","path":["Recipes","The Complete Session"],"tags":[]},{"location":"recipes/session-lifecycle/#step-7-persist-before-ending","level":3,"title":"Step 7: Persist Before Ending","text":"<p>Before ending the session, make sure any outstanding learnings and decisions are captured:</p> <pre><code>/ctx-reflect\n</code></pre> <p>The agent will review what happened during the session and offer to persist any outstanding learnings, decisions, or task updates.</p> <p>Session transcripts are automatically captured by Claude Code and can be browsed later with <code>ctx recall list</code> and <code>ctx recall show</code>.</p> <p>Be Conversational</p> <p>Phrases like \"let's wrap up\", \"save our progress\", or \"I'm done for today\" will trigger a reflection and persist flow.</p> <p>The agent will reflect on what happened and persist outstanding learnings and decisions in one pass.</p>","path":["Recipes","The Complete Session"],"tags":[]},{"location":"recipes/session-lifecycle/#conversational-session-flow","level":2,"title":"Conversational Session Flow","text":"<p>The steps above describe the mechanics. In practice, a session with a <code>ctx</code>-aware agent feels more like a conversation than a command sequence.</p> <p>The agent knows the lifecycle and moves through it naturally, often without explicit invocation. Here is a realistic example:</p> <p>You: Do you remember what we were working on?</p> <p>Agent (loads context silently, presents structured readback):</p> <p>Last session (Feb 7, caching-layer): we implemented the in-memory cache with TTL expiration and wrote tests for the eviction policy. </p> <p>You have 3 pending tasks; the biggest one is adding Redis as a backend.</p> <p>Recent decision: we chose LRU over LFU because the access pattern is mostly recency-based.</p> <p>Want to continue with the Redis backend, or tackle something else?</p> <p>You: Let's work on the Redis caching backend.</p> <p>Agent (picks up the task, begins implementation):</p> <p>Got it. I see the task in TASKS.md: \"Add Redis backend for cache layer.\"</p> <p>I will start with the connection pool setup. Only touching <code>internal/cache/redis/</code> for now.</p> <p>(The agent works... writes code, runs tests, iterates.)</p> <p>Agent (after implementing the connection pool and choosing a retry strategy):</p> <p>The connection pool is working. I went with exponential backoff with jitter for retries instead of fixed intervals; it handles thundering herd better under reconnection storms. That is a design choice worth recording. </p> <p>Want me to save it as a decision?</p> <p>You: Yes, go ahead.</p> <p>Agent:</p> <p>Done. Added to DECISIONS.md: \"Exponential backoff with jitter for Redis reconnection, to avoid thundering herd on pool recovery.\"</p> <p>(More work happens... the agent implements the cache read/write paths.)</p> <p>You: What else did we learn during this session?</p> <p>Agent:</p> <p>A few things worth capturing:</p> <ul> <li>Learning: Redis <code>SET</code> with <code>NX</code> and <code>PX</code> flags handles atomic   set-if-not-exists with TTL in a single call. No need for a separate   <code>EXPIRE</code> command. We initially did it in two calls and hit a race condition.</li> <li>Learning: The <code>go-redis</code> library's <code>PoolSize</code> default is 10 per CPU.   For our workload, explicit sizing at 20 was more predictable.</li> <li>Task update: The connection pool subtask is done; the read/write path   is implemented but needs integration tests.</li> </ul> <p>Want me to persist these?</p> <p>You: Yes. And let's wrap up.</p> <p>Agent (reflects and persists... all in one flow):</p> <p>Persisted:</p> <ul> <li>2 learnings added to LEARNINGS.md</li> <li>Marked \"connection pool setup\" done in TASKS.md</li> <li>Added \"write integration tests for Redis cache\" as a new task</li> </ul> <p>Context is up to date. You are good to close.</p> <p>Notice What Happened</p> <p>In the above workflow, the user never typed <code>/ctx-reflect</code> or <code>ctx add learning</code>.</p> <p>The agent moved through Load, Orient, Pick, Work, Commit, and Reflect driven by natural conversation.</p> <p>\"Let's wrap up\" was enough to trigger the full reflect-and-persist flow.</p> <p>The agent surfaced persist-worthy items at milestones: after a design choice, after discovering a gotcha—without waiting to be asked.</p> <p>This is the intended experience. </p> <p>The commands and skills still exist for when you want precise control, but  the agent is a proactive partner in the lifecycle, not a passive executor  of slash commands.</p>","path":["Recipes","The Complete Session"],"tags":[]},{"location":"recipes/session-lifecycle/#putting-it-all-together","level":2,"title":"Putting It All Together","text":"<p>Quick-reference checklist for a complete session:</p> <ul> <li> Load: \"Do you remember?\" or <code>/ctx-remember</code></li> <li> Orient: <code>/ctx-status</code>: check file health and token usage</li> <li> Pick: <code>/ctx-next</code>: choose what to work on</li> <li> Work: implement, test, iterate (scope with \"only change X\")</li> <li> Commit: <code>/ctx-commit</code>: commit and capture decisions/learnings</li> <li> Reflect: <code>/ctx-reflect</code>: identify what to persist (at milestones)</li> </ul> <p>Conversational equivalents: you can drive the same lifecycle with plain language:</p> Step Slash command Natural language Load <code>/ctx-remember</code> \"Do you remember?\" / \"What were we working on?\" Orient <code>/ctx-status</code> \"How's our context looking?\" Pick <code>/ctx-next</code> \"What should we work on?\" / \"Let's do the caching task\" Work -- \"Only change files in internal/cache/\" Commit <code>/ctx-commit</code> \"Commit this\" / \"Ship it\" Reflect <code>/ctx-reflect</code> \"What did we learn?\" / (agent offers at milestones) <p>The agent understands both columns.</p> <p>In practice, most sessions use a mix:</p> <ul> <li>explicit commands when you want precision</li> <li>natural language when you want flow and agentic autonomy</li> </ul> <p>The agent will also initiate steps on its own (particularly \"Reflect\") when it recognizes a milestone.</p> <p>Short sessions (quick bugfix) might only use: Load, Work, Commit.</p> <p>Long sessions should Reflect after each major milestone and persist learnings and decisions before ending.</p>","path":["Recipes","The Complete Session"],"tags":[]},{"location":"recipes/session-lifecycle/#tips","level":2,"title":"Tips","text":"<p>Persist early if context is running low. The <code>/ctx-context-monitor</code> skill will warn you when capacity is high, but do not wait for the warning. If you have been working for a while and have unpersisted learnings, persist proactively.</p> <p>Browse previous sessions by topic. If you need context from a prior session, <code>ctx recall show auth</code> will match by keyword. You do not need to remember the exact date or slug.</p> <p>Reflection is optional but valuable. You can skip <code>/ctx-reflect</code> for small changes, but always persist learnings and decisions before ending a session where you did meaningful work. These are what the next session loads.</p> <p>Let the hook handle context loading. The <code>PreToolUse</code> hook runs <code>ctx agent</code> automatically with a cooldown, so context loads on first tool use without you asking. The <code>/ctx-remember</code> prompt at session start is for your benefit (to get a readback you can verify), not because the assistant needs it.</p> <p>The agent is a proactive partner, not a passive tool. A <code>ctx</code>-aware agent follows the Agent Playbook: it watches for milestones (completed tasks, design decisions, discovered gotchas) and offers to persist them without being asked. If you finish a tricky debugging session, it may say \"That root cause is worth saving as a learning. Want me to record it?\" before you think to ask. This is by design.</p>","path":["Recipes","The Complete Session"],"tags":[]},{"location":"recipes/session-lifecycle/#next-up","level":2,"title":"Next Up","text":"<p>Tracking Work Across Sessions: Add, prioritize, complete, and archive tasks across sessions.</p>","path":["Recipes","The Complete Session"],"tags":[]},{"location":"recipes/session-lifecycle/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference: full documentation for all <code>ctx</code> commands</li> <li>Prompting Guide: effective prompts for ctx-enabled projects</li> <li>Tracking Work Across Sessions: deep dive on task management</li> <li>Persisting Decisions, Learnings, and Conventions:   deep dive on knowledge capture</li> <li>Detecting and Fixing Drift: keeping context files accurate</li> </ul>","path":["Recipes","The Complete Session"],"tags":[]},{"location":"recipes/task-management/","level":1,"title":"Tracking Work Across Sessions","text":"","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#problem","level":2,"title":"Problem","text":"<p>You have work that spans multiple sessions. Tasks get added during one session, partially finished in another, and completed days later.</p> <p>Without a system, follow-up items fall through the cracks, priorities drift, and you lose track of what was done versus what still needs doing. <code>TASKS.md</code> grows cluttered with completed checkboxes that obscure the remaining work.</p> <p>How do you manage work items that span multiple sessions without losing context?</p> <p>TL;DR</p> <p><pre><code>ctx add task \"Fix race condition\" --priority high   # add\nctx add task \"Write tests\" --section \"Phase 2\"      # add to phase\nctx complete \"race condition\"                        # mark done\nctx tasks snapshot \"before-refactor\"                 # backup\nctx tasks archive                                    # clean up\n</code></pre> <pre><code>/ctx-next                                            # pick what's next\n</code></pre></p> <p>Read on for the full workflow and conversational patterns.</p>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#commands-and-skills-used","level":2,"title":"Commands and Skills Used","text":"Tool Type Purpose <code>ctx add task</code> Command Add a new task to TASKS.md <code>ctx complete</code> Command Mark a task as done by number or text <code>ctx tasks snapshot</code> Command Create a point-in-time backup of TASKS.md <code>ctx tasks archive</code> Command Move completed tasks to archive file <code>/ctx-add-task</code> Skill AI-assisted task creation with validation <code>/ctx-archive</code> Skill AI-guided archival with safety checks <code>/ctx-next</code> Skill Pick what to work on based on priorities","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#the-workflow","level":2,"title":"The Workflow","text":"","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#step-1-add-tasks-with-priorities","level":3,"title":"Step 1: Add Tasks with Priorities","text":"<p>Every piece of follow-up work gets a task. Use <code>ctx add task</code> from the terminal or <code>/ctx-add-task</code> from your AI assistant. Tasks should start with a verb and be specific enough that someone unfamiliar with the session could act on them.</p> <pre><code># High-priority bug found during code review\nctx add task \"Fix race condition in session cooldown\" --priority high\n\n# Medium-priority feature work\nctx add task \"Add --format json flag to ctx status for CI integration\" --priority medium\n\n# Low-priority cleanup\nctx add task \"Remove deprecated --raw flag from ctx load\" --priority low\n</code></pre> <p>The <code>/ctx-add-task</code> skill validates your task before recording it. It checks that the description is actionable, not a duplicate, and specific enough for someone else to pick up.</p> <p>If you say \"fix the bug,\" it will ask you to clarify which bug and where.</p> <p>Tasks Are Often Created Proactively</p> <p>In practice, many tasks are created proactively by the agent rather than by explicit CLI commands.</p> <p>After completing a feature, the agent will often identify follow-up work: tests, docs, edge cases, error handling, and offer to add them as tasks.</p> <p>You do not need to dictate <code>ctx add task</code> commands; the agent picks up on work context and suggests tasks naturally.</p>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#step-2-organize-with-phase-sections","level":3,"title":"Step 2: Organize with Phase Sections","text":"<p>Tasks live in phase sections inside <code>TASKS.md</code>.</p> <p>Phases provide logical groupings that preserve order and enable replay.</p> <p>A task does not move between sections. It stays in its phase permanently, and status is tracked via checkboxes and inline tags.</p> <pre><code>## Phase 1: Core CLI\n\n- [x] Implement ctx add command `#done:2026-02-01-143022`\n- [x] Implement ctx complete command `#done:2026-02-03-091544`\n- [ ] Add --section flag to ctx add task `#priority:medium`\n\n## Phase 2: AI Integration\n\n- [ ] Implement ctx agent cooldown `#priority:high` `#in-progress`\n- [ ] Add ctx watch XML parsing `#priority:medium`\n  - Blocked by: Need to finalize agent output format\n\n## Backlog\n\n- [ ] Performance optimization for large TASKS.md files `#priority:low`\n- [ ] Add metrics dashboard to ctx status `#priority:deferred`\n</code></pre> <p>Use <code>--section</code> when adding a task to a specific phase:</p> <pre><code>ctx add task \"Add ctx watch XML parsing\" --priority medium --section \\\n    \"Phase 2: AI Integration\"\n</code></pre> <p>Without <code>--section</code>, the task is inserted before the first unchecked task in TASKS.md.</p>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#step-3-pick-what-to-work-on","level":3,"title":"Step 3: Pick What to Work On","text":"<p>At the start of a session, or after finishing a task, use <code>/ctx-next</code> to get prioritized recommendations. </p> <p>The skill reads <code>TASKS.md</code>, checks recent sessions, and ranks candidates using  explicit priority, blocking status, in-progress state, momentum from  recent work, and phase order.</p> <p>You can also ask naturally: \"what should we work on?\" or \"what's the highest priority right now?\"</p> <pre><code>/ctx-next\n</code></pre> <p>The output looks like this:</p> <pre><code>**1. Implement ctx agent cooldown** `#priority:high`\n\n    Still in-progress from yesterday's session. The tombstone file approach is\n    half-built. Finishing is cheaper than context-switching.\n\n**2. Add --section flag to ctx add task** `#priority:medium`\n\n    Last Phase 1 item. Quick win that unblocks organized task entry.\n\n---\n\n*Based on 8 pending tasks across 3 phases.\n\nLast session: agent-cooldown (2026-02-06).*\n</code></pre> <p>In-progress tasks almost always come first: </p> <p>Finishing existing work takes priority over starting new work.</p>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#step-4-complete-tasks","level":3,"title":"Step 4: Complete Tasks","text":"<p>When a task is done, mark it complete by number or partial text match:</p> <pre><code># By task number (as shown in TASKS.md)\nctx complete 3\n\n# By partial text match\nctx complete \"agent cooldown\"\n</code></pre> <p>The task's checkbox changes from <code>[ ]</code> to <code>[x]</code> and a <code>#done</code> timestamp is added. Tasks are never deleted: they stay in their phase section so history is preserved.</p> <p>Be Conversational</p> <p>You rarely need to run <code>ctx complete</code> yourself during an interactive session.</p> <p>When you say something like \"the rate limiter is done\" or \"we finished that,\" the agent marks the task complete and moves on to suggesting what is next.</p> <p>The CLI commands are most useful for manual housekeeping, scripted workflows, or when you want precision.</p>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#step-5-snapshot-before-risky-changes","level":3,"title":"Step 5: Snapshot Before Risky Changes","text":"<p>Before a major refactor or any change that might break things, snapshot your current task state. This creates a copy of TASKS.md in <code>.context/archive/</code> without modifying the original.</p> <pre><code># Default snapshot\nctx tasks snapshot\n\n# Named snapshot (recommended before big changes)\nctx tasks snapshot \"before-refactor\"\n</code></pre> <p>This creates a file like <code>.context/archive/tasks-before-refactor-2026-02-08-1430.md</code>. If the refactor goes sideways, and you need to confirm what the task state looked like before you started, the snapshot is there.</p> <p>Snapshots are cheap: Take them before any change you might want to undo or review later.</p>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#step-6-archive-when-tasksmd-gets-cluttered","level":3,"title":"Step 6: Archive When <code>TASKS.md</code> Gets Cluttered","text":"<p>After several sessions, <code>TASKS.md</code> accumulates completed tasks that make it hard to see what is still pending.</p> <p>Use <code>ctx tasks archive</code> to move all <code>[x]</code> items to a timestamped archive file.</p> <p>Start with a dry run to preview what will be moved:</p> <pre><code>ctx tasks archive --dry-run\n</code></pre> <p>Then archive:</p> <pre><code>ctx tasks archive\n</code></pre> <p>Completed tasks move to <code>.context/archive/tasks-2026-02-08.md</code>. Phase headers are preserved in the archive for traceability. Pending tasks (<code>[ ]</code>) remain in <code>TASKS.md</code>.</p> <p>The <code>/ctx-archive</code> skill adds two safety checks before archiving: it verifies that completed tasks are genuinely cluttering the view and that nothing was marked <code>[x]</code> prematurely.</p>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#letting-the-agent-drive","level":2,"title":"Letting the Agent Drive","text":"<p>The steps above show the CLI commands for task management.</p> <p>In practice, most task management happens conversationally:</p> <p>An agent that has loaded the context files does not need you to type <code>ctx add task</code>. It tracks work naturally and offers the right operations.</p>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#use-natural-language-instead-of-commands","level":3,"title":"Use Natural Language Instead of Commands","text":"<p>These conversational prompts replace explicit commands during interactive sessions:</p> Instead of typing... Just say... <code>ctx add task \"Write tests for X\"</code> \"We should add tests for this—track that?\" <code>/ctx-next</code> \"What should we work on?\" <code>ctx complete \"rate limiting\"</code> \"The rate limiter is done, what's next?\" <code>ctx tasks archive</code> \"TASKS.md is getting long, can you clean it up?\" <code>ctx add task ... &amp;&amp; ctx add task ...</code> \"Add follow-ups for what we just built.\" <p>The agent translates these into the right <code>ctx</code> operations behind the scenes.</p>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#the-agent-creates-tasks-proactively","level":3,"title":"The Agent Creates Tasks Proactively","text":"<p>After completing a piece of work, the agent does not wait for you to dictate follow-up items. It identifies them from the work context and offers:</p> <p>Agent: \"I've finished implementing the rate limiter middleware. I noticed three follow-up items:</p> <ol> <li>Write integration tests for the rate limiter (the unit tests pass but    there's no end-to-end coverage)</li> <li>Add rate limit headers to API responses (X-RateLimit-Remaining, etc.)</li> <li>Document the rate limit configuration in the ops runbook</li> </ol> <p>Want me to add these as tasks?\"</p> <p>This is how an agent behaves once it has read the Agent Playbook.</p> <p>The playbook's \"Work, Reflect, Persist\" cycle means the agent asks itself after every milestone: Did I just complete a task? Did new work emerge?</p> <p>When the answer is yes, it acts.</p>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#asking-the-agent-what-to-capture","level":3,"title":"Asking the Agent What to Capture","text":"<p>You don't always know what's worth persisting.</p> <p>Instead of reviewing the session yourself and typing specific commands, ask the agent to do the thinking:</p> You say What happens \"What tasks came out of this session?\" Agent reviews the work, identifies follow-ups, and offers to add them \"Are there any tasks, learnings, or decisions worth adding?\" Agent scans the full session for all three types and proposes a batch \"What should we remember from today?\" Agent surfaces everything persist-worthy—not just tasks \"Anything we should track before we move on?\" Agent checks for loose ends specific to the work just completed <p>This is especially powerful after long or exploratory sessions where multiple threads were touched. </p> <p>The agent has the full conversation in context and can spot follow-ups you  might miss:</p> <pre><code>You:   \"Are there any tasks, learnings, or decisions worth adding\n        from this session?\"\n\nAgent: \"Yes—here's what I'd suggest:\n\n  Tasks:\n  - Add retry logic to the webhook delivery (we discussed it when\n    the timeout test failed but never tracked it)\n  - Update the API docs to reflect the new rate limit headers\n\n  Learnings:\n  - net/http's default client has no timeout—we burned 15 minutes\n    on that before adding an explicit 30s timeout\n\n  Decisions:\n  - We chose token-bucket over sliding-window for rate limiting\n    because it handles bursts better and the library is simpler\n\n  Want me to add all of these?\"\n\nYou:   \"All of them.\"\n</code></pre> <p>The agent fills in structured fields from what it observed during the session. You get the same quality entries as if you typed verbose commands, without needing to remember what happened or how to format it.</p>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#the-agent-completes-tasks-and-moves-on","level":3,"title":"The Agent Completes Tasks and Moves On","text":"<p>When you confirm that work is finished, or when the agent can see that it is, it marks the task done and suggests the next step:</p> <pre><code>You: \n\"The cooldown logic is working now.\"\n\nAgent: \n\"Marked 'Implement ctx agent cooldown' as done. Your highest-\npriority remaining task is 'Add --section flag to ctx add task'.\n\nIt's the last item in Phase 1 and a quick win. Want to start on that?\"\n</code></pre> <p>The agent chains completion into next-task selection.</p> <p>One sentence from you triggers two operations.</p>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#end-of-session-capture","level":3,"title":"End-of-Session Capture","text":"<p>At the end of a session, the agent reviews what happened and catches loose ends:</p> <pre><code>You: \n\"I think we're good for today.\"\n\nAgent: \n\"Before we wrap up: during the middleware work you mentioned\nwanting to add metrics for rate limit hits. That never made it into TASKS.md.\n\nWant me to add it as a task so it's there next session?\"\n</code></pre> <p>This is the proactive persistence model at work.</p> <p>The agent monitors the conversation for mentioned-but-not-tracked work and surfaces it before context is lost.</p>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#a-conversational-session-example","level":3,"title":"A Conversational Session Example","text":"<p>Here is what task management looks like in a real session when the agent is driving:</p> <pre><code>You:   What's left to do?\nAgent: You have 5 pending tasks across 2 phases. The highest priority is\n       \"Implement ctx agent cooldown\"—it's marked in-progress from\n       yesterday and half-built. Want to pick that up?\n\nYou:   Yeah, let's finish it.\n       [... 20 minutes of implementation work ...]\n\nYou:   That's working. Tests pass.\nAgent: Nice. I'll mark \"Implement ctx agent cooldown\" as done.\n       I noticed two things from the implementation:\n       1. The tombstone file cleanup should happen on a timer, not just\n          at startup—want me to add that as a task?\n       2. We learned that file locks don't work reliably on NFS. I'll\n          add that to LEARNINGS.md.\n\nYou:   Yes to both. What's next?\nAgent: Added the cleanup task as high priority. Next up is \"Add --section\n       flag to ctx add task\"—last item in Phase 1. It should be\n       straightforward since the flag parsing pattern already exists\n       in the codebase. Ready?\n</code></pre> <p>It's All Conversational</p> <p>Notice what did not happen: The user never typed a <code>ctx</code> command.</p> <p>The agent handled task completion, follow-up creation, learning capture, and next-task selection—all from natural conversation.</p>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#putting-it-together","level":2,"title":"Putting It Together","text":"<pre><code># Add a task\nctx add task \"Implement rate limiting for API endpoints\" --priority high\n\n# Add to a specific phase\nctx add task \"Write integration tests for rate limiter\" --section \"Phase 2\"\n\n# See what to work on\n# (from AI assistant) /ctx-next\n\n# Mark done by text\nctx complete \"rate limiting\"\n\n# Mark done by number\nctx complete 5\n\n# Snapshot before a risky refactor\nctx tasks snapshot \"before-middleware-rewrite\"\n\n# Archive completed tasks when the list gets long\nctx tasks archive --dry-run     # preview first\nctx tasks archive               # then archive\n</code></pre>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#tips","level":2,"title":"Tips","text":"<ul> <li>Start tasks with a verb: \"Add,\" \"Fix,\" \"Implement,\" \"Investigate\":    not just a topic like \"Authentication.\"</li> <li>Include the why in the task description. Future sessions lack the context of   why you added the task. \"Add rate limiting\" is worse than \"Add rate limiting   to prevent abuse on the public API after the load test showed 10x traffic spikes.\"</li> <li>Use <code>#in-progress</code> sparingly. Only one or two tasks should carry this tag at   a time. If everything is in-progress, nothing is.</li> <li>Snapshot before, not after. The point of a snapshot is to capture the    state before a change, not to celebrate what you just finished.</li> <li>Archive regularly. Once completed tasks outnumber pending ones, it is time   to archive. A clean TASKS.md helps both you and your AI assistant focus.</li> <li>Never delete tasks. Mark them <code>[x]</code> (completed) or <code>[-]</code> (skipped with a   reason). Deletion breaks the audit trail.</li> <li>Trust the agent's task instincts. When the agent suggests follow-up items   after completing work, it is drawing on the full context of what just happened.</li> <li>Conversational prompts beat commands in interactive sessions. Saying   \"what should we work on?\" is faster and more natural than running <code>/ctx-next</code>.   Save explicit commands for scripts, CI, and unattended runs.</li> <li>Let the agent chain operations. A single statement like \"that's done, what's   next?\" can trigger completion, follow-up identification, and next-task   selection in one flow.</li> <li>Review proactive task suggestions before moving on. The best follow-ups come   from items spotted in-context right after the work completes.</li> </ul>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#next-up","level":2,"title":"Next Up","text":"<p>Persisting Decisions, Learnings, and Conventions:  Capture the \"why\" behind your work so it survives across sessions.</p>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/task-management/#see-also","level":2,"title":"See Also","text":"<ul> <li>The Complete Session: full session lifecycle including   task management in context</li> <li>Persisting Decisions, Learnings, and Conventions:   capturing the \"why\" behind your work</li> <li>Detecting and Fixing Drift: keeping TASKS.md accurate over time</li> <li>CLI Reference: full documentation for <code>ctx add</code>, <code>ctx complete</code>, <code>ctx tasks</code></li> <li>Context Files: TASKS.md: format and conventions for TASKS.md</li> </ul>","path":["Recipes","Tracking Work Across Sessions"],"tags":[]},{"location":"recipes/when-to-use-agent-teams/","level":1,"title":"When to Use a Team of Agents","text":"","path":["Recipes","When to Use a Team of Agents"],"tags":[]},{"location":"recipes/when-to-use-agent-teams/#the-problem","level":2,"title":"The Problem","text":"<p>You have a task, and you are wondering: \"should I throw more agents at it?\"</p> <p>More agents can mean faster results, but they also mean coordination overhead, merge conflicts, divergent mental models, and wasted tokens re-reading context. </p> <p>The wrong setup costs more than it saves.</p> <p>This recipe is a decision framework: It helps you choose between a single agent, parallel worktrees, and a full agent team, and explains what <code>ctx</code> provides at each level.</p>","path":["Recipes","When to Use a Team of Agents"],"tags":[]},{"location":"recipes/when-to-use-agent-teams/#the-spectrum","level":2,"title":"The Spectrum","text":"<p>There are three modes, ordered by complexity:</p>","path":["Recipes","When to Use a Team of Agents"],"tags":[]},{"location":"recipes/when-to-use-agent-teams/#1-single-agent-default","level":3,"title":"1. Single Agent (Default)","text":"<p>One agent, one session, one branch. This is correct for most work.</p> <p>Use when:</p> <ul> <li>The task has linear dependencies (step 2 needs step 1's output)</li> <li>Changes touch overlapping files</li> <li>You need tight feedback loops (review each change before the next)</li> <li>The task requires deep understanding of a single area</li> <li>Total effort is less than a few hours of agent time</li> </ul> <p>What <code>ctx</code> provides: Full <code>.context/</code>: tasks, decisions, learnings, conventions, all in one session. </p> <p>The agent builds a coherent mental model and persists it as it goes.</p> <p>Example tasks: Bug fixes, feature implementation, refactoring a module, writing documentation for one area, debugging.</p>","path":["Recipes","When to Use a Team of Agents"],"tags":[]},{"location":"recipes/when-to-use-agent-teams/#2-parallel-worktrees-independent-tracks","level":3,"title":"2. Parallel Worktrees (Independent Tracks)","text":"<p>2-4 agents, each in a separate git worktree on its own branch, working on non-overlapping parts of the codebase.</p> <p>Use when:</p> <ul> <li>You have 5+ independent tasks in the backlog</li> <li>Tasks group cleanly by directory or package</li> <li>File overlap between groups is zero or near-zero</li> <li>Each track can be completed and merged independently</li> <li>You want parallelism without coordination complexity</li> </ul> <p>What <code>ctx</code> provides: Shared <code>.context/</code> via <code>git</code> (each worktree sees the same tasks, decisions, conventions). <code>/ctx-worktree</code> skill for setup and teardown. <code>TASKS.md</code> as a lightweight work queue.</p> <p>Example tasks: Docs + new package + test coverage (three tracks that don't touch the same files). Parallel recipe writing. Independent module development.</p> <p>See: Parallel Agent Development with Git Worktrees</p>","path":["Recipes","When to Use a Team of Agents"],"tags":[]},{"location":"recipes/when-to-use-agent-teams/#3-agent-team-coordinated-swarm","level":3,"title":"3. Agent Team (Coordinated Swarm)","text":"<p>Multiple agents communicating via messages, sharing a task list, with a lead agent coordinating. Claude Code's team/swarm feature.</p> <p>Use when:</p> <ul> <li>Tasks have dependencies but can still partially overlap</li> <li>You need research and implementation happening simultaneously</li> <li>The work requires different roles (researcher, implementer, tester)</li> <li>A lead agent needs to review and integrate others' work</li> <li>The task is large enough that coordination cost is justified</li> </ul> <p>What <code>ctx</code> provides: <code>.context/</code> as shared state that all agents can read. Task tracking for work assignment. Decisions and learnings as team memory that survives individual agent turnover.</p> <p>Example tasks: Large refactor across modules where a lead reviews merges. Research and implementation where one agent explores options while another builds. Multi-file feature that needs integration testing after parallel implementation.</p>","path":["Recipes","When to Use a Team of Agents"],"tags":[]},{"location":"recipes/when-to-use-agent-teams/#the-decision-framework","level":2,"title":"The Decision Framework","text":"<p>Ask these questions in order:</p> <pre><code>Can one agent do this in a reasonable time?\n  YES → Single agent. Stop here.\n  NO  ↓\n\nCan the work be split into non-overlapping file sets?\n  YES → Parallel worktrees (2-4 tracks)\n  NO  ↓\n\nDo the subtasks need to communicate during execution?\n  YES → Agent team with lead coordination\n  NO  → Parallel worktrees with a merge step\n</code></pre>","path":["Recipes","When to Use a Team of Agents"],"tags":[]},{"location":"recipes/when-to-use-agent-teams/#the-file-overlap-test","level":3,"title":"The File Overlap Test","text":"<p>This is the critical decision point. Before choosing multi-agent, list the files each subtask would touch. If two subtasks modify the same file, they belong in the same track (or the same single-agent session).</p> <pre><code>You: \"I want to parallelize these tasks. Which files would each one touch?\"\n\nAgent: [reads TASKS.md, analyzes codebase]\n       \"Task A touches internal/config/ and internal/cli/initialize/\n        Task B touches docs/ and site/\n        Task C touches internal/config/ and internal/cli/status/\n\n        Tasks A and C overlap on internal/config/ — they should be\n        in the same track. Task B is independent.\"\n</code></pre> <p>When in doubt, keep things in one track. A merge conflict in a critical file costs more time than the parallelism saves.</p>","path":["Recipes","When to Use a Team of Agents"],"tags":[]},{"location":"recipes/when-to-use-agent-teams/#when-teams-make-things-worse","level":2,"title":"When Teams Make Things Worse","text":"<p>More agents is not always better. Watch for these patterns:</p> <p>Merge hell. If you are spending more time resolving conflicts than the parallel work saved, you split wrong: Re-group by file overlap.</p> <p>Context divergence: Each agent builds its own mental model. After 30 minutes of independent work, agent A might make assumptions that contradict agent B's approach. Shorter tracks with frequent merges reduce this.</p> <p>Coordination theater: A lead agent spending most of its time assigning tasks, checking status, and sending messages instead of doing work. If the task list is clear enough, worktrees with no communication are cheaper.</p> <p>Re-reading overhead: Every agent reads <code>.context/</code> on startup. A team of 4 agents each reading 4000 tokens of context = 16000 tokens before anyone does any work. For small tasks, that overhead dominates.</p>","path":["Recipes","When to Use a Team of Agents"],"tags":[]},{"location":"recipes/when-to-use-agent-teams/#what-ctx-gives-you-at-each-level","level":2,"title":"What ctx Gives You at Each Level","text":"ctx Feature Single Agent Worktrees Team <code>.context/</code> files Full access Shared via git Shared via filesystem <code>TASKS.md</code> Work queue Split by track Assigned by lead Decisions/Learnings Persisted in session Persisted per branch Persisted by any agent <code>/ctx-next</code> Picks next task Picks within track Lead assigns <code>/ctx-worktree</code> N/A Setup + teardown Optional <code>/ctx-commit</code> Normal commits Per-branch commits Per-agent commits","path":["Recipes","When to Use a Team of Agents"],"tags":[]},{"location":"recipes/when-to-use-agent-teams/#tips","level":2,"title":"Tips","text":"<ul> <li>Start with one agent. Only add parallelism when you have identified   the bottleneck. \"This would go faster with more agents\" is usually   wrong for tasks under 2 hours.</li> <li>The 3-4 agent ceiling is real. Coordination overhead grows   quadratically. 2 agents = 1 communication pair. 4 agents = 6 pairs.   Beyond 4, you are managing agents more than doing work.</li> <li>Worktrees &gt; teams for most parallelism needs. If agents don't   need to talk to each other during execution, worktrees give you   parallelism with zero coordination overhead.</li> <li>Use <code>ctx</code> as the shared brain. Whether it's one agent or four, the   <code>.context/</code> directory is the single source of truth. Decisions go in   <code>DECISIONS.md</code>, not in chat messages between agents.</li> <li>Merge early, merge often. Long-lived parallel branches diverge.   Merge a track as soon as it's done rather than waiting for all tracks   to finish.</li> <li><code>TASKS.md</code> conflicts are normal. Multiple agents completing different   tasks will conflict on merge. The resolution is always additive: accept   all <code>[x]</code> completions from both sides.</li> </ul>","path":["Recipes","When to Use a Team of Agents"],"tags":[]},{"location":"recipes/when-to-use-agent-teams/#go-deeper","level":2,"title":"Go Deeper","text":"<ul> <li>CLI Reference — all commands and flags</li> <li>Integrations — setup for Claude Code, Cursor, Aider</li> <li>Session Journal — browse and search session history</li> </ul>","path":["Recipes","When to Use a Team of Agents"],"tags":[]},{"location":"recipes/when-to-use-agent-teams/#see-also","level":2,"title":"See Also","text":"<ul> <li>Parallel Agent Development with Git Worktrees:   the mechanical \"how\" for worktree-based parallelism</li> <li>Running an Unattended AI Agent: serial autonomous   loops — a different scaling strategy</li> <li>Tracking Work Across Sessions: managing the task   backlog that feeds into any multi-agent setup</li> </ul>","path":["Recipes","When to Use a Team of Agents"],"tags":[]}]}